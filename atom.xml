<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CrissWuBlog</title>
  
  <subtitle>成為一個厲害得普通人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-21T11:12:08.200Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Criss Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端面试总结之JS篇</title>
    <link href="http://yoursite.com/2019/04/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8BJS%E7%AF%87/"/>
    <id>http://yoursite.com/2019/04/21/前端面试总结之JS篇/</id>
    <published>2019-04-21T03:04:20.000Z</published>
    <updated>2019-04-21T11:12:08.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javaScript"><a href="#javaScript" class="headerlink" title="$javaScript"></a>$javaScript</h2><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h3><ul><li>闭包就是能够读取其他函数内部变量的函数</li><li>闭包就是有权访问另一个函数作用域中变量的函数,创建闭包最常见的方式就是在一个函数内创建另一个函数,通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用域链</li></ul><p><strong>闭包的特性</strong></p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外部函数的参数与变量</li><li>参数与变量不会被垃圾回收器回收</li></ul><p><strong>谈谈你对闭包的理解</strong></p><ul><li><p>我认为使用闭包主要为了设计私有的方法和变量.闭包的优点是可以避免全局变量被污染,缺点是闭包会常驻内存,增大内存的使用量,使用不当容易造成内存泄漏,在js中,函数即闭包,只有在函数中才能产生作用域的概念</p></li><li><p>闭包的最大用处有两个,一个是可以读取函数内部的变量,另一个就是让这些变量始终保存在内存中</p></li><li>闭包的另一个用处,是封装对象的私有属性和私有方法.</li></ul><p><strong>闭包的总结</strong></p><ul><li>好处:能够实现封装和缓存等</li><li>坏处:就是消耗内存,使用不当会造成内存泄漏</li><li>解决办法是,在退出函数之前,将不使用的局部变量全部删除</li></ul><h3 id="谈谈你对作用域链的理解"><a href="#谈谈你对作用域链的理解" class="headerlink" title="谈谈你对作用域链的理解"></a>谈谈你对作用域链的理解</h3><ul><li>全局作用域和局部作用域中变量的访问权限,其实是由作用域链决定的</li><li>每次进入一个新的执行环境,都会创建一个用于搜索变量和函数的作用域链.作用域链是函数被创建的作用域中<strong>对象</strong>的集合.作用域链可以保证对执行环境有权访问的变量和函数有序访问</li><li>作用域链最前端始终是当前执行代码所在环境的变量对象(如果该环境是函数,则将其活动对象作为变量对象),下一变量对象来自包含环境(包含当前还运行环境的环境),下一个变量对象来自包含环境的包含环境，依次往上，直到全局执行环境的变量对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。</li></ul><p><strong>总结:</strong>作用域链的变量只能向上访问,变量访问到全局作用域(也就是window对象)即停止访问,作用域链向下访问是不被允许的,简单来说作用域就是变量与函数的可访问范围,即作用域控制这变量与函数的可见性和生命周期</p><h3 id="JavaScript原型-原型链-有什么特点"><a href="#JavaScript原型-原型链-有什么特点" class="headerlink" title="JavaScript原型,原型链?有什么特点?"></a>JavaScript原型,原型链?有什么特点?</h3><ul><li>每个对象都会在其内部初始化一个属性,就是prototype(原型)当我们访问一个对象的属性时,如果这个对象不存在这个属性,那么他就会去prototype里找这个属性,这个prototype会有自己的prototype,于是就这样一直找下去,也就是我们平时所说的原型链的概念</li><li>javascript对象是通过引用来传递的,我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时,与之相关的对象也会继承这一改变.</li><li>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性,如果没有的就会查找他的Prototype对象是否有这个属性，如此递推下去,一直检索到 Object 内建对象.</li></ul><h3 id="请解释什么是事件代理"><a href="#请解释什么是事件代理" class="headerlink" title="请解释什么是事件代理?"></a>请解释什么是事件代理?</h3><ul><li>事件代理(Event Delegation),又称为事件委托.是javascript中常用的绑定事件常用的技巧.顾名思义:’事件代理’即将原本需要绑定的事件委托给父元素,让父元素担当事件监听的职务.事件代理的原理是DOM元素事件冒泡.使用事件代理的好处可以提供性能</li><li>可以大量节省内存,减少事件注册,比如在table上代理所有td的click事件</li><li>可以实现新增子对象时无需再次对其绑定</li></ul><h3 id="谈谈你对this的理解"><a href="#谈谈你对this的理解" class="headerlink" title="谈谈你对this的理解"></a>谈谈你对this的理解</h3><ul><li>this总是指向函数的直接调用者(而非间接调用者)</li><li>如果有new关键字,this指向new出来的这个对象</li><li>在事件中,this指向触发这个事件的对象</li></ul><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><ul><li>W3C中定义了事件发生的三个阶段:捕获阶段(capturing),目标阶段(targetin),冒泡阶段(bubbling)</li><li>冒泡型事件:当你使用事件冒泡时,子级元素先触发,父级元素后触发</li><li>捕获型事件:当你使用事件捕获时,父级元素先触发,子级元素后触发</li><li>DOM事件流:同时支持两种事件模型:捕获事件和冒泡事件</li></ul><h3 id="new操作符具体干了什么"><a href="#new操作符具体干了什么" class="headerlink" title="new操作符具体干了什么?"></a>new操作符具体干了什么?</h3><ul><li>创建一个空对象</li><li>将构造函数的作用域赋给新对象,因此this就指向了这个新对象</li><li>属性和方法被加入到this引用的对象中</li><li>返回新对象</li></ul><h3 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h3><ul><li>Ajax的原理简单来说就是在用户和服务器之间加了一个中间层(AJax引擎),通过XmlhttpRequest对象来向服务器发送异步请求,从服务器获取数据,然后用javascript来操作DOM更新页面,使用户操作与服务器响应异步化,这其中最关键的一步就是从服务器获得请求数据</li><li>Ajax的过程只涉及Javascript,XmlHttpRequest和DOM.XmlhttpRequest是ajax的核心机制</li></ul><p><strong>优点</strong></p><ul><li>通过异步模式,提升了用户体验</li><li>优化了浏览器和服务器之间的传输,减少不必要的数据往返,减少了带宽占用</li><li>Ajax在客户端运行,减少了一部分本来在浏览器承担的工作,减少了大用户量下的服务器负载</li><li>Ajax可以实现动态不刷新(局部刷新)</li></ul><p><strong>缺点</strong></p><ul><li>安全问题Ajax暴露了与服务器交互的细节</li><li>对搜索引擎的支持比较弱,不利用seo优化</li><li>不容易调试</li></ul><h3 id="谈谈你对Webpack的看法"><a href="#谈谈你对Webpack的看法" class="headerlink" title="谈谈你对Webpack的看法"></a>谈谈你对Webpack的看法</h3><ul><li>WebPack是一个模块打包工具,你可以使用WebPack管理你的模块依赖,并编译输出模块们所需要的静态文件.它能够很好的管理,打包web开发中所用到的HTML,Javascript,CSS以及各种静态文件(图片,字体)等,让开发更加高效.对于不同类型的资源,webpack有对应的模块加载器,web模块加载器会分析模块之间的依赖关系,最后生成优化并且合并后的静态资源</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;javaScript&quot;&gt;&lt;a href=&quot;#javaScript&quot; class=&quot;headerlink&quot; title=&quot;$javaScript&quot;&gt;&lt;/a&gt;$javaScript&lt;/h2&gt;&lt;h3 id=&quot;1-闭包&quot;&gt;&lt;a href=&quot;#1-闭包&quot; class=&quot;he
      
    
    </summary>
    
      <category term="前端面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试总结之CSS篇</title>
    <link href="http://yoursite.com/2019/04/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8BCSS%E7%AF%87/"/>
    <id>http://yoursite.com/2019/04/20/前端面试总结之CSS篇/</id>
    <published>2019-04-20T14:40:05.000Z</published>
    <updated>2019-04-21T03:03:39.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h3 id="1-CSS-Sprite是什么-有什么优缺点"><a href="#1-CSS-Sprite是什么-有什么优缺点" class="headerlink" title="1.CSS Sprite是什么?有什么优缺点?"></a>1.CSS Sprite是什么?有什么优缺点?</h3><ul><li>概念: 精灵图片将多个小图片拼接到一个图片中,通过background-postion和元素尺寸调节需要显示的背景图案</li></ul><p><strong>优点</strong></p><ul><li>减少了http请求,极大地提高了页面的加载速度</li><li>增加了图片的信息重复度,提高压缩比,减少了图片大小</li><li>更换风格方便,只需要在一张或几张图片上修改颜色或者样式即可实现</li></ul><p><strong>缺点</strong></p><ul><li>图片合并麻烦</li><li>维护麻烦,修改一个图片可能需要从新布局整个图片,样式.</li></ul><h3 id="2、display-none-与visibility-hidden-的区别"><a href="#2、display-none-与visibility-hidden-的区别" class="headerlink" title="2、display: none;与visibility: hidden;的区别"></a>2、display: none;与visibility: hidden;的区别</h3><ul><li>联系：它们都能让元素不可见</li><li>区别：</li><li>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li><li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式</li><li>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。</li><li>读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容</li></ul><h3 id="3-link和-import的区别"><a href="#3-link和-import的区别" class="headerlink" title="3.link和@import的区别"></a>3.link和@import的区别</h3><ul><li>link是html方式,@import是CSS方式</li><li>link最大限度支持并行下载,@import过多嵌套会导致串行下载,出现fouc</li><li>link可以通过rel=”alternate stylesheet”指定候选样式</li><li>浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式</li><li>@import必须在样式规则之前,可以在CSS文件中引用其他文件</li><li>总结来说: link优于@import</li></ul><h3 id="4-什么是Fouc-如何避免"><a href="#4-什么是Fouc-如何避免" class="headerlink" title="4.什么是Fouc?如何避免?"></a>4.什么是Fouc?如何避免?</h3><ul><li>Flash of Ustyled Content: 用户定义样式表加载之前浏览器使用默认样式显示文档,用户样式加载渲染之后再重新显示文档,造成页面闪烁;</li><li><strong>解决办法</strong>:把样式表放到文档的head</li></ul><h3 id="5-清除浮动的几种方式，各自的优缺点"><a href="#5-清除浮动的几种方式，各自的优缺点" class="headerlink" title="5.清除浮动的几种方式，各自的优缺点"></a>5.清除浮动的几种方式，各自的优缺点</h3><ul><li>父级定义height</li><li>结尾处加空div标签:clear:both</li><li>父级div定义伪类:after和zoom</li><li>父级div定义overflow:hidden;</li><li>父级也浮动:需要定义宽度</li><li>结尾处加br标签clear:both</li></ul><h3 id="6-为什么要初始化CSS样式"><a href="#6-为什么要初始化CSS样式" class="headerlink" title="6.为什么要初始化CSS样式?"></a>6.为什么要初始化CSS样式?</h3><ul><li>为什么浏览器的兼容问题,不同浏览器对有些标签的默认是不同的,如果没有对CSS进行初始化往往会出现浏览器之间的页面显示差异</li><li>当然,初始化样式会对SEO有一定的影响,但是鱼和熊掌不可兼得,但是力求在影响最小的情况下进行初始化</li></ul><h3 id="7-CSS3有哪些新特性"><a href="#7-CSS3有哪些新特性" class="headerlink" title="7.CSS3有哪些新特性?"></a>7.CSS3有哪些新特性?</h3><ul><li>新增各种css选择器</li><li>圆角border-radius</li><li>多列布局</li><li>阴影和反射</li><li>文字特效 text-shadow</li><li>线性渐变</li><li>旋转 transform</li></ul><h3 id="8-CSS3新增的伪类有哪些"><a href="#8-CSS3新增的伪类有哪些" class="headerlink" title="8.CSS3新增的伪类有哪些?"></a>8.CSS3新增的伪类有哪些?</h3><ul><li>p:first-of-type 选择属于其父元素的首个p元素的每一个p元素</li><li>p:last-of-type 选择属于其父元素的最后p元素的每个p元素 </li><li>p:only-of-type 选择属于其父元素唯一的p元素的每个p元素</li><li>p:only-child  选择属于其父元素的唯一子元素的每个p元素</li><li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个p元素</li><li>:after在元素之前添加内容,也可以用来清除浮动</li><li>:before在元素之后添加内容</li><li>:enabled</li><li>:disabled 控件表单控件的禁用状态</li><li>:checked单选框或复选框被选中</li></ul><h3 id="9-display有哪些值-说明他的作用"><a href="#9-display有哪些值-说明他的作用" class="headerlink" title="9.display有哪些值 说明他的作用"></a>9.display有哪些值 说明他的作用</h3><ul><li>block 转化成块状元素</li><li>none: 像行内元素那样显示</li><li>inline-block 像行内元素一样显示,但是其内容像块类型元素一样显示</li><li>list-item 像块级元素一样显示,并添加样式列表标记</li><li>table 此元素会作为块级表格来显示</li><li>inherit 规定应该从父元素继承 display 属性的值</li></ul><h3 id="10-介绍一下标准的CSS盒子模型-低版本IE的盒子模型有什么不同"><a href="#10-介绍一下标准的CSS盒子模型-低版本IE的盒子模型有什么不同" class="headerlink" title="10.介绍一下标准的CSS盒子模型?低版本IE的盒子模型有什么不同?"></a>10.介绍一下标准的CSS盒子模型?低版本IE的盒子模型有什么不同?</h3><ul><li>有两种,IE盒子模型,W3C盒子模型</li><li>盒模型:内容(content),填充(padding),边界(margin),边框(border)</li><li>区别: IE的content把padding和border计算进去了</li></ul><h3 id="11-CSS优先级算法如何计算"><a href="#11-CSS优先级算法如何计算" class="headerlink" title="11.CSS优先级算法如何计算?"></a>11.CSS优先级算法如何计算?</h3><ul><li>优先就近原则,同权重情况下样式定义最近者为准.</li><li>载入样式以最后载入的定位为准</li><li>优先级:!important &gt; id &gt; class&gt; tag &gt;important比内联优先级高!!!</li></ul><h3 id="12-谈谈浮动和清除浮动"><a href="#12-谈谈浮动和清除浮动" class="headerlink" title="12.谈谈浮动和清除浮动"></a>12.谈谈浮动和清除浮动</h3><ul><li>浮动的框可以向左向右浮动,直到他的外边缘碰到包含框或者另一个浮动框为止.由于浮动框不在普通文档流中,所以文档中的普通的快框表现得就像浮动框不存在一样.浮动框会漂浮在文档普通流的快框上.</li></ul><h3 id="13-position的值-relative和absolute定位原点是"><a href="#13-position的值-relative和absolute定位原点是" class="headerlink" title="13.position的值,relative和absolute定位原点是"></a>13.position的值,relative和absolute定位原点是</h3><ul><li>absolute:生成绝对定位的元素,相对于static定位以外的第一个父元素进行定位</li><li>fixed:生成固定定位的元素,相对于浏览器窗口进行定位</li><li>relative:生成相对定位的元素,相对于其正常位置进行定位</li><li>static:默认值,没有定位,元素出现在正常的文档流中</li><li>inherit:规定从父元素继承position的值</li></ul><h3 id="14-PNG-JPG-GIF的区别及如何选择"><a href="#14-PNG-JPG-GIF的区别及如何选择" class="headerlink" title="14.PNG,JPG,GIF的区别及如何选择"></a>14.PNG,JPG,GIF的区别及如何选择</h3><ul><li><p>GIF</p><ul><li>8位像素,256色</li><li>无损压缩</li><li>支持简单动画</li><li>支持boolean透明</li><li>适合简单动画</li></ul></li><li><p>JPEG</p><ul><li>颜色限于256</li><li>有损压缩</li><li>可控制压缩质量</li><li>不支持透明</li><li>适合照片</li></ul></li><li><p>PNG</p><ul><li>适合图标,背景,按钮</li></ul></li></ul><h3 id="15-行内元素float-left后是否变为块级元素"><a href="#15-行内元素float-left后是否变为块级元素" class="headerlink" title="15.行内元素float:left后是否变为块级元素"></a>15.行内元素float:left后是否变为块级元素</h3><ul><li>浮动后,行内元素不会变成块级元素,但是浮动元素可以设置宽高,行内元素如果想变成块级元素可以设置display:block,但是如果浮动以后设置,那么就不会独占一行</li></ul><h3 id="16-在网页应该使用奇数还是偶数字体-为什么"><a href="#16-在网页应该使用奇数还是偶数字体-为什么" class="headerlink" title="16.在网页应该使用奇数还是偶数字体?为什么?"></a>16.在网页应该使用奇数还是偶数字体?为什么?</h3><ul><li>偶数字体相对来说更容易和Web设计的其他部分构成比例</li></ul><h3 id="17-before和-after中双冒号和单冒号-有什么区别-解释一下这两个伪元素的作用"><a href="#17-before和-after中双冒号和单冒号-有什么区别-解释一下这两个伪元素的作用" class="headerlink" title="17.::before和:after中双冒号和单冒号 有什么区别?解释一下这两个伪元素的作用"></a>17.::before和:after中双冒号和单冒号 有什么区别?解释一下这两个伪元素的作用</h3><ul><li>单冒号(:)用于css3伪类,双冒号用于(::)css3伪元素</li><li>用于区分伪类和伪元素</li></ul><h3 id="18-列出你所知道的可以改变页面布局的属性"><a href="#18-列出你所知道的可以改变页面布局的属性" class="headerlink" title="18.列出你所知道的可以改变页面布局的属性"></a>18.列出你所知道的可以改变页面布局的属性</h3><ul><li>position,display,margin,padding,border,width,height,top,left,right</li></ul><h3 id="19-CSS在性能优化方面的实践"><a href="#19-CSS在性能优化方面的实践" class="headerlink" title="19.CSS在性能优化方面的实践"></a>19.CSS在性能优化方面的实践</h3><ul><li>css压缩与合并,Gzip压缩</li><li>css文件放在head里,不使用@import</li><li>尽量用缩写,避免用滤镜,合理使用选择器</li></ul><h3 id="20-CSS3动画-简单动画的实现-如旋转"><a href="#20-CSS3动画-简单动画的实现-如旋转" class="headerlink" title="20.CSS3动画(简单动画的实现,如旋转)"></a>20.CSS3动画(简单动画的实现,如旋转)</h3><ul><li>依靠css3中提出的三个属性:transition,transform,animation</li><li>transtion:定义了元素在变化过程中是怎么样的</li><li>transform:定义了元素变化的结果:包含rotate,scale,skew,trasnlate</li><li>animation:动画定义了动作每一帧(@keyframes)有什么效果.</li></ul><h3 id="sass-less的区别"><a href="#sass-less的区别" class="headerlink" title="sass/less的区别"></a>sass/less的区别</h3><ul><li>均含有’变量’,’混合’,’嵌套’,’继承’,’颜色混合’五大基本特性</li><li>sass没有全局变量的概念</li><li>sass基于ruby语言的,less是基于node.js下的npm的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS部分&quot;&gt;&lt;a href=&quot;#CSS部分&quot; class=&quot;headerlink&quot; title=&quot;CSS部分&quot;&gt;&lt;/a&gt;CSS部分&lt;/h2&gt;&lt;h3 id=&quot;1-CSS-Sprite是什么-有什么优缺点&quot;&gt;&lt;a href=&quot;#1-CSS-Sprite是什么-有什么
      
    
    </summary>
    
      <category term="前端面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>区分伪类与伪元素</title>
    <link href="http://yoursite.com/2019/04/19/%E5%8C%BA%E5%88%86%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/04/19/区分伪类与伪元素/</id>
    <published>2019-04-18T23:36:48.000Z</published>
    <updated>2019-04-19T01:30:33.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区分伪类与伪元素"><a href="#区分伪类与伪元素" class="headerlink" title="区分伪类与伪元素"></a>区分伪类与伪元素</h2><h3 id="一-伪类"><a href="#一-伪类" class="headerlink" title="一:伪类"></a>一:伪类</h3><p><strong>1:定义:</strong></p><ul><li>css伪类用于向某些选择器添加特殊效果(本质还是一个类,因此主要作用仍然是用来选择元素而后设定具体的样式)</li><li>伪类其实与普通css类相似,可以为已有的元素添加样式,但是他只有在处于DOM无法描述的状态才能为文档树中的元素添加样式,所以称其为伪类.(这种文档树无法描述的状态是什么呢?,当一个元素在用户不同行为下,就变化成不同的状态这个行为的变化dom就无法描述,就要产生伪类,来为一些选择器添加特殊的效果)</li><li>应用场景:用户的交互动作(悬停,激活)等会导致元素状态发生变化,这时class对这些动态变化无能为力</li></ul><p><strong>2.什么是文档树(DOM)?</strong></p><ul><li>DOM实际上是以面向对象的方式描述的文档模型,DOM定义了表示修改文档所需的对象,这些对象的行为和属性,以及这些对象之间的关系,所以可以把DOM认为是页面上数据与结构的一个树形表示.</li></ul><p><strong>3.伪类选择器有哪些:</strong></p><ol><li>:link向未被选中的链接添加样式</li><li>:visited向已被访问过的链接添加样式</li><li>:hover当鼠标悬浮在元素时,向元素添加样式(没有特别指定是链接,所以这个标签被大量用于定义任何一个块/行元素在鼠标经过时的样式)</li><li>:active向被激活的元素添加样式(当鼠标点击时的样式,要主要是点击时的样式变化,这个也不是只有超链接才能用的伪类选择器)</li><li>:focus向用于键盘输入焦点的元素添加样式(比如input输入框鼠标点击时产生背景颜色的变化,注意是键盘输入焦点,有些浏览器不支持)</li><li>:first-child<ul><li>用于匹配父元素中的第一个元素.例如E:first-child,找的是E元素，E元素必须是他的父元素的第一位元素(扩展:nth-child(n))用于匹配父元素的第n个元素E,这个父元素必须是元素E的父元素</li></ul></li><li>:lang向带有指定lang属性的元素添加样式,（在标签中设置lang的属性，在样式表中对这种确切lang属性值的元素进行样式的设定，即使你有能力为不同的语言定义特殊的规则）</li></ol><p><strong>4.注意:</strong></p><ul><li>伪类选择器:”link”和”visited”只能用于定义链接的未被访问的样式和已被访问过的样式</li><li>伪类选择器: “hover”和:active可以用于定义任何一个块或行元素在鼠标经过时点击时的样式</li></ul><p><strong>5.重点:</strong></p><ul><li>上述:四个伪类选择器的顺序必须是固定的.否则将不会产生期望中的变化.</li><li>记忆技巧:love  hate(变化)</li></ul><h3 id="二-伪元素"><a href="#二-伪元素" class="headerlink" title="二:伪元素"></a>二:伪元素</h3><p><strong>1.伪元素</strong></p><ul><li>用于创建一些文档树中的元素,并且为他添加样式,举个列子:使用伪元素”::bofore”可以在一个元素后面创建一个新的元素,增加一些文本,并且为这个文本添加样式,虽然用户可以在页面上看到一些文本,但是这些文本是不存在于文档树中的.</li></ul><p><strong>2.几种常见的伪元素</strong></p><ol><li>:first-letter用于向文本中第一个字母添加样式</li><li>:first-line用于向文本的首行添加样式</li><li>:before在元素之前添加内容</li><li>:after在元素之后添加内容</li></ol><h3 id="三-伪元素和伪类的区别"><a href="#三-伪元素和伪类的区别" class="headerlink" title="三:伪元素和伪类的区别:"></a>三:伪元素和伪类的区别:</h3><ol><li>伪类和伪元素的最大区别就在于有没有创建一个文档树以外的元素,伪元素创建了一个伪元素以外的元素(虚拟容器)并为它添加样式,这个容器不包含任何DOM元素但是可以包含内容.</li><li>换句话说,伪类和伪元素的区别就是伪类的操作对象是文档树中已有的元素,而伪元素则创建了一个文档树以外的元素.</li><li>伪类使用的是单冒号,但是在css3中伪元素使用的是双冒号,但是除了少部分的伪元素必须使用双冒号以外,像after还有before都是支持单引号的.为了兼容性,所以目前还是在使用一些常见的伪元素的时候还是采用单冒号比较委托</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区分伪类与伪元素&quot;&gt;&lt;a href=&quot;#区分伪类与伪元素&quot; class=&quot;headerlink&quot; title=&quot;区分伪类与伪元素&quot;&gt;&lt;/a&gt;区分伪类与伪元素&lt;/h2&gt;&lt;h3 id=&quot;一-伪类&quot;&gt;&lt;a href=&quot;#一-伪类&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="CSS选择器" scheme="http://yoursite.com/categories/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
    
      <category term="伪类" scheme="http://yoursite.com/tags/%E4%BC%AA%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>js执行上下文理解</title>
    <link href="http://yoursite.com/2019/04/15/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/15/js执行上下文理解/</id>
    <published>2019-04-15T12:42:04.000Z</published>
    <updated>2019-04-15T13:08:22.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javascript执行上下文理解"><a href="#javascript执行上下文理解" class="headerlink" title="javascript执行上下文理解"></a>javascript执行上下文理解</h2><blockquote><p>可以理解当前代码的运行环境,代码的运行环境分为三种:</p><ol><li>全局级别的代码</li><li>函数级别的代码</li><li>Eval的代码 -在Eval函数函数体内运行的代码</li></ol></blockquote><ul><li>注意一点: 作用域在函数定义完的时候就已经创建了,而不是在函数调用的时候,这点特点重要</li><li>然后按照程序执行的顺序,一步步把各个上下文环境加上</li></ul><ol><li>第一步首先在加载程序的时候,就已经确定了全局的上下文环境,并随着程序的的执行改变对变量的赋值</li><li>函数的执行上下文是在调用函数后建立的,执行上下文的第一个阶段时在函数调用后,在代码执行之前的进行,执行上下文的第二个阶段时在具体代码执行的时候进行</li><li>作用域只是一个’区域’,一个抽象的概念,其中没有变量的,要通过作用域对应的执行上下环境来获取响应的变量,同一个作用域下,不同的调用会产生不同的的执行上下文环境,继而产生不同的变量</li><li>所以,如果要一个作用域下某个变量的值,就需要找到这个作用域对应的执行上下文环境,在其中变量的值.</li></ol><h3 id="执行上下文栈的理解"><a href="#执行上下文栈的理解" class="headerlink" title="执行上下文栈的理解"></a>执行上下文栈的理解</h3><ul><li>在浏览器中,javascript引起的工作方式是单线程的,也就是说,某一时刻只有唯一的一个事件是被激活处理的.其他事件被放入列中,等待处理</li><li>具体的工作原理:<ul><li>在js代码文件被浏览器载入后,默认最先进入的是一个全局的执行上下文,当在上下文中调用一个执行函数时,程序就会进入该被调用的函数内,此时在引擎就会为该函数创建一个新的执行上下文环境,并且将其压入到执行上下文堆栈的顶部,浏览器总是执行上下文对栈顶部的上下文,一旦执行完毕,该上下文环境就会被弹出,然后,进入其中的上下文执行代码,这样堆栈中上下文就会被弹出.只到只剩下全局的上下文.</li></ul></li></ul><h3 id="执行上下文的建立过程"><a href="#执行上下文的建立过程" class="headerlink" title="执行上下文的建立过程"></a>执行上下文的建立过程</h3><ul><li>我们已经知道,每当我们调用一个函数时,一个新的执行上下文就会被创建出来,然而在js内部,这个过程分为两个阶段</li></ul><p><strong>建立阶段</strong></p><ol><li>建立阶段(发生在函数调用之后,在执行函数内部具体代码之前)</li><li>建立变量,函数,参数对象,并给参数赋值</li><li>建立作用域链</li><li>确定this值</li><li>也就是说除了argument,函数声明,以及参数被赋予的具体的值,其他变量值都是undefined</li></ol><p><strong>执行阶段</strong></p><ol><li>变量赋值,执行其他代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">            console.log(typeof foo); // function pointer</span><br><span class="line">            console.log(typeof bar); // undefined</span><br><span class="line"></span><br><span class="line">            var foo = &apos;hello&apos;,</span><br><span class="line">                bar = function() &#123;</span><br><span class="line">                    return &apos;world&apos;;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            function foo() &#123;</span><br><span class="line">                return &apos;hello&apos;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;());​</span><br></pre></td></tr></table></figure><ul><li>问题一:为什么我们可以在声明foo变量以前就可以访问到foo呢？</li><li>因为在上下文的建立阶段,显示处理参数声明,然后是函数声明,最后才是变量声明,</li></ul><ol><li>在发现foo函数声明后,就会在variableObject下面建立一个foo属性,其值是一个指向函数的引用,当处理变量声明的时候,发现有var foo的声明,但是variableObject已经具有foo属性,所以函数声明会忽略后来的变量声明.</li></ol><ul><li>问题二:为什么bar是undefined呢?</li></ul><ol><li>因为bar是变量的声明,在建立阶段的时候,被赋予的默认的值是undefined,由于它只有在代码执行阶段才会被赋予具体的值.所以在调用typeof(bar)输出值的时候,输出undefined.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    console.log(typeof foo); //function</span><br><span class="line">    var foo；</span><br><span class="line">    function foo()&#123;&#125;； </span><br><span class="line">    //因为在执行上下文的准备阶段中先找函数声明，后找变量声明，所以取前面的函数声明，忽略后面的同名的变量声明，即在fooExecutionContext里会生成一句：foo: pointer to function c()，即foo的属性值为指向函数c()的指针</span><br><span class="line"></span><br><span class="line">    foo = &quot;foo&quot;;  //执行上下文的执行阶段，会对变量进行赋值，会把foo的值赋为&quot;foo&quot;</span><br><span class="line">    console.log(typeof foo); //string.对foo的string赋值会覆盖掉foo的原来的属性值，它原来的属性值为指向函数c()的指针，现在在fooExecutionContext里名为foo的属性为foo: &quot;foo&quot;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line"></span><br><span class="line">    alert(typeof foo);//undefined</span><br><span class="line"></span><br><span class="line">    var foo=function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;//同名的变量，只不过其中一个赋值为函数。按照在执行上下文的准备阶段中先找函数声明，后找变量声明，但两个都为变量，他俩优先级相同，js引擎默认取前面的声明，忽略后面的声明。故最终fooExecutionContext里会生成一句：foo: undefined。</span><br><span class="line">    var foo=&quot;foo&quot;;</span><br><span class="line"></span><br><span class="line">    alert(typeof foo);//string，因为执行上下文的执行阶段，会对变量进行赋值，这个就是按照代码的先后顺序执行了，所以typeof foo为string.</span><br><span class="line">    &#125;;</span><br><span class="line"> a();</span><br></pre></td></tr></table></figure><ul><li><p>总的来说,在建立执行上下文阶段,声明不重要,重要的是执行阶段的赋值,不管建立阶段执行上下文阶段的时候一个属性声明是怎么样的.仍旧可以被的赋值成不同类型的值.这也就是为什么javascript是弱类型语言.</p></li><li><p>在执行上下文第一阶段的准备阶段里变量的声明总结起来有三条:</p><ol><li>函数形参在声明的时候已经指定其形参的值.</li><li>之前的函数声明会忽略之后再声明的同名声明,不是后来同名声明是函数声明还是变量声明.</li><li>普通的变量声明,不会覆盖之前的同名声明,会被忽略此次声明.</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;javascript执行上下文理解&quot;&gt;&lt;a href=&quot;#javascript执行上下文理解&quot; class=&quot;headerlink&quot; title=&quot;javascript执行上下文理解&quot;&gt;&lt;/a&gt;javascript执行上下文理解&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="js执行上下文环境" scheme="http://yoursite.com/categories/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="js深入了解" scheme="http://yoursite.com/tags/js%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>this指针问题总结</title>
    <link href="http://yoursite.com/2019/04/15/this%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/15/this指针问题总结/</id>
    <published>2019-04-15T12:35:39.000Z</published>
    <updated>2019-04-15T12:41:04.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this指针问题总结"><a href="#this指针问题总结" class="headerlink" title="this指针问题总结"></a>this指针问题总结</h2><h3 id="this实例代码"><a href="#this实例代码" class="headerlink" title="this实例代码"></a>this实例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个全局变量</span><br><span class="line">var type = &quot;全局&quot;; </span><br><span class="line"> </span><br><span class="line">// 定义函数aa</span><br><span class="line">function aa () &#123;</span><br><span class="line">var type = &apos;局部&apos;;</span><br><span class="line">console.log(this.type);</span><br><span class="line">&#125;</span><br><span class="line">aa(); // &quot;全局&quot;</span><br><span class="line"> </span><br><span class="line">// 定义对象bb</span><br><span class="line">var bb = &#123;</span><br><span class="line">type: &apos;局部&apos;,</span><br><span class="line">getType: function () &#123;</span><br><span class="line">console.log(this.type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bb.getType(); // “局部”</span><br><span class="line"> </span><br><span class="line">// 定义对象cc</span><br><span class="line">var cc = &#123;</span><br><span class="line">type: &apos;局部&apos;,</span><br><span class="line">getType: function () &#123;</span><br><span class="line">return function () &#123;</span><br><span class="line">return this.type</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">cc.getType(); // “全局”（非严格模式下）</span><br></pre></td></tr></table></figure><ol><li>第一个函数的运行在全局环境中.所以this指向window.</li><li>bb是一个对象,当函数作为一个对象的方法被调用时,this指向调用的对象</li><li>cc第三个比较复杂,这个和JS的活动对象有关。每个函数在被调用时，其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索其活动对象为止，活动对象为当前所在执行环境的变量对象，当前所在的执行环境是一个立即执行的匿名函数，变量对象里并没有this.type，所以this还是指向window。</li></ol><h3 id="改变this的几种方法"><a href="#改变this的几种方法" class="headerlink" title="改变this的几种方法**"></a>改变this的几种方法**</h3><p><strong>1.apply()接收两个参数,一作用域,二是参数(可以是数组也可以是arguments对象)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function test (test1, test2) &#123;</span><br><span class="line">console.log(test1 + test2);</span><br><span class="line">&#125;</span><br><span class="line">function applyTest1 (test1, test2) &#123;</span><br><span class="line">return test.apply(this, [test1, test2]); // 传入数组</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function applyTest2 (test1, test2) &#123;</span><br><span class="line">return test.apply(this, arguments); // 传入arguments</span><br><span class="line">&#125;</span><br><span class="line">applyTest1 (50, 50); // 100</span><br><span class="line">applyTest2 (50, 50); // 100</span><br></pre></td></tr></table></figure></p><ul><li>这个例子里将test函数的this指向了applyTest系列函数，同时参数为applyTest系列函数传入的参数为数组和arguments对象都可以正常执行并返回正确的结果。</li></ul><p><strong>2.call()</strong></p><ul><li><p>call()的使用和apply()基本是一样的，不同的是参数的传递，call()必须明确的传入每一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test (test1, test2) &#123;</span><br><span class="line">console.log(test1 + test2);</span><br><span class="line">&#125;</span><br><span class="line">function applyTest1 (test1, test2) &#123;</span><br><span class="line">return test.call(this, test1, test2); // 明确传入参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当然，传递参数并不是apply()和call()真正的用武之地，其真正强大的地方还是在于通过传入作用域来扩充函数赖以运行的作用域。通过传入的作用域不同，来改变函数的this指向.</p></li></ul><h3 id="call-方法和apply-方法的区别"><a href="#call-方法和apply-方法的区别" class="headerlink" title="call()方法和apply()方法的区别."></a>call()方法和apply()方法的区别.</h3><ul><li>相同点: 都用来改变this的指向 都是调用一个对象的方法,(功能相同)</li><li>例如： B.call(A, args1,args2);即A对象调用B对象的方法 F.apply(G, arguments);即G对象应用F对象的方法</li><li>不同点: 参数书写方式不同.<ul><li>call()第一个参数是this需要指向的对象.后来是参数列表,可以是任意类型的值.当第一个参数为null/undefined时.默认指向window.</li><li>apply():第一个参数是this所要指向的对象.第二个参数是一个数组.</li></ul></li></ul><h3 id="call和bind区别"><a href="#call和bind区别" class="headerlink" title="call和bind区别"></a>call和bind区别</h3><ul><li>相同点:都是用来改变this的指向</li><li>不同点:call改变this指向后,会立即执行函数,bind改过this后,不执行函数,会返回一个绑定新this的函数.需要手动调用</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li>call的应用</li><li>利用call()来判断数据类型</li><li><p>在判断数据类形式使用typeof，一般不是太准确的，我们可以使用Object.prototype.toString.call()方法来判断一个数据的数据类型.</p></li><li><p>使用apply可以找出数组中的最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,4,5,1];</span><br><span class="line">console.log(Math.max.apply(arr,[2,4,5,1]));</span><br></pre></td></tr></table></figure></li><li><p>注意:Math是一个对象, 第一个arr表示让arr借用max这个方法,相当于替换了Math对象.第二个参数是数组.</p></li><li>apply(执行的操作)1.执行Math.max[1,2,3,5];2.把内部的this改成arr</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;this指针问题总结&quot;&gt;&lt;a href=&quot;#this指针问题总结&quot; class=&quot;headerlink&quot; title=&quot;this指针问题总结&quot;&gt;&lt;/a&gt;this指针问题总结&lt;/h2&gt;&lt;h3 id=&quot;this实例代码&quot;&gt;&lt;a href=&quot;#this实例代码&quot; cla
      
    
    </summary>
    
      <category term="this指针" scheme="http://yoursite.com/categories/this%E6%8C%87%E9%92%88/"/>
    
    
      <category term="-this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>js常用字符串方法总结归纳</title>
    <link href="http://yoursite.com/2019/04/15/js%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    <id>http://yoursite.com/2019/04/15/js常用字符串方法总结归纳/</id>
    <published>2019-04-15T01:38:30.000Z</published>
    <updated>2019-04-15T02:08:53.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用JS-string字符串方法"><a href="#常用JS-string字符串方法" class="headerlink" title="常用JS-string字符串方法"></a>常用JS-string字符串方法</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>我们刚刚总结了数组的一些常用方法,这次我们来总结一下字符串的常用方法,总结完希望对数组和字符串的方法有一个清楚的认知</p></blockquote><h3 id="1-字符串的分割"><a href="#1-字符串的分割" class="headerlink" title="1.字符串的分割"></a>1.字符串的分割</h3><h3 id="1-slice-start-end"><a href="#1-slice-start-end" class="headerlink" title="1. slice(start,end)"></a><strong>1. slice(start,end)</strong></h3><ul><li>关于这个方法,要搞懂四个关键点<ol><li>截取时的下标不包括下标为<strong>end</strong>的元素</li><li>end是可选参数,没有时,默认从start截取到结束的所有字符串</li><li>String.slice与Array.slice区别</li><li>参数:参数为负数时,是如何处理的?</li></ol></li></ul><h3 id="2-substr-start-length"><a href="#2-substr-start-length" class="headerlink" title="2. substr(start,length)"></a><strong>2. substr(start,length)</strong></h3><ul><li>关于这个方法,也有几个要搞懂的点<ol><li>第二个参数是字符串中的字符数,必须是数值.可以没有</li><li>参数为负数时,如何进行处理</li><li>最重要的一点来自官网说明,如下所示</li></ol></li><li>由于substr()的参数指定了子串的开始位置和长度,因此可以使用substring(),slice()代替使用它</li></ul><h3 id="3-substring-start-end"><a href="#3-substring-start-end" class="headerlink" title="3. substring()(start,end)"></a><strong>3. substring()(start,end)</strong></h3><ul><li>和slice类型,关于这个方法,同样需要搞懂几个关键点：<ol><li>返回的字符串中不包括<strong>end</strong>处的字符</li><li>参数为负数时如何进行处理</li><li>如果参数 start 与 stop 相等，那么该方法返回的就是一个空串(即长度为 0 的字符串)</li><li>如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数</li></ol></li></ul><p><strong>区别和使用</strong></p><ol><li>都接收两个参数,slice和substring接收的是起始位置和结束位置(注意:不包括结束位置),而substr接收的则是起始位置和索要返回的字符串的长度</li><li>需要注意的是:substring是以两个参数中较小的一个作为起始位置,较大的参数作为结束位置</li></ol><h3 id="4-split-字符串-正则-length"><a href="#4-split-字符串-正则-length" class="headerlink" title="4.split(字符串/正则,length)"></a><strong>4.split(字符串/正则,length)</strong></h3><ul><li>split()把一个字符串string分割成判断创建一个字符串数组,可选的参数1指定字符串或正则,参数2指定数组的最大长度</li></ul><p><strong>5. replace(seacrchValue,replaceValue)</strong></p><ul><li>作用:replace方法对string进行查找和替换操作,并返回一个新的字符串</li><li>取值:参数searchValue可以是一个字符串或者一个正则表达式对象</li><li>第一种情况:如果searchValue是一个字符串,那么searchValue只会在第一次出现的地方替换</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用JS-string字符串方法&quot;&gt;&lt;a href=&quot;#常用JS-string字符串方法&quot; class=&quot;headerlink&quot; title=&quot;常用JS-string字符串方法&quot;&gt;&lt;/a&gt;常用JS-string字符串方法&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="字符串方法总结" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="javascript基础" scheme="http://yoursite.com/tags/javascript%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数组方法总结归纳</title>
    <link href="http://yoursite.com/2019/04/14/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    <id>http://yoursite.com/2019/04/14/数组方法总结归纳/</id>
    <published>2019-04-14T12:54:21.000Z</published>
    <updated>2019-04-15T01:35:30.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js中常用的数组方法的总结"><a href="#js中常用的数组方法的总结" class="headerlink" title="js中常用的数组方法的总结"></a>js中常用的数组方法的总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>我认为学习完一个知识点,想要真正掌握它,最好的方式就是你用自己的话把内容表达清楚,现在我开始将以前学习的关于数组的知识整合起来,和大家一起提高</p></blockquote><h3 id="1-Array-map"><a href="#1-Array-map" class="headerlink" title="1.Array.map()"></a>1.Array.map()</h3><ul><li>此方法是将数组中的每一元素调用一个提供的函数</li><li>作用:数组中的元素为原始数组调用函数处理后的值</li><li>参数:arr.map(function(item,index,arr){}) item:每一项,index:当前索引,ary:当前数组</li><li>返回值:作为一个新的数组返回</li><li>是否改变原始数组:不改变原数组,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">    let newArr = arr.map(x =&gt; x*2)</span><br><span class="line">    //arr= [1, 2, 3, 4, 5]   原数组保持不变</span><br><span class="line">    //newArr = [2, 4, 6, 8, 10] 返回新数组</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Array-forEach"><a href="#2-Array-forEach" class="headerlink" title="2.Array.forEach()"></a>2.Array.forEach()</h3><ul><li>此方法是将数组中的每一个元素执行提供的函数,没有返回值,直接改变原数组,注意与map方法区分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">   arr.forEach(x =&gt; x*2)</span><br><span class="line">   // arr = [2, 4, 6, 8, 10]  数组改变,注意和map区分</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-Array-filter"><a href="#3-Array-filter" class="headerlink" title="3.Array.filter()"></a>3.Array.filter()</h3><ul><li>此方法是将所有的元素进行判断,将满足条件的元素作为一个新数组返回,</li><li>作用:创建一个新数组,新数组中的元素是通过检查指定数组中符合条件的所有元素</li><li>返回值:返回一个新数组,</li><li>是否改变原始数组:不会改变原始数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">    const isBigEnough =&gt; value =&gt; value &gt;= 3</span><br><span class="line">    let newArr = arr.filter(isBigEnough )</span><br><span class="line">    //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-Array-some"><a href="#4-Array-some" class="headerlink" title="4.Array.some()"></a>4.Array.some()</h3><ul><li>此方法是将所有元素都进行判断返回一个布尔值,如果存在元素都满足判断条件,</li><li>作用:检测数组中的元素是否满足指定条件</li><li>返回值:布尔值则返回true,若所有元素都不满足判断条件,则返回fasle</li><li>是否改变原始数组: 不改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr= [1, 2, 3, 4, 5]</span><br><span class="line">    const isLessThan4 =&gt; value =&gt; value &lt; 4</span><br><span class="line">    const isLessThan6 =&gt; value =&gt; value &gt; 6</span><br><span class="line">    arr.some(isLessThan4 ) //true</span><br><span class="line">    arr.some(isLessThan6 ) //false</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-Array-reduce"><a href="#5-Array-reduce" class="headerlink" title="5.Array.reduce()"></a>5.Array.reduce()</h3><ul><li>此方法是所有元素调用返回函数,返回值为最后结果,传入的值必须是函数类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">   const add = (a, b) =&gt; a + b</span><br><span class="line">   let sum = arr.reduce(add)</span><br><span class="line">   //sum = 15  相当于累加的效果</span><br><span class="line">   与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-Array-push"><a href="#6-Array-push" class="headerlink" title="6.Array.push()"></a>6.Array.push()</h3><ul><li>作用:此方法在数组的后面添加新元素</li><li>参数:要添加的项</li><li>返回值:新数组的长度</li><li>是否改变原数组:改变</li></ul><h3 id="7-Array-pop"><a href="#7-Array-pop" class="headerlink" title="7.Array.pop()"></a>7.Array.pop()</h3><ul><li>作用:pop为从数组中删除最后一个元素</li><li>参数:无</li><li>返回值:被删除的项</li><li>是否改变原数组:改变</li><li>数组为空时返回undefined。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].pop();</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-Array-unshift"><a href="#8-Array-unshift" class="headerlink" title="8.Array.unshift()"></a>8.Array.unshift()</h3><ul><li>作用:此方法是将一个或多个元素添加到数组的开头</li><li>参数:要添加的项,多项用逗号隔开</li><li>返回值:返回新数组的长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">    arr.unshift(6, 7)</span><br><span class="line">    console.log(arr) //[6, 7, 2, 3, 4, 5]</span><br><span class="line">    console.log(arr.length) //7</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-Array-shift"><a href="#9-Array-shift" class="headerlink" title="9.Array.shift()"></a>9.Array.shift()</h3><ul><li>作用:此方法在数组后面删除第一个元素</li><li>返回值:并返回被删除的项</li><li>是否改变原数组:改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">    arr.shift()</span><br><span class="line">    console.log(arr) //[2, 3, 4, 5]</span><br><span class="line">    console.log(arr.length) //4</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-Array-isArray"><a href="#10-Array-isArray" class="headerlink" title="10.Array.isArray()"></a>10.Array.isArray()</h3><ul><li>判断一个对象是不是数组，返回的是布尔值</li></ul><h3 id="11-Array-concat"><a href="#11-Array-concat" class="headerlink" title="11. Array.concat()"></a>11. Array.concat()</h3><ul><li>用于连接两个或多个数组</li><li>参数:参数可以是具体的值,也可以是数组对象.可以是任意多个</li><li>返回值:返回连接后的数组</li><li>是否改变原数组:不改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [1, 2, 3]</span><br><span class="line">      arr2 = [4, 5]</span><br><span class="line">  let arr = arr1.concat(arr2)</span><br><span class="line">  console.log(arr)//[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-Array-toString"><a href="#12-Array-toString" class="headerlink" title="12.Array.toString()"></a>12.Array.toString()</h3><ul><li>此方法将数组转化成字符串,并返回结果,默认用逗号分隔<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5];</span><br><span class="line">   let str = arr.toString()</span><br><span class="line">   console.log(str)// 1,2,3,4,5</span><br></pre></td></tr></table></figure></li></ul><h3 id="13-Array-join"><a href="#13-Array-join" class="headerlink" title="13.Array.join()"></a>13.Array.join()</h3><ul><li>用指定的分隔符将数组每一项拼接成字符串</li><li>参数:指定的分隔符,如果省略该参数,则使用逗号作为分隔符</li><li>返回值:拼接好的字符串</li><li><p>是否改变原始数组:不改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.join(&apos;-&apos;);</span><br><span class="line">console.log(ary);  // [1, 2, 3, 4, 5]</span><br><span class="line">console.log(res);  // 1-2-3-4-5</span><br></pre></td></tr></table></figure></li><li><p>通过上面这个列子可以看出和tostring的区别,join可以设置元素之间的间隔</p></li></ul><h3 id="14-Array-splice"><a href="#14-Array-splice" class="headerlink" title="14.Array.splice()"></a>14.Array.splice()</h3><ul><li>作用:万能方法可以实现增删改,</li><li>返回值:被删除的项目</li><li>是否改变原始数组:该方法会改变原始数组</li><li>语法:Array.splice(index,howmany,item1….,itemn)</li><li><p>index表示添加/删除项目的位置,howmany要删除项目的数量,item1…要新增的项目</p><p> <strong>1.增加功能</strong></p></li><li><code>ary.splice(n,0,x，......,y);</code></li><li><p>从数组的索引n开始，删除0项,在索引n的前边增加新的项，第三个参数开始都是用来填补删除的项目位置的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.splice(1,0,6,7);</span><br><span class="line">console.log(ary);  // [1, 6, 7, 2, 3, 4, 5]</span><br><span class="line">console.log(res);  // [] 删除0项，返回一个空数组</span><br></pre></td></tr></table></figure><p> <strong>2.删除的功能</strong></p></li><li><code>ary.splice(n,m);</code></li><li><p>从数组的索引n开始,删除m项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.splice(1,2);</span><br><span class="line">console.log(ary);  // [1，4，5]</span><br><span class="line">console.log(res);  // [2，3]</span><br></pre></td></tr></table></figure><p> <strong>3.修改的功能</strong></p></li><li><code>ary.splice(n,m,x);</code></li><li><p>从数组的索引n开始，删除m项，把x添加到索引n前边</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.splice(1,2,6,7);</span><br><span class="line">console.log(ary);  // [1, 6, 7, 4, 5]</span><br><span class="line">console.log(res);  // [2，3]</span><br></pre></td></tr></table></figure></li><li><p>模拟push(尾部添加) 与push二者返回值不同,push返回数组的长度,splice返回被删除的项</p></li><li><code>arr.splice(arr.length,0,新的项)</code>  因为splice是在索引前添加,所以是arr.length</li><li>模拟pop(尾部删除)</li><li><code>arr.splice(arr.length-1,1)</code></li><li>模拟shift(首项删除)</li><li><code>arr.splice(0,1)</code></li><li>模拟unshift(首项添加)和unshift二者返回值不同</li><li><p>arr.splice(0,0,新的项)</p></li><li><p>此外</p></li><li>arr.splice(n) 表示从索引n开始删除和末尾</li><li>arr.splice(0) 表示删除整个数组 有克隆数组的效果,利用返回值</li></ul><h3 id="15-slice"><a href="#15-slice" class="headerlink" title="15.slice"></a>15.slice</h3><ul><li>作用:截取数组(复制数组)</li><li>参数:`array.slice(start,end) 删除的时候不包括end这一项</li><li>返回值:返回一个新数组</li><li><p>是否改变原数组:不改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.slice(1,3);</span><br><span class="line">var res2 = ary.slice(-3,-1)</span><br><span class="line">console.log(ary);  // [1,2,3,4,5]</span><br><span class="line">console.log(res);  // [2,3]</span><br><span class="line">console.log(res2)  //[3,4] slice支持负参数，从最后一项开始算起，-1为最后一项，-2为倒数第二项</span><br></pre></td></tr></table></figure></li><li><p>注意与splice区别,slice不改变原数组,返回值为一个新数组,splice返回值为被删除的项,返回值一个新数组</p></li></ul><h3 id="16-sort"><a href="#16-sort" class="headerlink" title="16.sort"></a>16.sort</h3><ul><li>作用:对数组元素进行排序</li><li>参数:可选(函数)规定排序规则,默认排序顺序默认为字母升序</li><li>返回值:排好序的原数组</li><li>是否改变原数组:改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,5,7,9,12,24,56,87,92];</span><br><span class="line">var ary2 = [1,5,7,9,12,24,56,87,92];</span><br><span class="line">var ary3 = [1,5,7,9,12,24,56,87,92];</span><br><span class="line">var res = ary.sort();</span><br><span class="line">var res2 = ary2.sort(function(a,b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;)</span><br><span class="line">var res3 = ary3.sort(function(a,b)&#123;</span><br><span class="line">    return b-a;</span><br><span class="line">&#125;)</span><br><span class="line">// sort的参数函数总的形参a,b就是数组排序时候的相邻比较的两项</span><br><span class="line">console.log(res);  // [1, 12, 24, 5, 56, 7, 87, 9, 92]</span><br><span class="line">console.log(res2); // [1, 5, 7, 9, 12, 24, 56, 87, 92]</span><br><span class="line">console.log(res3); // [92, 87, 56, 24, 12, 9, 7, 5, 1]</span><br></pre></td></tr></table></figure></li></ul><h3 id="17-reverse"><a href="#17-reverse" class="headerlink" title="17.reverse"></a>17.reverse</h3><ul><li>作用:倒序数组</li><li>参数:无</li><li>返回值:倒序后的原数组</li><li>是否改变原数组:改变</li><li>注意: 返回值与原数组的值相同<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.reverse();</span><br><span class="line">console.log(ary);  // [5, 4, 3, 2, 1]</span><br><span class="line">console.log(res);  // [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure></li></ul><h3 id="18-indexOf"><a href="#18-indexOf" class="headerlink" title="18.indexOf"></a>18.indexOf</h3><ul><li>作用:查找指定元素的位置</li><li>参数:array.indexOf(item,start) item:查找元素 start:字符串中开始检索的位置</li><li>返回值:返回第一次查到的索引,为找到返回-1,</li><li>是否改变原数组:不改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5]</span><br><span class="line">var res = ary.indexOf(3);</span><br><span class="line">console.log(ary);  // [1,2,3,4,5]</span><br><span class="line">console.log(res);  // 2</span><br><span class="line">var ary = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;c&apos;];</span><br><span class="line">var res = ary.indexOf(&apos;c&apos;,3);</span><br><span class="line">console.log(res) // 4</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;js中常用的数组方法的总结&quot;&gt;&lt;a href=&quot;#js中常用的数组方法的总结&quot; class=&quot;headerlink&quot; title=&quot;js中常用的数组方法的总结&quot;&gt;&lt;/a&gt;js中常用的数组方法的总结&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla
      
    
    </summary>
    
      <category term="数组" scheme="http://yoursite.com/categories/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="javascript基础" scheme="http://yoursite.com/tags/javascript%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题总结之HTML， HTTP，web综合问题</title>
    <link href="http://yoursite.com/2019/04/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/13/前端面试题总结/</id>
    <published>2019-04-13T12:33:00.000Z</published>
    <updated>2019-04-21T05:58:34.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML，-HTTP，web综合问题"><a href="#HTML，-HTTP，web综合问题" class="headerlink" title="HTML， HTTP，web综合问题"></a>HTML， HTTP，web综合问题</h2><h3 id="1-什么是CSS预处理"><a href="#1-什么是CSS预处理" class="headerlink" title="1.什么是CSS预处理"></a>1.什么是CSS预处理</h3><ul><li>css预处理定义:<ul><li>定义了一种新的语言,其基本思想是同一种专门变成语言,为CSS增加了一些编程特性,将css作为目标生成文件,然后开发者就只要使用这种语言进行编码工作</li></ul></li><li>几种预处理语言<ul><li>sass</li><li>less</li><li>stylus</li><li>burbine</li><li>switch css</li><li>dt css</li><li>css cacheer</li></ul></li></ul><h3 id="2-Javascript中的定时器有哪些？他们的区别及用法是什么？"><a href="#2-Javascript中的定时器有哪些？他们的区别及用法是什么？" class="headerlink" title="2.Javascript中的定时器有哪些？他们的区别及用法是什么？"></a>2.Javascript中的定时器有哪些？他们的区别及用法是什么？</h3><ul><li>setTimeOut 只会执行一次</li><li>setInterval 会一直重复执行</li></ul><h3 id="3-请描述一下cookies-sessionStorage与loaclStorage区别"><a href="#3-请描述一下cookies-sessionStorage与loaclStorage区别" class="headerlink" title="3.请描述一下cookies sessionStorage与loaclStorage区别"></a>3.请描述一下cookies sessionStorage与loaclStorage区别</h3><ul><li>cookie是网站为了标示用户身份而存储在用户本地终端（Client Side)上的数据(通常是经过加密的)</li><li>相同点:都存储在客户端</li><li>不同点:</li></ul><ol><li>存储大小<ul><li>cookies数据大小不能超过4k</li><li>sessionStorage和localStorage虽然也有大小的限制,但是比cookie大的多,可以达到5M或更大</li></ul></li><li>有效时间<ul><li>loaclStorage存储持久数据,在浏览器关闭后数据不会丢失,除非主动删除</li><li>sessionStorage数据在浏览器关闭后数据自动删除</li><li>cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li><li>数据与服务器之间的交互方式<ul><li>cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</li></ul></li></ol><h3 id="4-编写一个方法去掉数组里面-重复的内容-var-arr-1-2-3-4-5-1-2-3"><a href="#4-编写一个方法去掉数组里面-重复的内容-var-arr-1-2-3-4-5-1-2-3" class="headerlink" title="4.编写一个方法去掉数组里面 重复的内容  var arr=[1,2,3,4,5,1,2,3]"></a>4.编写一个方法去掉数组里面 重复的内容  var arr=[1,2,3,4,5,1,2,3]</h3><p><strong>一个数组去重的实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;abc&apos;,&apos;abcd&apos;,&apos;sss&apos;,&apos;2&apos;,&apos;d&apos;,&apos;t&apos;,&apos;2&apos;,&apos;ss&apos;,&apos;f&apos;,&apos;22&apos;,&apos;d&apos;];</span><br><span class="line">//定义一个新的数组</span><br><span class="line">var s = [];</span><br><span class="line">//遍历数组</span><br><span class="line">for(var i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(s.indexOf(arr[i]) == -1)&#123;  //判断在s数组中是否存在，不存在则push到s数组中</span><br><span class="line">        s.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(s);</span><br><span class="line">//输出结果：[&quot;abc&quot;, &quot;abcd&quot;, &quot;sss&quot;, &quot;2&quot;, &quot;d&quot;, &quot;t&quot;, &quot;ss&quot;, &quot;f&quot;, &quot;22&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="5-计算一个数组arr所有元素的和"><a href="#5-计算一个数组arr所有元素的和" class="headerlink" title="5.计算一个数组arr所有元素的和"></a>5.计算一个数组arr所有元素的和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3,4,5,6,7,8,9];</span><br><span class="line">var sum1=0;</span><br><span class="line">for (var i=0;i&lt;=arr1.length;i++) &#123;</span><br><span class="line">if (typeof arr1[i]==&quot;number&quot;) &#123;</span><br><span class="line">sum1+=arr1[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">document.write(sum1);</span><br></pre></td></tr></table></figure><h3 id="6-ajax的步骤"><a href="#6-ajax的步骤" class="headerlink" title="6.ajax的步骤"></a>6.ajax的步骤</h3><blockquote><p></p><p style="color:red;font-weight:bold">什么是ajax</p> <p></p><ul><li>ajax(异步javascript xml)能够刷新局部网页数据,而不是重新加载整个网页</li><li>如何使用ajax<ol><li>第一步,创建xmlhttpquest对象,var xmlhttp = new XMLhttpRequest();XMLHttpRequest对象用来和服务器交换数据</li><li>第二步,使用xmlhttpquest对象的open()和send()方法发送资源请求给服务器</li><li>第三部,使用xmlhttpquest对象的responseText和responseXML属性获取服务器的响应</li><li>第四步,onreadystatechange函数,当发送请求到服务器,我们想要服务器响应执行一些功能,就需要使用onreadystatechange函数,每次xmlhttpquest对象的readystate发生改变都会触发onreadystatechange函数</li></ol></li></ul></blockquote><h3 id="7-XML和json的区别"><a href="#7-XML和json的区别" class="headerlink" title="7.XML和json的区别"></a>7.XML和json的区别</h3><ul><li>json相对XML来讲,数据的体积更小,传递的速度更快</li><li>JSON与javaScript交互更加方便,更容易解析处理,更好的进行数据交互</li><li>XML对数据的描述比json好</li><li>JSON的速度要远远快于XML</li></ul><h3 id="8-清除浮动的方法"><a href="#8-清除浮动的方法" class="headerlink" title="8.清除浮动的方法"></a>8.清除浮动的方法</h3><ol><li>父div定义height</li></ol><ul><li>原理:父级div手动定义height,就解决了父级div无法自动获取高度的问题</li><li>缺点:只适合高度固定的布局,要给出精确的高度,如果高度和父级div不一样,会产生问题</li></ul><ol start="2"><li>结尾处加上空div标签:clear:both</li></ol><ul><li>原理: 添加一个空的div,利用css提高的clear:both清除浮动,让父级div自动就能获取到高度</li></ul><ol start="3"><li>父级div定义 伪类:after 和 zoom</li></ol><ul><li>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 </li></ul><ol start="4"><li>父级div定义 overflow:hidden</li></ol><ul><li>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度</li><li>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 </li></ul><h3 id="9-box-sizing常用的属性有哪些？分别有什么作用？"><a href="#9-box-sizing常用的属性有哪些？分别有什么作用？" class="headerlink" title="9.box-sizing常用的属性有哪些？分别有什么作用？"></a>9.box-sizing常用的属性有哪些？分别有什么作用？</h3><ul><li>属性值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box-sizing：content-box</span><br><span class="line">box-sizing：border-box</span><br><span class="line">box-sizing：inherit</span><br></pre></td></tr></table></figure></li></ul><p><strong>content-box</strong></p><pre><code>- 这是box-sizing的默认属性值- 在CSS中定义的宽度和高度对应元素的内容框- 在CSS中定义的宽度和高度之外绘制元素的内外边距和边框 </code></pre><p><strong>border-box</strong></p><pre><code>- 在CSS中微元素设定的宽度和高度就决定了元素的边框的盒- 即为元素的内边框和边框是在已经定义好的宽度和高度之间之内绘制的- CSS中的设定的高度和宽度减去边框的内外边距,才能得到元素内容所占的实际宽度和高度</code></pre><ul><li>即centent-box是在定义的宽度的高度之外绘制元素的内边距和边框(元素的默认效果)</li><li>border-box:元素指定的任何内边框和边框都将在定义的高度和宽度之间的进行绘制,通过已设定的高度和宽度减去内边距和边框的和得到的才是内容的宽度和高度</li></ul><h3 id="10-CSS选择器有哪些-选择器的权重的优先级"><a href="#10-CSS选择器有哪些-选择器的权重的优先级" class="headerlink" title="10.CSS选择器有哪些?选择器的权重的优先级"></a>10.CSS选择器有哪些?选择器的权重的优先级</h3><p><strong>选择器类型:</strong></p><ol><li>id选择器 #id</li><li>class选择器 .calss</li><li>标签选择器 p</li><li>通用 *</li><li>属性选择器 [type=”text”]</li><li>伪类选择器 :hover</li><li>伪元素选择器 ::first-line</li><li>子选择器,相邻选择器</li></ol><p><strong>权重:</strong></p><ol><li>第一等:表示内联样式,如style=””,权值1000</li><li>第二等:id选择器 权值为100</li><li>第三等:class选择器 权值为10</li><li>第四等:代表类型选择器和伪元素选择器,如div p 权值为1</li><li>通配符,子选择器,相邻选择器等的.如.&gt;.+权值为0</li><li>继承样式没有权值</li></ol><h3 id="11-js有几种数据类型-其中基本数据类型有哪些"><a href="#11-js有几种数据类型-其中基本数据类型有哪些" class="headerlink" title="11.js有几种数据类型,其中基本数据类型有哪些?"></a>11.js有几种数据类型,其中基本数据类型有哪些?</h3><ul><li>五种基本数据类型:undefined,Null,Bollean,Number和String</li><li>一种复杂数据类型-Object,Object本质上是由一组无序的名值对组成</li><li>Object,Array,Function则属于引用数据类型</li></ul><h3 id="12-undefined和null的区别"><a href="#12-undefined和null的区别" class="headerlink" title="12.undefined和null的区别"></a>12.undefined和null的区别</h3><ul><li>null:Null类型,代表是空值,代表一个空对象的指针,使用typeof运算得到一个object,所以你可以认为它是一个特殊的对象值</li><li>undefined:Undefined类型,当一个声明了的变量没有初始化,得到的值就是undefined</li><li>null是javascript关键字,可以认为是对象类型,它是一个空对象指针,和其他语言一样都代表是”空值”</li><li>javaScript权威指南:null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。</li></ul><h3 id="13-http和https有何区别-如何灵活使用"><a href="#13-http和https有何区别-如何灵活使用" class="headerlink" title="13.http和https有何区别?如何灵活使用"></a>13.http和https有何区别?如何灵活使用</h3><ul><li>http是HTTP协议运行在TCP之上.所有传输的内容都是明文,客户端和服务器端都无法验证对方的身份</li><li>htpps是HTTP运行SSL/TLS之上,SSL/TLS运行在TCP之上.所有传输都经过加密,加密采用对称加密.</li></ul><h3 id="14-原型链的解释"><a href="#14-原型链的解释" class="headerlink" title="14.原型链的解释"></a>14.原型链的解释</h3><ul><li>由于<em>proto</em>是任何对象都有的属性,而js里万物都有对象,所以会形成一条由<em>proto</em>连起来的链条,递归访问_proto必须最终到头,并且值是null</li></ul><blockquote><p><strong>属性的设置</strong></p><ul><li>读取对象属性时,会自动在原型链的中查找</li><li>设置对象属性时,不会查找原型链,如果是当时中没有的属性,直接添加属性并设置此值</li><li>方法一般定义在原型中.属性一般通过构造函数定义在函数本身.</li></ul></blockquote><ul><li>注意:这里有一个特别的函数Function() 它是new自己创建的.它自己的显式原型与隐式原型属性指向同一个原型对象</li></ul><h3 id="15-对前端路由的理解-前后端路由的区别"><a href="#15-对前端路由的理解-前后端路由的区别" class="headerlink" title="15.对前端路由的理解?前后端路由的区别?"></a>15.对前端路由的理解?前后端路由的区别?</h3><ul><li>前端路由和后端路由在实现原理上不一样,但是原理都是一样的.在HTML的history API出现之前,前端的路由都是通过hash来实现的,hash能兼容低版本的浏览器哦</li></ul><p><strong>服务器路由</strong>:每次跳转到不同URL,都是重新访问服务端,然后服务端返回页面,页面也可以是服务端获取数据，然后和模板组合，返回HTML，也可以是直接返回模板HTML，然后由前端JS再去请求数据，使用前端模板和数据进行组合，生成想要的HTML。</p><p><strong>前端路由</strong>:每次跳转到不同URL都是使用前端的锚点路由.实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合，当然模板有可能是请求服务端返回的，这就是 SPA 单页程序。</p><h3 id="16-解释一下call函数和apply函数的作用-及其用法"><a href="#16-解释一下call函数和apply函数的作用-及其用法" class="headerlink" title="16.解释一下call函数和apply函数的作用,及其用法"></a>16.解释一下call函数和apply函数的作用,及其用法</h3><blockquote><p><strong>改变对象的内部指针,即改变对象的this指向问题</strong></p><ol><li>call()</li></ol><ul><li>语法:<code>obj1.call(obj2[,param1,param2,...])</code> 定义:用obj2对象代替obj1,并且调用obj1的方法.即将obj1应用到obj2上;</li><li>说明: call方法可以用来代替另一个对象调用一个方法,call方法可将一个函数的对象上下文从初始的上下文改变为由obj2指定的新对象,扩充对象的能力</li></ul><ol start="2"><li>apply()</li></ol><ul><li>语法: <code>obj1.call(obj2[,arrArg])</code>,定义：用obj2对象来代替obj1，调用obj1的方法，即将obj1应用到obj2上，说明：call ()和apply()作用一样，但是call()可以接收任何类型的参数，而apply()只能接收数组参数。</li></ul></blockquote><h3 id="17-作用域与执行上下文的区别"><a href="#17-作用域与执行上下文的区别" class="headerlink" title="17.作用域与执行上下文的区别"></a>17.作用域与执行上下文的区别</h3><ol><li>对应的创建和产生的时间:作用域是函数被定义的时候产生的,执行上下文是函数被调用,代码执行之前</li><li>活动状态:作用域是静态的,定义好了就一直存在,且不会发生变化,上下文环境是动态的,函数调用的时候创建,函数调用结束时,被释放.</li><li>从属关系:执行上下文环境,从属于所在的作用域</li></ol><h4 id="18-为什么会存在函数名-变量名提升"><a href="#18-为什么会存在函数名-变量名提升" class="headerlink" title="18.为什么会存在函数名,变量名提升?"></a>18.为什么会存在函数名,变量名提升?</h4><ul><li>就是在执行上下文的预处理,在执行全局数据或者局部数据之前,对全集数据进行预处理,比如var定义的全局变量==&gt;undefined,添加为window的属性</li></ul><h3 id="19-执行下上文"><a href="#19-执行下上文" class="headerlink" title="19.执行下上文"></a>19.执行下上文</h3><ul><li>代码分类(位置)<ul><li>全局代码</li><li>函数(局部)代码</li></ul></li><li>执行全局上下文<ul><li>在执行全局代码前,将window确定全局执行上下文对象</li></ul></li><li>对全局数据进行预处理,<ul><li>var定义的全局变量==&gt;undefined,添加为window的属性</li><li>function声明的全局函数,==&gt;赋值(fun),添加为window的方法</li><li>this==&gt;赋值(window)</li></ul></li><li><p>开始执行全局代码</p></li><li><p>函数执行上下文</p><ul><li>在调用函数,准备执行函数体之前,创建对应的函数执行上下文对象.(存在于栈中,虚拟的).</li><li>对局部数据进行预处理<ul><li>形参变量赋值为实参, ==&gt;添加为执行上下文的属性.</li><li>arguments==&gt;赋值(实参列表)==&gt;添加为执行上下文的属性.</li><li>var定义的局部变量==&gt;undefined,==&gt;添加为执行上下文的属性.</li><li>function声明的函数==&gt;赋值(fun)==&gt;添加为执行上下文的方法.</li><li>this==&gt;(赋值)调用函数的对象.</li></ul></li><li>调用函数(次数),window.导致产生执行上下文栈 (后进先出).数据进行预处理</li></ul></li><li><p>在js代码执行前,js引擎就会创建一个栈来管理所有的执行上下文对象(虚拟的)</p></li><li>在全局执行上下文(window)创建后,将其添加上到栈中</li><li>在当函数执行完后,将栈顶的对象移出(出栈)</li><li>当所有代码执行完毕后,栈中只剩下window</li></ul><h3 id="20-实例与对象的区别"><a href="#20-实例与对象的区别" class="headerlink" title="20.实例与对象的区别"></a>20.实例与对象的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">var person = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>通过new object创建的对象,可以称之为object的实例</li><li>第二个采用对象字面量的形式生成的person也是如此.</li><li>但是他没有调用new object(),而是通过JSON()初始化的方式</li><li>将现有的引用指向person</li><li>对象与实例的区别<ul><li>实例是对象的具象化产品</li><li>而对象是一个具有多种属性的内容结构.</li><li>实例都是对象,但是对象不全部是实例</li></ul></li><li>实例与对象的区别总结: </li></ul><ol><li>实例是对象的具体化产品,而对象是一个具有多种属性的内容结构.</li><li>实例一定是对象,但是对象不全都是实例.</li></ol><h3 id="21-继承问题"><a href="#21-继承问题" class="headerlink" title="21.继承问题"></a>21.继承问题</h3><blockquote><p><strong>object</strong>构造函数模式</p><ul><li>套路:先创建一个空的object对象,再动态的添加属性/方法</li><li>使用场景:起始不太确定对象内部数据</li><li>语句太多</li></ul></blockquote><blockquote><p><strong>对象字面量模式</strong></p><ul><li>套路:使用{}创建对象,同时指定属性/方法</li><li>使用场景:起始时,对象内部数据是确定的,适用于创建单个对象</li><li>问题:如果创建多个对象,有重复代码,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">name: &apos;张三&apos;,</span><br><span class="line">age: 30,</span><br><span class="line">say:function () &#123;</span><br><span class="line">alert(&apos;hello,world!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>工厂创建模式</strong></p><ul><li>套路:通过工厂函数动态创建对象并返回</li><li>使用场景:需要创建多个对象</li><li>问题:对象没有一个具体的类型.都是Object类型 (区分不开类型)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age, job)&#123;</span><br><span class="line">var o = new Object();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.job = job;</span><br><span class="line">o.sayName = function()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>自定义构造函数模式</strong></p><ul><li>套路:自定义构造函数,通过new创建对象</li><li>使用场景:需要创建多个类型创建的对象</li><li>问题:每个对象都要相同的数据,浪费内存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.job = job;</span><br><span class="line">// this在此时无法知道指向谁,必须等到调用的时候才确定</span><br><span class="line">this.sayName = function()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 如果使用关键词new,那么this指向 创建出来的实例对象本身</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><strong>组合使用构造函数模式和原型模式</strong></p><ul><li>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式</li><li><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.job = job;</span><br><span class="line">this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">constructor : Person,</span><br><span class="line">sayName : function()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends); //&quot;Shelby,Count,Van&quot;</span><br><span class="line">alert(person2.friends); //&quot;Shelby,Count&quot;</span><br></pre></td></tr></table></figure></li><li><p>好处:每个实例都有自己的一份实例属性的副本,但是同时又共享着对方法的引用,最大限度地节省了内存.这种混成模式还支持向构造函数传递参数,可谓是集两种模式之长</p></li></ul><p><strong>区别:</strong></p><ul><li>没有显示的创建对象</li><li>没有直接将属性和方法赋值给this对象</li><li>没有return语句</li><li><p>创建自定义构造函数意味着将来可以将它的实例标识为一种特定的类型,而这正是构造函数模式胜过工厂模式的地方</p></li><li><p>要创建Person的新实例,必须使用new操作符.以这种方式调用构造函数会经历以下四个步骤</p></li></ul><ol><li>创建一个新对象</li><li>将构造函数作用域赋值给新对象(因此this就指向了这个对象)</li><li>执行构造函数中的代码(为这个新对象添加属性)</li><li>返回新对象</li></ol><h3 id="22-检测数据类型的方法"><a href="#22-检测数据类型的方法" class="headerlink" title="22.检测数据类型的方法"></a>22.检测数据类型的方法</h3><ul><li>typeof 只能检测基本数据类型,对于复杂数据类型,都是object</li><li>insaneof 用来检测对象的类型,返回值为布尔值</li></ul><h3 id="23-TCP-IP-HTTP的区别"><a href="#23-TCP-IP-HTTP的区别" class="headerlink" title="23.TCP/IP HTTP的区别"></a>23.TCP/IP HTTP的区别</h3><ul><li>TPC/IP协议是传输层协议,主要解决数据如何在网络中传输.而HTTP是应用层协议，主要解决如何包装数据。</li><li>可以这样理解,我们在传输数据时,可以只使用(传输层)TCP/IP协议,但是那样的话,如果没有应用层协议,便无法识别数据,如果想要使传输的数据有意义，则必须使用到应用层协议，WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上.</li><li>术语TCP/IP代表传输控制协议/网际协议,把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等.</li><li>TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。</li><li>HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议.客户端使用web浏览器发起HTTP请求给web服务器.Web服务器发送被请求的信息给客户端</li></ul><h3 id="24-前端要注意哪些SEO"><a href="#24-前端要注意哪些SEO" class="headerlink" title="24.前端要注意哪些SEO"></a>24.前端要注意哪些SEO</h3><ul><li>合理的title、description、keyword:搜索对三项的权重逐一减小,title值注意递减,重要关键词不要超过两次,而且靠前,不同页面title要有所不同,description把页面内容高度概括,长度合适,不可过分堆砌关键词,不同页面description有所不同,keywords列举出重要关键词即可</li><li>语义化html代码,符合W3C规范,语义化代码让搜索引擎容易理解网页,</li><li>重要html代码放在最前,搜索引擎抓取html是从上到下的,有的搜索引擎对抓取长度有限制,保证重要内容一定被抓取</li><li>重要内容不要用js输出,爬虫不会执行js获取内容</li><li>少用iframe:搜索引擎不会抓取iframe中的内容</li><li>非装饰性img必须加alt</li><li>提高网站速度:网站速度是搜索引擎排序的一个重要指标</li></ul><h3 id="25-img的title和alt有什么区别"><a href="#25-img的title和alt有什么区别" class="headerlink" title="25.img的title和alt有什么区别"></a>25.img的title和alt有什么区别</h3><ul><li>alt是img特有的标签,是图片内容的等价描述,用于图片无法加载时显示、读屏器阅读图片,提供图片可访问性,搜索引擎会重点分析</li></ul><h3 id="26-从在浏览器地址输入url到页面显示的步骤"><a href="#26-从在浏览器地址输入url到页面显示的步骤" class="headerlink" title="26.从在浏览器地址输入url到页面显示的步骤"></a>26.从在浏览器地址输入url到页面显示的步骤</h3><ol><li>浏览器根据请求的URL交给(域名系统)DNS域名解析,找到真实的IP,向服务器发起请求;</li><li>服务器交给后台处理完成后返回数据,浏览器接收文件(html,js,css,图像等);</li><li>浏览器对加载到的资源(html,css,js等),进行语法解析,建立相应的的内部数据结构(如html的DOM)</li><li>载入解析到的资源文件,渲染页面,完成</li></ol><h3 id="27-如何进行网站的性能优化"><a href="#27-如何进行网站的性能优化" class="headerlink" title="27.如何进行网站的性能优化"></a>27.如何进行网站的性能优化</h3><p><strong>content方法</strong></p><ol><li>减少http请求:合并文件,css精灵图片,inline image</li><li>减少DNS查询:DNS缓存,将资源分布到恰当数量的主机名</li><li>减少DOM元素数量</li></ol><p><strong>service</strong></p><ol><li>使用CDN</li><li>配置ETag</li><li>对组件使用Gzip压缩</li></ol><p><strong>css</strong></p><ol><li>将样式表放到页面顶部</li><li>不使用css表达式</li><li>使用link不适用@import(为什么?)</li></ol><p><strong>javascript</strong></p><ol><li>将脚本放到页面底部</li><li>将javascript和css从外引入</li><li>压缩javascript和css</li><li>删除不需要的脚本</li><li>减少DOM访问</li></ol><p><strong>图片方面</strong></p><ol><li>优化图片,根据实际情况需要选择色深,压缩</li><li>优化css精灵</li><li>不要在html中拉伸图片</li></ol><h3 id="28-HTTP状态码及其含义"><a href="#28-HTTP状态码及其含义" class="headerlink" title="28.HTTP状态码及其含义"></a>28.HTTP状态码及其含义</h3><ul><li><p>1XX:信息状态码</p><ul><li>100 continue继续,一般在post请求时,已发送了http header之后服务端将返回此信息,表示确认,之后发送具体参数信息</li></ul></li><li><p>2XX:成功状态码</p><ul><li>200 ok正常返回信息</li><li>201 created请求成功并且服务器创建了新的资源</li><li>202 Accepted 服务器已接受请求,但是尚未处理</li></ul></li><li><p>3XX:重定向</p><ul><li>301 Moved Permanently 请求的网页已永久移动到新位置。</li><li>302 Found     临时性重定向。</li><li>303 See Other  临时性重定向,且总是使用 GET 请求新的 URI。</li><li>304 Not Modified 自从上次请求后，请求的网页未修改过。</li></ul></li><li>4XX: 客户端错误<ul><li>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li><li>401 Unauthorized 请求未授权。</li><li>403 Forbidden 禁止访问。</li><li>404 Not Found 找不到如何与 URI 相匹配的资源。</li></ul></li><li>5XX: 服务器端错误<ul><li>500 Internal Server Error 最常见的服务器端错误。</li><li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）</li></ul></li></ul><h3 id="29-说说你对语义化的理解"><a href="#29-说说你对语义化的理解" class="headerlink" title="29.说说你对语义化的理解"></a>29.说说你对语义化的理解</h3><ul><li>说通俗一点就是让正确的标签做正确的事</li><li>html的语义化就是让页面内容结构化,便于浏览器和搜索引擎解析</li><li>并且在没有css样式下也是一种文档格式显示,并且是容易阅读的</li><li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重,利于SEO.</li><li>让阅读源代码的人对网站更容易将网站分块,便于阅读维护理解</li></ul><h3 id="30-谈谈你对浏览器内核的理解"><a href="#30-谈谈你对浏览器内核的理解" class="headerlink" title="30.谈谈你对浏览器内核的理解"></a>30.谈谈你对浏览器内核的理解</h3><ul><li>主要分为两个部分: 渲染引擎和js引擎</li><li><strong>渲染引擎</strong>: 负责取得网页的内容(html,xml,图像),整理讯息(例如加入css等),以及计算网页的显示方式,然后输出至显示器或打印器.浏览器的内核的不同对于网页的语法解释也不同,所以渲染出来的效果也不同.所有的网页路浏览器,电子邮件客户端以及它需要编辑,显示网页内容的应用程序都需要内核</li><li><strong>js引擎</strong>: 解析和执行javascript来实现网页的动态效果</li><li>最开始渲染引擎和js引擎并没有区分的很明确.后来js引擎越来越独立,内核就倾向于只渲染引擎</li></ul><h3 id="31-html5有哪写新特性-移除了哪写内容"><a href="#31-html5有哪写新特性-移除了哪写内容" class="headerlink" title="31.html5有哪写新特性,移除了哪写内容?"></a>31.html5有哪写新特性,移除了哪写内容?</h3><ul><li>主要是关于图像,位置,存储,多任何等功能的增加<ul><li>绘画canvas</li><li>用于媒介回放的video和audio元素</li><li>本地离线存储localStorage长期存储数据,浏览器关闭后数据不会丢失</li><li>sessionStorage的数据在浏览器关闭后会自动删除</li><li>语义化更好的内容元素:article,footer,header,nav,section</li><li>表单控件,calendar,date,time,email,url,search</li></ul></li><li><p><strong>移出的元素</strong></p><ul><li>纯表现的元素:basefont,big,center,font,s,strike,</li><li>对可用性产生负面影响的元素:frame,frameset,noframes</li></ul></li><li><p>支持HTML5新标签</p><ul><li>IE8/IE7/IE6支持通过docuemnt.creatElement方法产生的标签</li><li>可以利用这一特性让这些浏览器支持html5新标签</li><li>浏览器支持新标签后,还需要添加标签默认的样式</li></ul></li></ul><h3 id="32-浏览器怎么对HTML5的离线存储资源进行管理和加载的呢"><a href="#32-浏览器怎么对HTML5的离线存储资源进行管理和加载的呢" class="headerlink" title="32.浏览器怎么对HTML5的离线存储资源进行管理和加载的呢?"></a>32.浏览器怎么对HTML5的离线存储资源进行管理和加载的呢?</h3><ul><li><p>在线的情况下,浏览器发现html头部有mainfest属性,它请求mainfest文件,如果是第一次访问app,那么浏览器会根据mainfest文件的内容,下载相应资源并且进行离线存储.如果已经访问过app并且资源已经离线下载存储了,那么浏览器就会使用离线的资源加载页面,然后浏览器会对比新的mainfest文件与旧的mainfest文件,如果文件没有变化,就不做任何操作,如果文件改变了,那么重新下载文件中的资源,并进行离线存储。</p></li><li><p>离线的情况下，浏览器就直接使用离线存储的资源</p></li></ul><h3 id="33-iframe-有些缺点"><a href="#33-iframe-有些缺点" class="headerlink" title="33.iframe 有些缺点?"></a>33.iframe 有些缺点?</h3><ul><li>iframe会阻塞主页面的Onload事件</li><li>索引引擎的检索程序无法解读这种页面,不利用seo</li><li>iframe和主页面共享连接池,而浏览器对相同域的连接有限制,所以会影响页面的并行加载</li><li>使用iframe之前需要考虑这两个缺点,如果要使用iframe,最好是通过javscript动态给iframe添加src属性值,这样可以绕开这两个问题</li></ul><h3 id="34-WEB标准以及W3C标准是什么"><a href="#34-WEB标准以及W3C标准是什么" class="headerlink" title="34.WEB标准以及W3C标准是什么?"></a>34.WEB标准以及W3C标准是什么?</h3><ul><li>标签闭合,标签小写,不乱嵌套,使用外链css和js,结构行为表现分离</li></ul><h3 id="35-XHTML和-HTML有什么区别"><a href="#35-XHTML和-HTML有什么区别" class="headerlink" title="35.XHTML和 HTML有什么区别?"></a>35.XHTML和 HTML有什么区别?</h3><ul><li>一个是功能上的差别<ul><li>主要是XHTML可兼容各大浏览器,手机以及PDA,并且浏览器也能快读解析编译网页</li></ul></li><li>另一个是书写习惯的差别<ul><li>XHTML元素必须被正确的嵌套,闭合,区分大小写,文档必须拥有根元素</li></ul></li></ul><h3 id="36-DocType作用-严格模式与混杂模式如何区分-它们有何意义"><a href="#36-DocType作用-严格模式与混杂模式如何区分-它们有何意义" class="headerlink" title="36.DocType作用?严格模式与混杂模式如何区分?它们有何意义?"></a>36.DocType作用?严格模式与混杂模式如何区分?它们有何意义?</h3><ul><li>页面被加载时,link会同时被加载,而@import页面被加载时,link会同时被加载,而@import引用的css会等到页面被加载完再加载</li><li>@import只要ie5以上才能被识别,而link是XHTML标签,无需考虑兼容问题</li><li>link方式的样式的权重高于@import的权重</li><li>&lt;!doctype&gt;声明位于文档中的最前面,处于<html>标签之前,告知浏览器解析器,用什么文档类型来解析这个文档</html></li><li>严格模式的排版和js运行模式是以该浏览器支持的最高标准运行</li><li>在混杂模式中,页面以宽松的向后兼容的方式显示,模拟老浏览器的行为防止站点无法工作,DocType不存在或格式不正确会导致文档以混杂模式呈现</li></ul><h3 id="37-行内元素有哪些-块状元素有哪些-空-viod-元素有哪些-行内元素和块级元素有什么区别"><a href="#37-行内元素有哪些-块状元素有哪些-空-viod-元素有哪些-行内元素和块级元素有什么区别" class="headerlink" title="37.行内元素有哪些?块状元素有哪些?空(viod)元素有哪些?行内元素和块级元素有什么区别?"></a>37.行内元素有哪些?块状元素有哪些?空(viod)元素有哪些?行内元素和块级元素有什么区别?</h3><ul><li>行内元素有:a b span img  input select</li><li>块状元素: div ul ol li  dl dt dd  h1 h2 h3</li><li>空元素: br hr img  input  link meta</li><li>行内元素对宽高无效,不独占一行</li><li>块状元素可以设置宽高,独占一行</li></ul><h3 id="38-html全局属性-global-attribute-有哪些"><a href="#38-html全局属性-global-attribute-有哪些" class="headerlink" title="38.html全局属性(global attribute)有哪些?"></a>38.html全局属性(global attribute)有哪些?</h3><ul><li>class: 为元素设置标识</li><li>data-*:为元素增加自定义属性</li><li>draggable: 设置元素是否可拖拽</li><li>id:元素id,文档内唯一</li><li>lang:元素内容的语言</li><li>style:行内css样式</li><li>title:元素相关的建议信息</li></ul><h3 id="39-Canvas和SVG有什么区别"><a href="#39-Canvas和SVG有什么区别" class="headerlink" title="39.Canvas和SVG有什么区别"></a>39.Canvas和SVG有什么区别</h3><ul><li>svg绘制出来的每一个图形的元素都是独立的DOM节点,能够方便的绑定事件或用来修改.canvas输出的一整幅画布</li><li>svg输出的图形是矢量图形,后期可以修改参数来自由方法缩小,不会是真和锯齿</li><li>而canvas输出标量画布,就像一张图片一样,放大会失真或者锯齿</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTML，-HTTP，web综合问题&quot;&gt;&lt;a href=&quot;#HTML，-HTTP，web综合问题&quot; class=&quot;headerlink&quot; title=&quot;HTML， HTTP，web综合问题&quot;&gt;&lt;/a&gt;HTML， HTTP，web综合问题&lt;/h2&gt;&lt;h3 id=&quot;1
      
    
    </summary>
    
      <category term="前端面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Sass学习笔记</title>
    <link href="http://yoursite.com/2019/04/13/sass%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/13/sass学习笔记/</id>
    <published>2019-04-13T10:56:39.000Z</published>
    <updated>2019-04-13T12:32:09.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sass学习笔记-sass学习入门"><a href="#Sass学习笔记-sass学习入门" class="headerlink" title="Sass学习笔记,sass学习入门"></a>Sass学习笔记,sass学习入门</h2><h3 id="sass是css预处理器"><a href="#sass是css预处理器" class="headerlink" title="sass是css预处理器"></a>sass是css预处理器</h3><ul><li>sass是基于ruby的,使用sass我们需要安装ruby</li><li>sass和scss其实是同一种东西,我们平时都称之为sass,两者不同之处有以下两点:</li></ul><ol><li>文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名</li><li>语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。<h3 id="为什么要使用Sass"><a href="#为什么要使用Sass" class="headerlink" title="为什么要使用Sass"></a>为什么要使用Sass</h3></li><li>因为css代码重复利用少,管理起来不方便,而用Sass来写代码可以使代码复用.方便快捷修改,比如要修改整站的某种颜色,只需要修改一个变量即可,</li><li>或者对仅使用过一次的属性值,你可以赋予其一个简单易懂的变量名,让人一眼就知道这个属性值的用途.<h3 id="什么是css-reset"><a href="#什么是css-reset" class="headerlink" title="什么是css reset?"></a>什么是css reset?</h3></li></ol><ul><li>HTML标签在浏览器中都有默认的样式,不同浏览器的默认样式之间存在差别.列入ul默认带有缩进的样式,在IE浏览器中,它的缩进是由margin实现的,而在Firefox下却是由padding实现的,开发时的默认样式可能会给我们带来许多浏览器兼容性的问题,影响开发效率.现在很流行的一种方法就是一开始将浏览器的默认样式全部覆盖掉,这就是CSS reset<h3 id="编译Sass"><a href="#编译Sass" class="headerlink" title="编译Sass"></a>编译Sass</h3></li><li>单文件转换命令<br><code>sass input.scss output.css</code></li><li>单文件监听命令<br><code>sass --watch input.scss:output.css</code></li><li>如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录：<br><code>sass --watch app/sass:public/stylesheets</code></li></ul><h2 id="sass语法"><a href="#sass语法" class="headerlink" title="sass语法"></a>sass语法</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul><li>Sass使用$符号来标识变量(老版本使用!符号)比如$<code>sidebar-width</code>;</li><li>为什么选择$符号呢？因为它好认、更具美感，且在CSS中并无他用，不会导致与现存或未来的css语法冲突。<h3 id="css嵌套"><a href="#css嵌套" class="headerlink" title="css嵌套"></a>css嵌套</h3></li><li>父选择器的标识符&amp;<h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3></li><li>导入公共样式</li><li>可以省略.scss后缀<h3 id="原生的css导入"><a href="#原生的css导入" class="headerlink" title="原生的css导入"></a>原生的css导入</h3></li><li>因为sass的语法完全兼容css，所以把原始的css文件改名为.scss后缀，即可直接导入了。</li><li>注意:// 这种注释不会出现在已经生成的css文件中<h3 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h3></li><li>混合器使用@mixin标识符定义.</li><li><p>使用@include引用变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin rounded-corners &#123;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">notice &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">  border: 2px solid #00aa00;</span><br><span class="line">  @include rounded-corners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>通过选择器继承继承样式(@extend)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.error &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意:不要继承后代样式</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Sass学习笔记-sass学习入门&quot;&gt;&lt;a href=&quot;#Sass学习笔记-sass学习入门&quot; class=&quot;headerlink&quot; title=&quot;Sass学习笔记,sass学习入门&quot;&gt;&lt;/a&gt;Sass学习笔记,sass学习入门&lt;/h2&gt;&lt;h3 id=&quot;sass是
      
    
    </summary>
    
      <category term="sass" scheme="http://yoursite.com/categories/sass/"/>
    
    
      <category term="Sass基础语法" scheme="http://yoursite.com/tags/Sass%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue路由基础知识总结</title>
    <link href="http://yoursite.com/2019/04/10/Vue%E8%B7%AF%E7%94%B1/"/>
    <id>http://yoursite.com/2019/04/10/Vue路由/</id>
    <published>2019-04-10T14:16:51.000Z</published>
    <updated>2019-04-15T00:09:50.102Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h2><h3 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h3><ul><li><strong>后端路由</strong>: 对于普通网页来说,所有的超链接都是URL地址,所有URL地址都对应服务器上对应的资源</li><li><strong>前端路由</strong>: 对于单页面用户来说,主要通过URL里面的hash(#号)来实现不同页面之间的切换,同时hash有一个特点:HTTP请求中不会包含相关的内容,所有单页面跳转主要用hash实现.在单页面程序中,这种通过hash来实现切换页面的方式,我们称之为前端路由.(区别于后端路由)</li></ul><h3 id="URL里面的hash有什么特点"><a href="#URL里面的hash有什么特点" class="headerlink" title="URL里面的hash有什么特点?"></a>URL里面的hash有什么特点?</h3><ul><li>思考这个问题…</li></ul><h3 id="router-routes-route之间的区别与联系"><a href="#router-routes-route之间的区别与联系" class="headerlink" title="router,routes,route之间的区别与联系"></a>router,routes,route之间的区别与联系</h3><ol><li>route,它是一条路由,由这个英文单词也可以看出来，它是单数， Home按钮  =&gt; home内容， 这是一条route,  about按钮 =&gt; about 内容， 这是另一条路由。</li><li>routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}]</li><li>router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。</li><li>路由的执行过程:当用户点击router-link标签时,会去寻找它的to属性,它的to属性和js中配置的路径(path:’/home’,component:Home)path一一对应,从而找到了组件,最后把组件渲染到了<code>&lt;router-view&gt;</code>标签所在的地方.所有的这些实现才是基于hash实现的</li></ol><h3 id="使用路由的基本步骤"><a href="#使用路由的基本步骤" class="headerlink" title="使用路由的基本步骤"></a>使用路由的基本步骤</h3><ol><li>安装路由模块,导入后自动拥有hash路由,可以在网站上显示看到#</li><li>创建一个组件模板对象</li><li>创建一个路由实例对象,当导入vue-router包之后,在window全局对象中,就有了一个路由构造器<ul><li>其中在new路由对象的时候,可以为构造函数,传递一个配置对象</li><li>这个配置对象实际就是路由匹配规则的意思</li><li>每个路由规则都是一个对象,这个规则对象中有两个必须的属性</li><li>path表示监听,拦截路由的地址</li><li>component表示,根据path拦截到对应的路由匹配地址,则展示对应当前路由地址的component组件</li><li>注意:component属性值必须是一个组件模板对象,而不能是组件的引入名称</li></ul></li><li>通过router属性,将路由规则对象注册到vm实例上,用来监听URL地址的变化,展示对应的组件.</li><li>组件需要在页面中展示,就需要Vue提供的router-view相当于一个标签属性,我们可以把它当做一个占位符.将来根据路由规则匹配到的组件,就会展示在这个router-view</li><li>router-link 默认渲染a标签 (tag可以改变展示的标签)</li></ol><h3 id="vue使用params-query传参的区别"><a href="#vue使用params-query传参的区别" class="headerlink" title="vue使用params,query传参的区别"></a>vue使用params,query传参的区别</h3><p><strong>params</strong>：/router1/:id ，/router1/123，/router1/789 ,这里的id叫做params</p><p><strong>query</strong>：/router1?id=123 ,/router1?id=456 ,这里的id叫做query。</p><ul><li>区别一: 路由设置这里,<strong>当你使用params方法传参时,要在路由后面加参数名</strong>,并且传参的时候,参数名要跟路由后面的设置的参数名对应,使用query方法，就没有这种限制，直接在跳转里面用就可以.</li><li>注意:如果路由上不写参数,也是可以传过去的,但是不会在URL上显示出你的参数,并且当你跳转到其他页面或者刷新页面的时候参数会丢失.那依赖的这个参数的http请求,或者其他的操作就会失败.</li><li>区别二:<strong>params一旦设置在路由上</strong>,params就是路由的一部分,如果这个路由有params传参,但是在跳转的时候,没有传这个参数,会导致跳转失败或者页面会没有内容.</li></ul><h3 id="push传参的三种方法及与replace的区别"><a href="#push传参的三种方法及与replace的区别" class="headerlink" title="push传参的三种方法及与replace的区别"></a>push传参的三种方法及与replace的区别</h3><ul><li>除了使用除了使用 <router-link> 创建 a 标签来定义导航链接,我们还可以借助 router 的实例方法,通过编写代码来实现. $router.push可以实现路由的跳转,这个方法会向 history 栈添加一个新的记录,所以,当用户点击浏览器后退按钮时,则回到之前的URL.</router-link></li><li>当你点击的时候,这个方法会在内部调用,所以说,点击<code>&lt;router-link :to=&quot;…&quot;&gt;</code> 等同于调用router.push(…).</li></ul><ol><li>第一种形式:字符串<code>this.$router.push(&#39;/about&#39;)</code></li><li>第二种形式:对象<code>this.$router.push({path:&#39;/about&#39;})</code></li><li>第三种形式:命名的路由,也是传入一个对象,如果一个路由有name属性.params跳转到某个详情页<code>this.$router.push({name:&#39;about&#39;})</code>在跳转到某个详情页的时候,还需要给parmas属性传入一个对象,对象里面包含详情页的内容.</li><li>总结: 由于动态路由也是传递params的,所以在this.$router.push()方法中path不能和params一起使用,否则params无效,需要使用name来指定页面,也就是说,除了path我们也可以使用路由的name属性来实现跳转页面</li><li>replace会将之前访问的路由替换成要跳转的路由.但是导航并不会留下history记录,即使点击返回按钮也不会回到页面,加上replace为true后,它不会向history添加新记录,而是跟它的方法名一样—替换掉当前的history记录.</li><li>params中保存的是一个对象类型的数据,里面存有路由路径中参数.</li></ol><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><ul><li><p>我们常常需要把某种匹配模匹配到所有的路由,全部映射到同一个组件中。例如,我们有同一个User组件,对于所有ID各不相同的用户,都要使用这个组件来渲染.那么,我们可以在vue-router的路由路径中使用动态路径参数(dynamic segment)来达到这个效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>/user/foo和/user/bar都将映射到相同的路由</p></li><li>一个路径参数使用:标记,当匹配一个路由时,参数值会被设置到{this.$router.params},可以在每个组件内使用,于是我们可以更新user模板,输出当前用户的ID.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h3><ul><li>注意: 当使用路由参数时,例如从/user/bar导航到/user/foo,<strong>原来的组件将会被复用</strong>,因为两个路由都同时渲染同一个组件.比起销毁再创建,复用则显得效率更高效,不过这也意味着组件的生命周期钩子不会再被调用.复用组件的时候,如果想对路由参数的变化做出响应的话.你可以简单的watch:$route对象</li></ul><h3 id="路由注意事项"><a href="#路由注意事项" class="headerlink" title="路由注意事项"></a>路由注意事项</h3><p><strong>注意:exact-active与active的区别</strong><br>    exact是当前真正匹配的那个路由,active是匹配到exact路由经过的那个路由<br>    比如说 要匹配北京新闻详情里的路由,必须要经过上一个北京路径的这个路由</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Vue路由&quot;&gt;&lt;a href=&quot;#Vue路由&quot; class=&quot;headerlink&quot; title=&quot;Vue路由&quot;&gt;&lt;/a&gt;Vue路由&lt;/h2&gt;&lt;h3 id=&quot;路由的概念&quot;&gt;&lt;a href=&quot;#路由的概念&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Vue路由" scheme="http://yoursite.com/categories/Vue%E8%B7%AF%E7%94%B1/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="路由" scheme="http://yoursite.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础语法一</title>
    <link href="http://yoursite.com/2019/04/10/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%80/"/>
    <id>http://yoursite.com/2019/04/10/Vue基础语法一/</id>
    <published>2019-04-10T14:14:31.000Z</published>
    <updated>2019-04-15T12:17:09.986Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Vue基础之Vue模板语法"><a href="#Vue基础之Vue模板语法" class="headerlink" title="Vue基础之Vue模板语法"></a>Vue基础之Vue模板语法</h2><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ul><li>数据绑定最常见的的形式就是使用Mustache语法(双大括号)的文本插值,双大括号会将数据解析成纯文本<br><code>&lt;span&gt;Message:&lt;/span&gt;</code></li><li>如果Mustache标签将会被替代为对应数据对象上的msg属性的值.无论何时,绑定的数据对象上的msg属性发生了变化,</li><li>插值处的内容都会更新</li></ul><h3 id="纯HTML"><a href="#纯HTML" class="headerlink" title="纯HTML"></a>纯HTML</h3><ul><li>双大括号会将数据解释为纯文本,而非 HTML.为了输出真正的HTML,你需要使用v-html指令<br><code>&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt;</code></li><li>此时被插入的内容都会被当做HTML–数据绑定会被忽略<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3></li><li>Vue允许你自定义过滤器,来实现一些常见的文本格式化功能.过滤器应该被添加上mustache插值尾部,由”管道符”标识起来<br><code></code></li><li>过滤器可以串联</li><li>过滤器是javascript函数,因此可以接受参数<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3></li><li>指令是带有(Directives)是带有v-前缀的特殊属性,指令属性的值预期是单一javascript表达式(除了v-for,之后再讨论).指令的职责就是当其表达式的值时,相应的将某些行为应用到DOM上<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3></li><li>一些指令只能接受一个参数,在指令后以冒号指明,例如v-bind指令被用来更新HTML属性<br><code>&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</code></li><li>在这里href是参数,告知v-bind指令将该元素的href属性与表达式url值绑定<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3></li><li>修饰符(Modifiers)是以半角句号.指明的特殊后缀,用于指出一个指令应该以特殊方法绑定</li></ul><p><strong>事件修饰符</strong></p><ul><li>我们还可以使用事件修饰符(Event Modifer):<ul><li>.stop 阻止冒泡事件</li><li>.prevent 阻止默认事件</li><li>.capture  阻止捕获事件</li><li>.once 执行一次</li></ul></li></ul><h3 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h3><p><strong>1.声明式</strong></p><ul><li>只需要声明在哪里(where)做什么(what),不用关心如何使用(how)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用es6的map方法,关注如何取值</span><br><span class="line">//将原数组（arr）中利用map函数，传入每一项</span><br><span class="line">        var arrNew = arr.map(function (item) &#123;</span><br><span class="line">            return item*2</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>2.命令式</strong></p><ul><li>需要具体代码表达在哪里(where)做什么(what),如何实现(how)</li><li>命令式:使用for循环拿出每一项,然后计算完成后,再放到另一个数中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个新的空数组，然后利用for循环，每一步每一步地放入其中</span><br><span class="line">     var arrNew = [];</span><br><span class="line">       for (var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">           arrNew.push(arr[i]*2);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h3><p><strong>什么是指令</strong></p><ul><li>是一种特殊的自定义行间属性(也就是在html标签内书写),指令的职责就是当其表达式的值发生改变的时候相应的将某些行为应用到DOM上,在Vue中,指令以v开头<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v-bind：动态绑定数据。简写为“:” 。=&gt; 以后的:class=&quot;&#123;red:boolean&#125;&quot;</span><br><span class="line">v-on ：绑定时间监听器。简写为“@”，例：@click=&quot;xxx&quot;；</span><br><span class="line">v-text ：更新数据，会覆盖已有结构。类似&#123;&#123; msg &#125;&#125; ；</span><br><span class="line">v-show ：根据值的真假，切换元素的display属性；</span><br><span class="line">v-if ：根据值的真假，切换元素会被销毁、重建； =&gt; 在dom中已消失</span><br><span class="line">v-else-if ：多条件判断，为真则渲染；</span><br><span class="line">v-else ：条件都不符合时渲染；</span><br><span class="line">v-for ：基于源数据多次渲染元素或模块；</span><br><span class="line">v-model ：在表单控件元素（input等）上创建双向数据绑定（数据源）；</span><br><span class="line">v-pre ：跳过元素和子元素的编译过程；</span><br><span class="line">v-once ：只渲染一次，随后数据更新也不重新渲染；</span><br><span class="line">v-cloak ：隐藏未编译的Mustache语法，在css中设置[v-cloak]&#123;display:none;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Vue模板"><a href="#Vue模板" class="headerlink" title="Vue模板"></a>Vue模板</h2><h3 id="1-html模板"><a href="#1-html模板" class="headerlink" title="1.html模板"></a>1.html模板</h3><ul><li>html模板:基于DOM的模板,模板都是可解析的有效的HTML</li></ul><p><strong>插值</strong></p><ul><li><p><strong>文本</strong>:使用Mustache语法(大括号)作用,替换上实例上的属性值,当值改变时,插值内容就会被自动更新.也可以使用v-text=”value”代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; value &#125;&#125;&lt;p&gt; 等价于 &lt;p v-text=&quot;value&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>原生的html</strong>：双大括号输出的文本，不会解析html标签。也就是说当实例的data为html标签时，不能解析而是直接输出出来。此时如想要解析，可使用v-html=”value”代替.</p></li><li><p><strong>属性</strong>：使用v-bind进行绑定，可以响应变化。<br></p><h2 :class="{red:show}">标题</h2> =&gt; 注意此处的show为data内的一个布尔值数据，若真则添加red的class，若假则移除red的class<p></p></li><li><p><strong>使用javascript表达式</strong>：可以写简单的表达式。（可以简单的三目运算，但是不可以写if语句），以后会有计算属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; 1+2 &#125;</span><br><span class="line">&#123; true? &quot;yes&quot;:&quot;no&quot; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-字符串模板"><a href="#2-字符串模板" class="headerlink" title="2.字符串模板"></a>2.字符串模板</h3><p><strong>template字符串</strong></p><blockquote><p>tempalte =&gt; 选项对象的属性</p><ul><li>模板将会*<em>替换</em>挂载的元素.挂载元素的内容都会被忽略,根节点只有一点,将html结构写在一堆script标签中</li></ul></blockquote><p><strong>数据对象属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class: &#123;&#125;,  =&gt;  绑定class，和v-bind:class一样的API</span><br><span class="line">style: &#123;&#125;,  =&gt;  绑定样式，和v-bind:style一样的API</span><br><span class="line">attrs: &#123;&#125;,  =&gt;  添加行间属性</span><br><span class="line">domProps: &#123;&#125;,  =&gt;   DOM元素属性</span><br><span class="line">on: &#123;&#125;,  =&gt;  绑定事件</span><br><span class="line">nativeOn: &#123;&#125;,  =&gt;  监听原生事件</span><br><span class="line">directives: &#123;&#125;,  =&gt;  自定义指令</span><br><span class="line">scopedSlots: &#123;&#125;,  =&gt;   slot作用域</span><br><span class="line">slot: &#123;&#125;,  =&gt;   定义slot名称  和组件有关系，插曹</span><br><span class="line">key: &quot;key&quot;,  =&gt;   给元素添加唯一标识</span><br><span class="line">ref: &quot;ref&quot;,  =&gt;   引用信息</span><br></pre></td></tr></table></figure></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><strong>1. 注册全局指令-所有人都可以使用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">      &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;div v-color=&quot;colorStatus&quot;&gt;我是一个普通的div元素&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./node_modules/vue/dist/vue.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      document.addEventListener(&apos;DOMContentLoaded&apos;,function () &#123;</span><br><span class="line">          Vue.directive(&apos;color&apos;,function (el,binding) &#123;//指令名称注意不要加**v-**</span><br><span class="line">              console.log(el);//当前绑定自定义指令的元素，可以用来直接操作DOM</span><br><span class="line">              console.log(binding);//一些参数，常用的  =&gt; binding.value（指令的值） </span><br><span class="line">              el.style.backgroundColor = &apos;lawngreen&apos;;</span><br><span class="line">          &#125;)</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &apos;.app&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                colorStatus: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,false);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>2.注册局部指令—当前组件下可用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">      &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;div v-color=&quot;colorStatus&quot;&gt;我是一个普通的div元素&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./node_modules/vue/dist/vue.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      document.addEventListener(&apos;DOMContentLoaded&apos;,function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &apos;.app&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                colorStatus: true</span><br><span class="line">            &#125;,</span><br><span class="line">            directives:&#123; </span><br><span class="line">                &apos;color&apos;:function (el,binding) &#123;</span><br><span class="line">                    el.style.backgroundColor = &apos;lawngreen&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,false);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure></p><ul><li><strong>注意</strong>: 选项对象的directives属性注意此处有个s</li></ul><h3 id="计算数据-计算属性"><a href="#计算数据-计算属性" class="headerlink" title="计算数据(计算属性)"></a>计算数据(计算属性)</h3><p><strong>为什么要使用计算属性</strong></p><ul><li>模板是未来描述视图的结构,在模板中放入太多的逻辑,会导致模板过重难以维护</li><li>在计算一个计算属性时,Vue.js更新它的依赖列表并缓存结果,只有当其中一个发生了变化,缓存的结果才无效</li></ul><h3 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h3><p><strong>1.什么是组件</strong></p><ul><li>WEB中的组件其实就是在页面组成的一部分,好比是电脑中的每一个原件(如硬盘,键盘.鼠标)它是一个具有独立逻辑的功能或页面,同时又能根据规定的接口规则进行相互融合,变成一个完整的应用</li></ul><p><strong>2.使用组件的好处</strong></p><ol><li>提供效率</li><li>方便重复使用</li><li>简化调试步骤</li><li>提升整个项目的可维护性</li><li>便于协同开发</li></ol><p><strong>3.组件的特性</strong></p><ol><li>高内聚性,组价功能必须是完整的,如我要实现下拉菜单的功能,那在下拉菜单这个组件中,就把下拉菜单的所有功能全部实现</li><li>低耦合性,通俗点说,代码独立不会和项目中的代码发生冲突!在实际工程,我们经常会涉及到团队协作,传统按业务线去编写代码的方式,就很容易相互发生冲突,运用组件化可以大大减低避免这种冲突的存在</li><li>每个组件都有自己清晰的职责,完整的功能,较低的耦合便于单元测试和重复利用</li></ol><p><strong>4.Vue的组件</strong></p><ul><li>vue的组件是一定自定义标签(元素),Vue.js的编译器为它添加特殊功能,vue也可以拓展原生的html元素,封装可重用的代码</li><li>样式结构,行为逻辑,数据三大组成元素</li></ul><h3 id="SASS函数功能实现PX转REM"><a href="#SASS函数功能实现PX转REM" class="headerlink" title="SASS函数功能实现PX转REM"></a>SASS函数功能实现PX转REM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$baseFontSize:100 //函数</span><br><span class="line">@function px2rem($px)&#123;</span><br><span class="line">    @return $px/baseFontsize*rem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Vue基础之Vue模板语法&quot;&gt;&lt;a href=&quot;#Vue基础之Vue模板语法&quot; class=&quot;headerlink&quot; title=&quot;Vue基础之Vue模板语法&quot;&gt;&lt;/a&gt;Vue基础之Vue模板语法&lt;/h2&gt;&lt;h3 id=&quot;插值&quot;
      
    
    </summary>
    
      <category term="Vue基础语法" scheme="http://yoursite.com/categories/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue计算属性</title>
    <link href="http://yoursite.com/2019/04/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/10/Vue计算属性/</id>
    <published>2019-04-10T03:47:37.000Z</published>
    <updated>2019-04-11T00:01:58.626Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p> <strong>1.计算属性的特点</strong></p><ul><li>1.可以对属性数据进行逻辑操作</li><li>2.对计算属性中的数据进行监视,也就是被计算的属性如果被修改,那计算属性后的结果就是被修改后再计算的结果.</li><li>3.计算属性依赖于响应式中的数据,可以当做作为data数据中的修饰符,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:&quot;hello vue!&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        msgReverse:function()&#123;</span><br><span class="line">            return this.msg.split(&quot; &quot;).reverse().join(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">调用方法：&#123;&#123;msgReverse&#125;&#125;  //vue hello</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-computed计算属性VSmethods内的方法"><a href="#2-computed计算属性VSmethods内的方法" class="headerlink" title="2.computed计算属性VSmethods内的方法"></a>2.computed计算属性VSmethods内的方法</h3><ul><li>计算属性的get函数，如果使用methods内的方法，也可以达到同样的效果，那我们为何要使用计算属性呢？</li><li>他们之间的的区别<ol><li>计算属性是依赖于被计算的数据,只有当这个数据改变的时候,计算属性才会改变</li><li>计算属性是有缓存的,如果计算的那个数据没有发生改变,无论你访问多少次,计算属性返回的值依旧是之前计算的值</li></ol></li></ul><pre><code>var vm = new Vue({    el: &quot;#app&quot;,    data:{        num:8    },    computed:{        getNum:function(){            console.log(new Date());    // Wed Feb 27 2019 13:00:42 GMT+0800 (中国标准时间)            return this.num+1;         // 9        }    },    methods:{        getNum2:function(){            console.log(new Date());    // Wed Feb 27 2019 13:00:42 GMT+0800 (中国标准时间)            return this.num+1;         // 9        }    }})// 模拟多次访问计算属性，每次结果都一样，new Date()的值也被缓存了，没有发生改变setInterval(function(){    console.log(vm.getNum);     // Wed Feb 27 2019 13:00:42 GMT+0800 (中国标准时间)                                // 9},1000)// 模拟多次访问methods内的方法，new Date()每次结果都在发生改变，没有被缓存setInterval(function(){    console.log(vm.getNum2());     // （ new Date的值一直在变化 ）                                // 9},1000)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;计算属性&quot;&gt;&lt;a href=&quot;#计算属性&quot; class=&quot;headerlink&quot; title=&quot;计算属性&quot;&gt;&lt;/a&gt;计算属性&lt;/h2&gt;&lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Vue基础语法" scheme="http://yoursite.com/categories/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>es6常用数组操作及总结</title>
    <link href="http://yoursite.com/2019/04/10/es6%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/10/es6常用数组操作及总结/</id>
    <published>2019-04-10T01:01:48.000Z</published>
    <updated>2019-04-15T00:17:13.757Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol><li><code>array.filter(callback[, thisArg]);</code></li></ol><ul><li>filter是一个常用的数组操作,它用于将Array的不符合条件的元素过滤出来,返回由符合条件元素组成的新列表</li><li>和map()类似,filter也接收一个函数,和map()不同的是,filter()把传入的函数一次作用于每个元素,然后根据返回值是true还是flase决定保留还是丢弃该元素.</li><li>filter()接收的是一个回调函数,通常我们只使用它的第一个参数,表示Array的某个元素,表示元素的位置和元素本身.</li></ul><p><strong>filter的几种用法</strong></p><ul><li><p>创建一个数组，判断数组中是否存在某个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var newarr = [</span><br><span class="line">  &#123; num: 1, val: &apos;ceshi&apos;, flag: &apos;aa&apos; &#125;,</span><br><span class="line">  &#123; num: 2, val: &apos;ceshi2&apos;, flag: &apos;aa2&apos;  &#125;</span><br><span class="line">]</span><br><span class="line">console.log(newarr.filter(item =&gt; item.num===2 ))</span><br></pre></td></tr></table></figure></li><li><p>去掉空数组空字符串、undefined、null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;1&apos;,&apos;2&apos;,undefined, &apos;3.jpg&apos;,undefined]</span><br><span class="line">var newArr = arr.filter(item =&gt; item)</span><br><span class="line">console.log(newArr)</span><br><span class="line"></span><br><span class="line">var arr = [&apos;1&apos;,&apos;2&apos;,null, &apos;3.jpg&apos;,null]</span><br><span class="line">var newArr = arr.filter(item =&gt; item)</span><br><span class="line">console.log(newArr)</span><br><span class="line"></span><br><span class="line">&gt;//空字符串里面不能包含空格</span><br><span class="line">var arr = [&apos;1&apos;,&apos;2&apos;,&apos;&apos;, &apos;3.jpg&apos;,&apos;&apos;]</span><br><span class="line">var newArr = arr.filter(item =&gt; item)</span><br><span class="line">console.log(newArr)</span><br></pre></td></tr></table></figure></li><li><p>去掉数组中不符合项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [20,30,50, 96,50]</span><br><span class="line">var newArr = arr.filter(item =&gt; item&gt;40)  </span><br><span class="line">console.log(newArr)</span><br></pre></td></tr></table></figure></li><li><p>过滤不符合项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;10&apos;,&apos;12&apos;,&apos;23&apos;,&apos;44&apos;,&apos;42&apos;]</span><br><span class="line">var newArr = arr.filter(item =&gt; item.indexOf(&apos;2&apos;)&lt;0) </span><br><span class="line">console.log(newArr)</span><br></pre></td></tr></table></figure></li><li><p>数组去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7,8,8,0,8,6,3,4,56,2];</span><br><span class="line">var arr2 = arr.filter((x, index,self)=&gt;self.indexOf(x)===index) //indexof可以返回每个指定字符串在字符串中出现的位置</span><br><span class="line">console.log(arr2); //[1, 2, 3, 4, 5, 6, 7, 8, 0, 56]</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>array.map(callback[, thisArg]);</li></ol><ul><li>返回一个新数组,新数组中每个元素都是调用callback函数后返回的结果,</li><li>在实际使用的时候,我们可以利用map方法以便利的获取对象中的特定的属性值</li><li>注意:array.map由于不具有过滤的功能，因此array调用map函数时，如果array中的数据并不是每一个都会return，则必须先filter，然后再map，即map调用时必须是对数组中的每一个元素都有效。<figure class="highlight plain"><figcaption><span>maped </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``` maped: [&apos;aac&apos;, &apos;bbc&apos;];**</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>array.includes(searchElement, fromIndex);</li></ol><ul><li>inlcludes()方法用来判断一个数组是否包含一个指定的值,返回true或者false.searchElement要查找的元素,fromIndex开始查找的索引的位置<br><code>[1, 2, 3].includes(2, 2);  // false</code></li></ul><ol start="4"><li>array.findIndex(callback[, thisArg]);</li></ol><ul><li>返回通过callback函数测试的第一个元素的索引，否则返回-1，callback函数定义同上。<br><code>const findIndex = [1, 2, 3].findIndex(element =&gt; element &gt; 1);  // findIndex: 1</code></li></ul><ol start="5"><li>array.find(callback[, thisArg]);</li></ol><ul><li>返回通过callback函数测试的第一个元素，否则返回undefined，callback函数定义同上。<br><code>const finded = [1, 2, 3].find(element =&gt; element &gt; 1); // finded: 2</code></li></ul><ol start="6"><li>array.slice(begin, end)</li></ol><ul><li>返回一个新数组，包含原数组从begin 到 end(不包含end)索引位置的所有元素。<br><code>const newArray = [&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;].slice(1, 3);   // newArray: [&#39;one&#39;, &#39;two&#39;];</code></li></ul><ol start="7"><li>array.splice(start[, deleteCount, item1, item2, …]);</li></ol><ul><li>通过删除现有元素和/或添加新元素来更改一个数组的内容.start指定修改的开始位置.deleteCount:从start位置开始要删除的元素个数;要添加进数组的元素,从start位置开始.</li><li>注意:返回值是由被删除数组组成的数组,如果只删除了一个元素,则返回只包含一个元素的数组.如果没有删除元素,则返回空数组.</li><li>如果deleteCount大于start之后的元素的总数.则从start后面的元素都将被删除(含start).<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const myFish = [&apos;angel&apos;, &apos;clown&apos;, &apos;mandarin&apos;, &apos;sturgeon&apos;];</span><br><span class="line">const deleted = myFish.splice(2, 0, &apos;drum&apos;); // 在索引为2的位置插入&apos;drum&apos;</span><br><span class="line">// myFish 变为 [&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;sturgeon&quot;]，deleted为[]</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li>array.concat(array1, array2,…arrayN);</li></ol><ul><li>合并多个数组,返回合并后的数组,原数组没有变化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const array = [1,2].concat([&apos;a&apos;, &apos;b&apos;], [&apos;name&apos;]);</span><br><span class="line">// [1, 2, &quot;a&quot;, &quot;b&quot;, &quot;name&quot;]</span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>array.pop() </li></ol><ul><li>pop为从数组中删除最后一个元素</li><li>参数:无</li><li>返回值:被删除的项</li><li>是否改变原数组:改变</li><li>数组为空时返回undefined。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].pop();</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></li></ul><ol start="10"><li>Array.shift()</li></ol><ul><li>作用: 删除数组的第一个元素,</li><li>返回值:返回被删除的元素。</li><li>是否改变原数组:改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const shifted = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;].shift();</span><br><span class="line">// shifted: &apos;one&apos;</span><br></pre></td></tr></table></figure></li></ul><ol><li>array.push(element1, element2, ….elementN) 与 array.unshift(element1, element2, …elementN);</li></ol><ul><li>push是将一个或多个元素添加到数组的末尾，并返回新数组的长度; unshift将一个或多个元素添加到数组的开头，并返回新数组的长度。唯一的区别就是插入的位置不同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">const length = arr.push(4, 5);</span><br><span class="line">// arr: [1, 2, 3, 4, 5]; length: 5</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;常用方法&quot;&gt;&lt;a href=&quot;#常用方法&quot; class=&quot;headerlink&quot; title=&quot;常用方法&quot;&gt;&lt;/a&gt;常用方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;array.filter(callback[, thisArg]
      
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础语法二</title>
    <link href="http://yoursite.com/2019/04/08/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/04/08/Vue基础语法二/</id>
    <published>2019-04-08T12:45:47.000Z</published>
    <updated>2019-04-14T01:29:17.895Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>简单来说,假如父组件需要在子组件内放一些DOM,那么这些DOM是显示,不显示,在那些地方显示,如何显示,就是插槽(slot)分发负责的活</p></blockquote><p><strong><em>注意:父组件在子组件内套的内容,是不显示的</em></strong></p><h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><blockquote><p>slot就是占位符,用于展示在组件标签内部显示的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;  </span><br><span class="line">    &lt;children&gt;  </span><br><span class="line">        &lt;span&gt;12345&lt;/span&gt;  </span><br><span class="line">        &lt;!--上面这行不会显示--&gt;  </span><br><span class="line">    &lt;/children&gt;  </span><br><span class="line">&lt;/div&gt;  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">    var vm = new Vue(&#123;  </span><br><span class="line">        el: &apos;#app&apos;,  </span><br><span class="line">        components: &#123;  </span><br><span class="line">            children: &#123;    //这个无返回值，不会继续派发  </span><br><span class="line">                template: &quot;&lt;button&gt;为了明确作用范围，所以使用button标签&lt;/button&gt;&quot;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="单个slot"><a href="#单个slot" class="headerlink" title="单个slot"></a>单个slot</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;  </span><br><span class="line">    &lt;children&gt;  </span><br><span class="line">        &lt;span&gt;12345&lt;/span&gt;  </span><br><span class="line">        &lt;!--上面这行不会显示--&gt;  </span><br><span class="line">    &lt;/children&gt;  </span><br><span class="line">&lt;/div&gt;  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">    var vm = new Vue(&#123;  </span><br><span class="line">        el: &apos;#app&apos;,  </span><br><span class="line">        components: &#123;  </span><br><span class="line">            children: &#123;    //这个无返回值，不会继续派发  </span><br><span class="line">                template: &quot;&lt;button&gt;&lt;slot&gt;&lt;/slot&gt;为了明确作用范围，所以使用button标签&lt;/button&gt;&quot;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>这样写结果是:<code>&lt;button&gt;&lt;span&gt;12345&lt;/span&gt;</code>为了明确作用范围，所以使用button标签<code>&lt;/button&gt;</code>即父组件入到子组件的内容,插入到了子组件的<code>&lt;slot&gt;&lt;/slot&gt;</code></li><li>注意即使有多个标签,也会被一起插入,相当于用父组件插入子组件里的标签,替换了<code>&lt;slot&gt;&lt;/slot&gt;</code><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote><p>指将放入子组件里的不同html标签放在不同的位置(也就是不同的插槽内)</p></blockquote></li><li>父组件要在分发的标签里添加v-slot:name属性</li><li>子组件要在对应的分发位置的slot标签里添加name = name属性</li><li>然后就会将对应的标签放置在对应的位置上了</li><li>注意:slot不能当做组件的根元素使用,v-slot只用在组件中使用.</li><li>只要出现多个插槽，请始终为所有的插槽使用完整的基于<code>&lt;template&gt;</code>的语法</li></ul><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><blockquote><p>组件标签 的内容中的 变量 获取的是当前组件调用者的 作用域的变量</p><ul><li>父级模板里所有的内容都是在父级作用域中编译的,子级模板里的所有内容都是在子作用域中编译的.</li></ul></blockquote><h3 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h3><blockquote><p>slot可以设置后备内容</p><ul><li>后备内容指的就是默认内容,它只会在没有提供内容的时候被渲染,它被放在slot标签内部.</li><li>如果在父组件中使用并且提供内容,那个这个提供的内容将会被渲染并取代后备内容</li></ul></blockquote><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote><p>如何在组件内部的slot对应的组件外部内容中访问到组件内部的变量. 换句话说如何把组件内部的变量,通过slot在外部进行装饰.</p><ul><li>我们可以将user作为一个<slot>元素的特性绑定上去,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;slot v-bind:user=&quot;user&quot;&gt;</span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></slot></li></ul></blockquote><ul><li>绑定在<slot>元素上的特性被称为插槽prop.现在在父级作用域中,我们也可以给v-slot带一个值来定义我们插槽prop的名字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;current-user&gt;</span><br><span class="line">  &lt;template v-slot:default=&quot;abc&quot;&gt;</span><br><span class="line">    &#123;&#123; abc.user.firstName &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure></slot></li></ul><h2 id="动态组件-异步组件"><a href="#动态组件-异步组件" class="headerlink" title="动态组件/异步组件"></a>动态组件/异步组件</h2><ul><li>keep-alive</li><li>‘my-component’: () =&gt; import(‘./my-async-component’)</li></ul><h2 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h2><ol><li>父组件调用子组件</li></ol><ul><li>组件时可以复用的,父组件找到子组件的唯一方法是给子组件取名字(使用ref)</li><li>然后调用方法时,在父组件方法中通过this.$refs.(子组件名)就可以找到子组件,并且使用它</li></ul><ol start="2"><li>孙子及以下节点找父组件</li></ol><ul><li>调用自身的方法打印this.$root就是顶级父组件对象</li></ul><ol start="3"><li>孩子组件找父组件</li></ol><ul><li>调用自身的方法打印this.$parent就是父组件对象</li></ul><h3 id="访问组件"><a href="#访问组件" class="headerlink" title="访问组件"></a>访问组件</h3><ul><li>访问根实例 $root</li><li>访问父级组件实例 $parent</li><li>访问子组件实例或子元素 $refs.xx</li></ul><h2 id="过渡-动画"><a href="#过渡-动画" class="headerlink" title="过渡/动画"></a>过渡/动画</h2><ul><li>v-enter  过渡的开始状态,在元素被插入之前生效</li><li>v-enter-active 定义进入过渡生效的状态,在整个过渡阶段应用,在元素被插入之前生效</li><li>v-enter-to  定义进入过渡的结束状态</li><li>v-leave   定义离开过渡的开始状态</li><li>v-leave-active 定义离开过渡生效的状态</li><li>v-leave-to 定义离开过渡的结束状态</li><li>注意: 需要使用vue提供的transiton标签把要进行过渡的元素包裹起来。</li></ul><h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><blockquote><p>可以复用的代码块,在组件引入可以把混合的对象合并到当前组件.</p><ul><li>通过使用mixins属性并且通过数组的形式引入要被混合的对象引入到当前组件</li></ul></blockquote><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><blockquote><p>vue不提倡直接操作dom元素,如果真的需要有,一般在自定义指令里完成.指令可以传递参数和修饰符,使指令的操作更加灵活.</p><ul><li>通过directive属性定义,在inserted时被插入DOM对象</li><li>注意: 第一个参数永远是el,指的是当前指令的DOM对象</li><li>在标签中使用时需要加上v-</li><li>参数 binding.value 可以获取指令的参数</li><li>修饰符 binding.modifiers 通过修饰符可以传递额外的参数,多个参数是对象类型,其中每一个为boolean类型.</li></ul></blockquote><h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><ul><li>过滤器可以同时使用多个,通过管道符隔开</li><li>过滤器可以传参(可以传多个)</li><li>过滤器通过使用Vue.filter定义第一个参数为过滤器的名称,第二个参数为一个回调函数回调函数也有一个参数,为要过滤元素的属性值.</li></ul><h2 id="列表渲染-v-for"><a href="#列表渲染-v-for" class="headerlink" title="列表渲染(v-for)"></a>列表渲染(v-for)</h2><blockquote><p>我们使用v-for指令根据一组数据的选项列表进行渲染.v-for指令需要以item in items形式的特殊语法,items是源数据组并且item是数组元素迭代的别名<br><strong>基本用法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id =&quot;example-1&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123;item.message&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var example1 new = vue(&#123;</span><br><span class="line">    el:&quot;#example&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        items:&#123;</span><br><span class="line">            &#123;message:&apos;foo&apos;&#125;,</span><br><span class="line">            &#123;message:&apos;bar&apos;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>在v-for块中,我们拥有对父作用域属性的完全访问权限,v-for还支持一个可选的第二个参数为当前的索引</li><li>注意:你也可以使用of代替in作为分隔符,因为它是最近Javascript迭代器的语法</li></ul><p><strong>对象迭代</strong></p><ul><li>可以提供三个参数:</li><li>value为键值,第二个参数key为键名,第三个参数为索引index</li></ul><p><strong>整数迭代</strong></p><ul><li>v-for也可以取整数.在这种情况下,它将重复多次模板</li></ul><p><strong>组件和v-for</strong></p><ul><li>在自定义组件里你也可以使用v-for</li><li>然而他不能自动传递数据到组件里,因为组件里有自己的作用域,为了传递迭代数据到组件里,我们要使用pros</li></ul><p><strong>key</strong></p><ul><li>为了给Vue一个提示,以便它能跟踪每个节点的身份,从而重用和重新排序现有元素,你需要为每一项提供一个唯一的key值,它的工作方式类似于一个属性,所以你需要使用v-bind来绑定动态值</li></ul><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变异方法-会改变原数组-且会触发更新"><a href="#变异方法-会改变原数组-且会触发更新" class="headerlink" title="变异方法:会改变原数组,且会触发更新"></a>变异方法:会改变原数组,且会触发更新</h3><ul><li>push,pro,shift,unshift,splice,sort,reverse<h3 id="非变异方法-不会改变原数组-总是返回一个新数组"><a href="#非变异方法-不会改变原数组-总是返回一个新数组" class="headerlink" title="非变异方法: 不会改变原数组,总是返回一个新数组"></a>非变异方法: 不会改变原数组,总是返回一个新数组</h3></li><li>filter concat slice map some <h3 id="显示过滤-排序结果"><a href="#显示过滤-排序结果" class="headerlink" title="显示过滤/排序结果"></a>显示过滤/排序结果</h3></li><li>有时,我们希望显示一个数组的过滤或者排序副本,但是不改变或重置原始数据,在这种情况下,可以创建或者返过滤或者排序数组的计算属性</li></ul><h3 id="Vue中的v-if与v-show的区别"><a href="#Vue中的v-if与v-show的区别" class="headerlink" title="Vue中的v-if与v-show的区别"></a>Vue中的v-if与v-show的区别</h3><blockquote><p>v-if的特点</p><ul><li>有较高的切换消耗,每次都会重新删除或者创建的元素.就是说,如果你每次都需要删除和切换频率很高的时候建议使用v-show<br>v-show的特点</li><li>每次不会重新进行dom元素的创建和删除,只是通过display属性切换元素的属性(display:none)不会占据原来的空间,有较高的初始渲染消耗</li><li>总结v-if有较高的切换消耗,v-show有较高的初始渲染消耗</li><li>元素需要频繁切换时,使用v-show,当运行条件不大可能改变的时候可以使用v-if.</li></ul></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>因为javascript的限制,Vue.js不能检测到下面数组的变化</li></ul><ol><li>直接用索引设置元素,如vm.items[0] = {}</li></ol><ul><li>为了解决这个问题,Vue.js扩展了观察数组,为它添加了一个$set()方法</li><li><code>example.items.$set(0,{childmsg:&#39;Changed!&#39;})</code></li></ul><ol start="2"><li>修改数据的长度,如vm.items.length= 0</li></ol><ul><li>至于这个问题,只需要使用一个空数组替换items.除了$set方法,Vue.js也为观察数组提供了$remove方法,用于从目标数组中查找并删除元素,在它内部调用它splice().因此,不必这样<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var index = this.items.indexOf(item)</span><br><span class="line">if(index!=-1)&#123;</span><br><span class="line">    this.items.splice(index,1)</span><br><span class="line">&#125;</span><br><span class="line">只用这样`this.items.$remove(item);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;插槽&quot;&gt;&lt;a href=&quot;#插槽&quot; class=&quot;headerlink&quot; title=&quot;插槽&quot;&gt;&lt;/a&gt;插槽&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;
      
    
    </summary>
    
      <category term="Vue基础语法" scheme="http://yoursite.com/categories/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="-Vue -基础" scheme="http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>原型对象总结</title>
    <link href="http://yoursite.com/2019/04/07/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/07/原型对象总结/</id>
    <published>2019-04-07T14:03:20.000Z</published>
    <updated>2019-04-15T12:34:25.824Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><blockquote><p>函数的prototype属性</p><ul><li>每个函数都有一个prototype属性,它默认指向一个Object空对象(即称为:原型对象)</li><li>原型对象中有一个constructor,它指向函数对象</li></ul></blockquote><ul><li>给原型对象添加属性(一般都是方法)<ul><li>作用: 函数的实例对象自动拥有原型中的属性(方法)</li><li>实例对象可以引用原型对象添加的属性(一般是方法);<blockquote><p>显式原型和隐式原型</p></blockquote></li></ul></li><li>每个函数fucntion都有一个prototype,即显式原型</li><li>每个实例对象都有一个<strong>proto</strong>,称为隐式原型</li><li>实例对象的隐性原型对应的值,为其对应的构造函数的显式原型的值</li><li>总结:</li><li>函数的prototype属性:在定义函数时自动添加,默认值是一个空Object对象(也就是执行函数定义时自动添加了prototype属性)</li><li>注意prototype保存的值是地址值,它是一个引用变量属性.</li><li>函数的<strong>proto</strong>属性:在创建对象时自动添加,默认值为prototype的值</li><li><p>程序员能直接操作显式对象,但不能直接操作隐式对象(ES6之前)</p></li><li><p>执行函数定义与执行函数的区别</p><ul><li>执行函数定义的时候,函数体还没有执行,只是定义了函数,本质上只是创建了一个函数对象 </li><li>加()的时候函数体才会执行调用</li></ul></li></ul><h3 id="引入数据类型和基本数据类型"><a href="#引入数据类型和基本数据类型" class="headerlink" title="引入数据类型和基本数据类型"></a>引入数据类型和基本数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = xxx; a中到底保存的是什么?</span><br></pre></td></tr></table></figure><ol><li>如果xxx是基本数据类型.则保存的就是这个数据</li><li>如果xxx是对象,保存的是这个对象的地址值</li><li>注意:xxx是一个变量,保存的xxx的内存内容(可能是基本数据,也可能是地址值)特别重要!!!!!</li></ol><ul><li><p>关于引用变量赋值的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;name:&apos;tom&apos;&#125;</span><br><span class="line">var obj2 = obj1;</span><br></pre></td></tr></table></figure></li><li><p>obj2保存的是obj1的内存内容,只不过obj1的内存内容是一个地址值</p></li><li>注意:2个引用变量指向同一个对象,通过一个变量修改对象内部数据,另一个变量看到的是修改以后的数据</li><li>2个引用变量指向同一个对象,让其中一个引用变量指向另一个对象,另一个引用变量依然指向前一个对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a  =&#123;age:12&#125;</span><br><span class="line">function fn2(obj)&#123;</span><br><span class="line">    obj = &#123;age:15&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn2(a);</span><br><span class="line">console.log(a.age);</span><br></pre></td></tr></table></figure><ul><li>特别重要:</li></ul><ol><li>首先将a的内容赋值给obj,在函数还没有调用的时候,a存储的值等于obj存储的值,指向同一个对象,指向{age:12};</li><li>下一步执行函数体,obj等于一个新的对象,将一个新的对象赋值给obj,指向{age:15};</li><li>这里有两个注意点: a的值没有变,没有改变a所指向的对象.修改了obj指向的内容</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>分为两大类</strong><br><strong>1.基本数据类型</strong></p><ol><li>Number:任意数值</li><li>string:任意文本</li><li>boolean: true/false</li><li>undefined: undefined</li><li>null: null</li></ol><ul><li>对象(引用类型)</li></ul><ol><li>object一般对象类型</li><li>array特别的对象类型(下标/内部数据有序)</li><li>function特别对象类型(可执行)</li></ol><p><strong>判断</strong></p><ul><li>typeof:</li><li>可以区别:数值,字符串,布尔值,undefined,function</li><li>不能区别null与对象 数组与对象</li><li>instanceof(专门用来判断对象的数据类型):object,Array与Function</li><li>=== 可以用来判断null与undefined</li></ul><blockquote><p>undefined与null区别</p><ul><li>underfined代表定义为赋值</li><li>null表示定义且赋值了,只是值为null</li></ul></blockquote><blockquote><p>什么时候给变量赋值为null呢&gt;?</p><ul><li>初始赋值 表示将要赋值为对象</li><li>结束的时候 让b指向的对象称为垃圾对象(被垃圾回收器回收)</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;原型对象&quot;&gt;&lt;a href=&quot;#原型对象&quot; class=&quot;headerlink&quot; title=&quot;原型对象&quot;&gt;&lt;/a&gt;原型对象&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;函数的prototype属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个函
      
    
    </summary>
    
      <category term="面向对象" scheme="http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="-Javascript -面向对象" scheme="http://yoursite.com/tags/Javascript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
