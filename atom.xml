<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CrissWuBlog</title>
  
  <subtitle>成為一個厲害得普通人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-23T10:44:32.086Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Criss Wu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web前端面试之vue</title>
    <link href="http://yoursite.com/2019/05/22/web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8Bvue/"/>
    <id>http://yoursite.com/2019/05/22/web前端面试之vue/</id>
    <published>2019-05-22T05:28:53.000Z</published>
    <updated>2019-05-23T10:44:32.086Z</updated>
    
    <content type="html"><![CDATA[<p>###vue面试题总结</p><p>####前端seo优化</p><ul><li>搜索引擎网站,比如百度,后台都有一个非常庞大的数据库,里面存储了海量的关键词,而每个关键词又对应这很多网址,这些网址是百度程序从互联网上一点点下载收集而来的,这些程序称之为搜索引擎蜘蛛,或者网络爬虫</li><li><p>这些程序每天在互联网上爬循,从一个链接到另一个链接,下载其中内容,进行分析提炼,找到其中的关键词,</p></li><li><p>一般提倡扁平化布局,一般而言,网站的层次结构越少,越容易被收录.中小型网站超过三级,蜘蛛就不愿意往下爬</p></li></ul><ol><li>控制首页链接数量  网站首页是权重最高的地方,如果首页链接太少,没有桥,蜘蛛也不能往下爬到内页,直接影响网站收录数量.但是网站的链接也不能太多,一旦太多,没有实质性链接,很容易影响用户体验,也会降低网站首页的群众,收录效果也不好</li><li>扁平化的目录层次,尽量让蜘蛛只要跳转三次,就能到达网页的任何一个内页,扁平化的目录机构</li><li>导航尽量采用文字方式,也可以搭配图片导航,但是图片导航一定要优化,img标签必须添加alt title属性,告诉搜索引擎导航的定位,做到图片即使没有显示,用户也能显示提示文字</li><li>控制页面的大小,一个页面最好不要超过100k,太大,页面的加载速度慢,当速度很慢的时候,用户体验不好,留不住访客</li></ol><ul><li>页面代码优化</li></ul><ol><li>title标题,只强调重点即可,尽量把重要的关键词放在前面,关键词不要重复出现,尽量做到每个页面title标题中的不要设置相同的内容</li><li>body尽量让标签语义化,在适当我位置使用适当的标签</li><li>a标签, 如果是页面链接的话,要加title属性说明,让访客和蜘蛛知道,而外部链接,链接到其他到其它网站的,则需要加上el=”nofollow”属性, 告诉蜘蛛不要爬,因为蜘蛛一旦爬了外部链接以后.就不会再回来了</li><li>主要的内容不要使用js输出,因为蜘蛛不认识</li><li>尽量不要使用iframe框架,因为蜘蛛一般会读取其中的内容</li><li>尽量不要使用display:none,因为不想显示的内容,应当设置z-index或设置到浏览器显示器之外.因为搜索引擎会过滤掉dispaly:none其中的内容</li><li>不但精简代码.</li></ol><ul><li>js时间,与时间戳的转换</li><li>Date.parse(new Date())  但是这种方法不太好,因为毫秒级别的值被转化成000</li><li>(new Date()).valueOf()  通过valueOf() 函数返回指定对象的原始值,获得准确的时间戳值</li><li>new Date().getTime()   通过原型方法直接获得当前时间的毫秒值</li><li><p>Number(new Date())  减时间转化成一个number类型的数值,即时间戳</p></li><li><p>二，时间戳转时间<br>var timestamp4 = new Date(1472048779952);//直接用 new Date(时间戳) 格式转化获得当前时间 </p></li></ul><p>####vue中的mvvm模式</p><ul><li>即Model-View-ViewModel</li><li>Vue是以数据驱动的</li></ul><p>###vue的生命周期**</p><ul><li>创建前/后，DOM渲染前/后，更新前/后，销毁前/后； </li><li>对于各个周期的理解： </li><li>创建前/后： </li><li>beforeCreated：此时的vue实例还没有挂载元素$el，数据对象data也是undefiend； </li><li>created：vue实例的数据对象data有了，但是$el还没有 </li><li>载入前/后： </li><li>beforeMount：vue的实例的$el和data都初始化了，但还是挂载在之前虚拟的DOM节点上面，data.message还未替换 </li><li>mounted :vue实例挂载完成，data.message成功渲染。 </li><li>更新前/后 </li><li>在data发生变化的时候，会触发beforeUpdate和updated方法。 </li><li>销毁前/后： </li><li>在destiory之后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在</li></ul><p><strong>请说下vue组件封装的过程</strong></p><ul><li>首先,组件可以提升整个项目的开发效率,能够把页面抽象成多个相对独立的模块,解决传统项目:开发效率低,维护难,复用性低等特点</li></ul><ol><li>首先使用Vue.extend方法创建一个组件,</li><li>然后使用vue.component方法注册组件.子组件需要数据,可以在props中接受定义.而在子组件修改成好数据后.想把数据传递给父组件,可以采用emit方法</li></ol><p><strong>嵌套路由怎么定义</strong></p><ul><li>当有多层组件嵌套的时候,可以考虑嵌套路由的实现</li><li>因此我们需要在vue-router的参数中使用children配置,这样就可以很好的实现路由嵌套</li><li>路由如何实现重定向:redirect,</li></ul><p><strong>怎么定义vue-router的动态路由?怎么获取传过来的动态参数</strong></p><ul><li>在router目录下的index.js文件中,对path属性加上/:id</li><li>使用router对象的params.id功能</li></ul><p><strong>keep-alive</strong></p><ul><li>在vue-router中写在keep-alive,keep-alive的含义:如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令</li></ul><p><strong>vue有哪几种导航钩子</strong></p><ul><li>三种:最常用的一种的全局导航钩子,router.beforEach(to,form,next)可以用作路由跳转跳转前进行拦截判断<ul><li>router.beforeEach(to, from, next),</li><li>router.beforeResolve(to, from, next),</li><li>router.afterEach(to, from ,next)</li></ul></li><li>组件内的钩子函数<ul><li>beforeRouteEnter</li><li>beforeRouteUpdate,</li><li>beforeRouteLeave</li></ul></li><li>单独路由独享组件<br>  beforeenter<br><strong>axios是什么? 如何使用?怎么解决跨域问题?</strong></li></ul><ol><li>axios是请求后台资源的模块</li><li>因为vue-cli会建立一个服务器,那么本地用axios请求,会造成跨域,解决方法是通过vue-cli生产的框架的结构目录下的config/index.js去配置proxyTable</li></ol><p><strong>指令v-el的使用</strong><br>有时候我们想就像使用jquery那样去访问一个元素，此时就可以使用v-el指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。</p><p><strong>Vue.js是什么</strong></p><ul><li>Vue.js（是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。</li></ul><p><strong>vue.js的特性</strong></p><ul><li>MVVM模式:数据变量(model)发生改变视图(view)也改变,视图(view)改变,数据变量也发生改变</li><li>使用MVVM模式有哪些好处?<ul><li>低耦合,view可以独立于model变化和修改,一个viewModel可以绑定不同的view上,当view变化的时候model可以不变,当model变化的时候view也可以不变</li><li>可重复用性,可以将一些视图的逻辑放在viewmodel里面,让很多view重用这段视图逻辑.</li><li>独立开发,开发人员可以专注于业务逻辑和数据的开发(viewmodel) 设计人员可以专注于页面的的设计</li></ul></li></ul><p><strong>React / Vue 项目时为什么要在组件中写 key，其作用是什么?</strong></p><ul><li>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 Diff 算法中 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染</li></ul><p><strong>20. computed 和 watched 的区别</strong></p><ul><li>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。所以一般来说需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。</li></ul><p><strong>自定义指令的方法有哪些？它有哪些钩子函数？还有哪些钩子函数参数？</strong></p><ul><li>全局自定义指令:在vue对象的directive方法里有两个参数,一个指令名称,另一个是函数. 在组件内定义指令   (局部定义指令):directives 全局组件的注册components组件封装一下的的</li><li>钩子函数包括:bind(绑定事件触发) inserted(插入节点时候,触发)、update组件内相关更新,unbind(只调用一次,指令与元素解绑时调用)</li></ul><p><strong>4、说出至少4种vue当中的指令和它的用法？</strong></p><ul><li>答：v-if：判断是否隐藏；v-else v-else-if v-on绑定事件 快捷方法@ v-text读取文本内容 v-html读取html标签 v-class v-once  v-for：数据循环出来；v-bind:class：绑定一个属性；v-model：实现双向绑定  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-focus/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 注册一个全局自定义指令 v-focus</span><br><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当绑定元素插入到 DOM 中。</span><br><span class="line">  inserted: function (el,binding) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">new Vue(&#123;</span><br><span class="line">　　el:&apos;#app&apos;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>页面的优化方案</strong></p><ul><li>防止的css的过多嵌套,合理的css选择器可以避免这个问题,这里可以多提一句,现在新出的css预处理器,如less、sass基本都是通过嵌套来写css,所以不知道它里面是怎么优化的</li><li>减少http请求次数,将图片资源整合,将其他文件通过打包工具打包,因为加载两张图片没有加载一张图片的速度快,这是由于加载一张图片,不需要切换工作,盛夏了<h3 id="微信小程序面试题"><a href="#微信小程序面试题" class="headerlink" title="微信小程序面试题"></a>微信小程序面试题</h3></li></ul><p><strong>微信小程序主要目录和文件的作用</strong></p><ul><li>project.config.json 项目配置文件,用得最多的就是配置是否开启https校验</li><li>app.js获取一些全局的基础数据,一般会将一些持久化数据放置在这里</li><li>app.json底部tab、 window标题栏、 page页面路由设置等  </li><li>app.wxss公共样式,引入iconfont等</li><li>pages里面包含一个个具体的页面</li><li>index.json(包含当前页面标题和引入组件等);</li><li>index.wxml(页面结构)</li><li>index.wxss(页面样式表)</li><li>index.js 页面逻辑处理,请求和数据处理</li></ul><p><strong>你是怎么封装微信小程序的数据请求的？</strong></p><ol><li>一般我封装小程序数据请求的时候 我一般会专门创建一个httpserve封装请求后台数据的方法</li><li>在config.js,配置基地址、试听课信息后台数据接口接口</li><li>然后创建一个api.js文件 引入接口 引入请求方法. 集中处理请求数据的方法</li></ol><p><strong>微信小程序如何传值</strong></p><ol><li>微信小程序设置id的方法表示传值,设置一个id并给当前的id赋值上对应的key值,比如一步电影的id,后面带着去下一页面查询,详细信息</li><li>通过e.currentTarget.id获取当前item的下标的id.并通过设置全局对象的方式来传递数值.</li><li>通过data-xxx的方法标识传值,xxx可以自定义取名,比如data-key等等都可以</li><li>在js的bindtap响应事件中,通过解析一层层找到数据,var id = e.target.dataset.id </li></ol><p><strong>微信小程序如何跨页面取值</strong></p><ul><li>页面跳转后,们就需要在下一个页面拿到传递的数据（这个数据在传递前，就已经被设置成全局变量）</li><li>跳转页分为两种,一种是跳转到新的页面url后面的路径并可以携带参数,一种是在后面加上redirect,在当前页面打开,并携带参数</li><li>而且开发页面小程序的时候,我们规定页面路径最多只能是五层,请避免多层级交互方式,跳转的页面一定不要忘了在app.json里配置,否则会报错</li></ul><p><strong>微信小程序页面跳转三种方式</strong></p><ol><li>wx.navigateTo(object) 保留当前页面,跳转到页面内的某个页面,使用wx.navigateBack可以返回到原页面.</li><li>wx.redirectTo(OBJECT) 关闭当前页面，跳转到应用内的某个页面。</li><li>wx.navigateBack(OBJECT) 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages()) 获取当前的页面栈，决定需要返回几层。 </li></ol><p><strong>微信小程序之间如何传递数据</strong></p><ul><li>初始化代码的时候，小程序会读取一个 app.js的文件，在这里我们可以定义我们所需要的全局变量。</li><li>然后在页面中，可以通过getApp()方法获取到全局应用对象，可以对全局变量进行读取并更改.</li><li>但是由于app.js在项目中是用来做基础配置的.因此不建议将很多变量放在这里配置.一般会将一些持久化的数据放置在这里,对于一些经常需要变动的量不建议用这个方法</li></ul><p><strong>你使用过哪些方法，来提高微信小程序的应用速度？</strong></p><ol><li>提高页面加载速度</li><li>用户行为预测</li><li>减少默认data的大小</li><li>组件化方案</li></ol><p><strong>简述微信小程序原理？</strong></p><ol><li>微信小程序采用javascript,wxml,wxss三种技术进行开发,从技术讲和现有的前端开发差不多.</li><li>WXML微信自己基于XML语法开发的,开发时只能使用微信提供的现有标签,HTML的标签无法使用</li><li>WXSS:WXSS具有CSS的大部分特性,但不是所有都支持,</li><li>微信的架构,是数据驱动的模式,它的ui和数据是分离的.所有的页面更新.都需要通过对数据的更改来实现</li></ol><p><strong>微信的小程序</strong></p><ul><li>没有body;样式可以直接使用import导入</li><li>wxss的图片引入需要使用外链地址,不能使用添加背景图片的方式</li></ul><p><strong>小程序调用后台接口遇到哪些问题？</strong></p><ol><li>数据的大小有限制，超过范围会直接导致整个小程序崩溃，除非重启小程序</li></ol><p><strong>微信小程序常见问题</strong></p><ol><li>rpx(responsivepixel)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###vue面试题总结&lt;/p&gt;
&lt;p&gt;####前端seo优化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索引擎网站,比如百度,后台都有一个非常庞大的数据库,里面存储了海量的关键词,而每个关键词又对应这很多网址,这些网址是百度程序从互联网上一点点下载收集而来的,这些程序称之为搜索引擎蜘蛛,
      
    
    </summary>
    
    
      <category term="vue 面试" scheme="http://yoursite.com/tags/vue-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>前端面试之前端综合问题</title>
    <link href="http://yoursite.com/2019/05/03/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/05/03/前端面试之前端综合问题/</id>
    <published>2019-05-03T07:07:52.000Z</published>
    <updated>2019-05-24T17:10:58.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端面试问题"><a href="#前端面试问题" class="headerlink" title="前端面试问题"></a>前端面试问题</h2><h3 id="前端页面有哪三层构成-分别是什么-起什么样的作用"><a href="#前端页面有哪三层构成-分别是什么-起什么样的作用" class="headerlink" title="前端页面有哪三层构成,分别是什么?起什么样的作用?"></a>前端页面有哪三层构成,分别是什么?起什么样的作用?</h3><p><strong>1. 结构层html</strong></p><ul><li>由html或者XHTML之类的标记语言创建,即:’标签’</li></ul><p><strong>2.样式层css</strong></p><ul><li>解决结构层,如何显示的问题</li></ul><p><strong>3.行为层javascript</strong></p><ul><li>内容如何对事件做出反应一类的问题解决</li></ul><h3 id="常见的浏览器内核有哪些"><a href="#常见的浏览器内核有哪些" class="headerlink" title="常见的浏览器内核有哪些?"></a>常见的浏览器内核有哪些?</h3><ul><li>trident内核:IE, 360,搜狗浏览器,又称[MSHTML]</li><li>Gecko内核: Netscape6及以上版本,MozillaSuite firefox</li><li>preston内核: Opera7及以上 现在为Blink</li><li>Webkit内核: Safari,Chrome等 [Chrome的:Blink,webkit的分支]</li></ul><h3 id="介绍一下你对浏览器内核的理解"><a href="#介绍一下你对浏览器内核的理解" class="headerlink" title="介绍一下你对浏览器内核的理解"></a>介绍一下你对浏览器内核的理解</h3><ul><li>主要分成两个部分,<strong>渲e染引擎layout engineer或者Rendering Engine</strong>和<strong>js引擎</strong></li><li><strong>渲染引擎:</strong>负责取得网页的内容(HTML,XML,图像等等),整理讯息(列入加入CSS等),以及计算机的显示方式,然后会输出至显示器和打印机.浏览器的内核不同会对网页的语法解释也会有所不同,所以渲染的效果也不相同,</li><li><strong>js引擎:</strong>解析和执行JavaScript来实现网页的动态效果.</li></ul><h3 id="html5有哪些新特性"><a href="#html5有哪些新特性" class="headerlink" title="html5有哪些新特性"></a>html5有哪些新特性</h3><ol><li>绘图canvas</li><li>用于媒介回放的video和audio元素</li><li>本地离线储存loaclStroage长期存储数据,浏览器关闭后数据不会丢失</li><li>语义化更好的内容元素,header,footer,acticle,nav,section</li><li>表单控件calendar,data,time,email,search,url</li></ol><p><strong>如何让ie6/7/8支持h5新标签</strong> <strong>如何处理HTML5新标签的浏览器兼容问题</strong></p><ul><li>IE8/IE7/IE6支持通过document.createElement方法产生的标签,可以利用这一特性让这些浏览器支持html5新标签,注意还需要添加新标签的默认样式</li></ul><p><strong>简述一下你对语义化的理解</strong></p><ul><li>html语义化让结构更清晰，便于对浏览器、搜索引擎解析.</li><li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO</li><li>使阅读源代码的人对网站更容易将网站分块，增强代码可读性</li></ul><p><strong>iframe标签有哪些缺点</strong></p><ul><li>iframe会阻塞主页面的onload事件</li><li><p>搜素引擎的检索程序无法解读这种页面,不利于seo</p></li><li><p>如果要使用ifame内联框架,最好动态给iframe添加src属性,可以绕开这两个问题</p><h3 id="title与h1的区别、b与strong的区别、i与em的区别？"><a href="#title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="title与h1的区别、b与strong的区别、i与em的区别？"></a>title与h1的区别、b与strong的区别、i与em的区别？</h3></li><li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响；</li><li>strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<b>是展示强调内容。</b></strong></li><li>i内容展示为斜体，em表示强调的文本；</li><li>Physical Style Elements – 自然样式标签</li><li>b, i, u, s, pre</li><li>Semantic Style Elements – 语义样式标签</li><li>strong, em, ins, del, code</li><li>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。</li></ul><h3 id="浏览器是如何渲染页面的"><a href="#浏览器是如何渲染页面的" class="headerlink" title="浏览器是如何渲染页面的?"></a>浏览器是如何渲染页面的?</h3><ul><li>渲染流程流程如下:</li></ul><ol><li>解析html文件,创建DOM树,自上而下执行,遇到任何(link,style)与脚本(script)都会阻塞(外部样式不阻塞外部脚本的加载)</li><li>解析css.优先级:浏览器默认设置&lt;用户设置&lt;外部设置&lt;内联样式&lt;html中的style样式</li><li>将CSS和DOM数合并,构建渲染数(render tree)</li><li>布局和绘制,重绘(repaint)和重排(reflow)</li></ol><h3 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h3><p><strong>简洁版</strong></p><ol><li>浏览器根据请求的URL交给DNS域名解析,找到真实的ip,向服务器发起请求</li><li>服务器交给后台处理完成后返回数据,浏览器接收文件(html/css/js/图像)</li><li>浏览器对加载到的资源(HTML,js,CSS等)进行语法解析,建立相应的内部数据结构(如HTML的DOM)</li><li>载入解析到的资源文件,渲染页面,完成.</li></ol><p><strong>详细篇</strong></p><ol><li>首先,在浏览器地址栏输入url</li><li>在浏览器先查看浏览器缓存-系统缓存-路由缓存,如果内存中有,会直接在屏幕中显示内容.</li><li>如果没有缓存,则在发送http请求之前,需要进行域名解析(DNS解析)它可以将域名和ip地址相互映射的一个分布式数据库,能够使人更加方便的访问互联网,而不用去记住ip地址),解析获取响应的ip地址</li><li>浏览器向服务器发送tcp连接,与浏览器建立三次握手(tcp即传输控制协议,是互联网传输协议集的一种)</li><li>握手成功后,浏览器向服务器发送http请求,请求数据包</li><li>服务器处理收到的请求后,将数据返回至浏览器</li><li>浏览器接收到HTTP响应</li><li>读取页面内容,浏览器渲染,解析html源码</li><li>生成DOM树,解析css样式,js交互</li><li>客户端和服务器交互</li><li>ajax查询</li></ol><h3 id="你有用到过哪些前端性能优化的方法"><a href="#你有用到过哪些前端性能优化的方法" class="headerlink" title="你有用到过哪些前端性能优化的方法?"></a>你有用到过哪些前端性能优化的方法?</h3><ol><li>HTML部分</li></ol><ul><li>语义化Html:好处在于可以使用代码简洁清晰,支持不同的设备,利于搜索引擎,便于开发</li><li>减少DOM节点:加速页面渲染</li><li>给图片加上正确的宽高,这可以减少页面重绘,同时方便图片缩放</li><li>防止src属性和link的href为空,当值为空时,浏览器很可能会把当前页面当成其属性值加载</li><li>正确的闭合标签</li><li>使用link而不是@import导入样式</li><li>样式方在页首,js放在页尾</li></ul><ol><li>CSS部分</li></ol><ul><li>使用css缩写,减少代码数量</li><li>通过精灵图片合成一张,减少图片的请求</li><li>删除重复的css</li></ul><ol start="3"><li>javascript</li></ol><ul><li>尽量少用全局变量</li><li>使用事件代理绑定事件,</li><li>避免频繁操作DOM节点</li><li>不使用EVAL</li><li>减少对象查找,如a,b,c,d</li><li>对字符串进行循环操作,比如替换,查找,应使用正则表达式</li><li>删除重复的js</li></ul><p><strong>为什么要少用全局变量</strong></p><ul><li>全局变量存放在静态存储区,系统需要为其分配内存,一直到程序结束,才会释放内存,所以空间利用率比较低,大量的全局变量,很快会把内存用光,所以要少用全局变量.</li><li>局部变量动态分配,随用随从栈内栈中申请,用完就释放</li><li>全局变量由于每个函数都可以使用,所以任何一个函数的修改,如果修改了全局变量,都有可能影响到其他函数</li></ul><h3 id="前端面试之自我介绍"><a href="#前端面试之自我介绍" class="headerlink" title="前端面试之自我介绍"></a>前端面试之自我介绍</h3><ul><li>您好,我叫吴浩,来自安徽,今天是想来面试贵公司web前端开发岗位,我想从以下几个方法来介绍自己</li></ul><ol><li>首先是工作经验方面,从接触前端至今已经2年多了,之前分别在宁国睿智科技有限公司和郑州不凡科技有限公司任职过前端开发这个岗位,起初写的最多就是pc端网站,也参与过响应式开发.小程序,最近在上家公司做的是幼儿园的后台管理系统.</li><li>在学习方面,我毕业后并没有从事专业相关的岗位,而是对互联网产生了浓厚兴趣,通过自学,进入公司实习等途径接触到前端这个岗位,在这期间,我通过学习,逐渐对HTML5新特性,css/javascript,并且对前端语义化有了较为深刻的理解,可以根据ui设计稿快速完成构建高质量的html页面.并且能独立完成响应式网页开发和移动端web开发.我能够熟练的使用原生js进行编程</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端面试问题&quot;&gt;&lt;a href=&quot;#前端面试问题&quot; class=&quot;headerlink&quot; title=&quot;前端面试问题&quot;&gt;&lt;/a&gt;前端面试问题&lt;/h2&gt;&lt;h3 id=&quot;前端页面有哪三层构成-分别是什么-起什么样的作用&quot;&gt;&lt;a href=&quot;#前端页面有哪三层构成-分别
      
    
    </summary>
    
      <category term="前端面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack知识总结</title>
    <link href="http://yoursite.com/2019/04/28/webpack%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/28/webpack知识总结/</id>
    <published>2019-04-28T05:31:28.000Z</published>
    <updated>2019-05-03T08:07:35.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack知识总结"><a href="#webpack知识总结" class="headerlink" title="webpack知识总结"></a>webpack知识总结</h2><h3 id="webpack简介"><a href="#webpack简介" class="headerlink" title="webpack简介"></a>webpack简介</h3><ul><li>本质上,webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler).当 webpack 处理应用程序时,它会递归地构建一个依赖关系图(dependency graph),其中包含应用程序需要的每个模块,然后将所有这些模块打包成一个或多个 bundle</li></ul><h3 id="webpack核心模块"><a href="#webpack核心模块" class="headerlink" title="webpack核心模块"></a>webpack核心模块</h3><p><strong>入口(entry)</strong></p><ul><li>入口起点(entry ponit)指示 webpack应该使用哪个模块,来构建其内部依赖图的开始,进入入口起点后,webpack会找出哪些模块和库是入口起点(直接和间接)依赖的,每个依赖项随即被处理,最后输出到称之为bundles的文件中</li><li>可以在webpack配置中配置entry</li></ul><p><strong>多入口文件配置</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry:&#123;</span><br><span class="line">    app:&apos;./src/index.js&apos;</span><br><span class="line">    print:&apos;./src/pring.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>输出(output)</strong></p><ul><li>用于配置输出的打包目录和文件</li></ul><p><strong>多文件输出</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">    filename:&apos;[name].bundle.js&apos;  //多文件输出 结果是app.bundle.js/print:&apos;./src/pring.js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>loader</strong></p><ul><li>用于解析.css .sass .vue .xxx等类型文件</li></ul><p><strong>插件(plugins)</strong></p><pre><code>- HtmlWebpackPlugin 自动生成html模板</code></pre><h3 id="webpack执行步骤"><a href="#webpack执行步骤" class="headerlink" title="webpack执行步骤"></a>webpack执行步骤</h3><ul><li>考虑到通过cli这种方式运行本地的webpack不是特别方便,我们可以设置一个快捷方式,在package.json中添加一个npm脚本(npm script)</li><li>然后我们就可以npm run build 来自动帮我们自动执行webpack命令,并帮我们自动解析webpack_config文件,自动将入口设置目录下的文件设置为入口文件,并将它打包成bundle文件,输出到dist(输出层)</li></ul><h3 id="管理资源"><a href="#管理资源" class="headerlink" title="管理资源"></a>管理资源</h3><p><strong>加载CSS</strong></p><ul><li>需要在index.js文件中引入相关的css文件</li><li>注意:为了在js文件中import一个CSS文件,你需要在module配置中安装并添加style-loader和css-loader</li></ul><p><strong>加载图片</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. npm install --save-dev file-loader</span><br><span class="line">   &#123;</span><br><span class="line">     test: /\.(png|svg|jpg|gif)$/, .匹配除换行符 \n 之外的任何单字符。要匹配 .,请使用 \. </span><br><span class="line">    use: [</span><br><span class="line">       &apos;file-loader&apos;</span><br><span class="line">     ]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h3><ol><li>插件HtmlWebpackPlugin</li></ol><p><strong>应用场景以及作用</strong></p><ul><li>当我们更改了一个入口起点名字时,生成的包将被重命名在一个构建中,但是我们的html文件中仍然会引用旧的名字</li><li>虽然我们文件夹中已经有了index.html文件,但是HtmlWebpackPlugin还是会默认生成index.html文件,就是说它会生成新的index.html文件替换原来的</li></ul><ol start="2"><li>clean-webpack-plugin</li></ol><p><strong>应用场景以及作用</strong></p><ul><li>当没有它时,过去的指南和代码示例全部会遗留在文件夹中,会导致我们的/dist文件相当错乱,webpack每次构建都会将这些文件生成在.dist文件夹中,但是它无法判断到底哪些文件是实际在项目中用到的</li><li>它的作用就是在每次构建文件前,清理.dist文件夹,只会生成当前用到文件,可以减少代码冗余,精简代码</li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="1-source-map"><a href="#1-source-map" class="headerlink" title="1.source map"></a>1.source map</h4><p><strong>应用场景以及作用</strong></p><ul><li><p>webpack打包源代码时,会很难追踪到错误和警告在源代码中的原始位置,错误显示只会显示在已经打包的bundle文件中,如果有多个文件打包入bundle文件中,将很难查询到错误在源代码中的具体位置</p></li><li><p>它的作用就是帮助我们更容易的追踪错误和警告,将编译后的代码映射回原始源代码中</p></li><li>因此我们需要使用到devtool,并且我们推荐在开发环境中使用eval-source-map(因为在开发环境中,我们需要快速定位报错信息,方便我们的修改)</li><li>在生产环境中使用cheap-module-source-map(它可以帮我们压缩代码,减小代码占用的内存空间)</li></ul><h4 id="2-webpack-dev-server"><a href="#2-webpack-dev-server" class="headerlink" title="2.webpack-dev-server"></a>2.webpack-dev-server</h4><p><strong>应用场景</strong></p><ul><li>通常情况下,我们都希望我们修改的代码能够自动编译到出口文件中.而省去每次都需要使用npm run build.</li></ul><p><strong>作用</strong></p><ul><li>为你提供了一个简单的web服务器,并且能够实时重新加载(live reloding)</li><li>config中需要配置一下devServer属性<code>contentBase:&#39;./dist&#39;</code>,是说明在哪个目录下启动服务</li><li>同时在package.json中,需要加上<code>start:&#39;webpack-dev-server --open&#39;</code></li><li>注意:自动服务时,run可以默认不写</li></ul><h3 id="热替换模块-Hot-Module-Replacement"><a href="#热替换模块-Hot-Module-Replacement" class="headerlink" title="热替换模块(Hot Module Replacement)"></a>热替换模块(Hot Module Replacement)</h3><p><strong>应用场景</strong></p><ul><li>当我们更新文件中,我们总希望构建可以局部更新,而避免完全刷新</li></ul><p><strong>作用</strong></p><ul><li>它允许在运行时更新各种模块,而无需<strong>完全</strong>刷新.这样能更加高效的刷新页面.</li><li>首先我们需要在config文件中,引入webpack模块,同时在devServer中加入hot:true,注意:中文文档引入有问题,需参照英文文档</li></ul><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h3><ul><li>通常用于描述移除JavaScript上下文中的未引用代码</li><li>webpack4更新了这个功能,package.json 的 “sideEffects” 属性作为标记</li></ul><h3 id="生产环境构建"><a href="#生产环境构建" class="headerlink" title="生产环境构建"></a>生产环境构建</h3><ul><li>在生产环境中,我们更倾向于关注更小的bundle,更轻量的source map,以及更优化的资源,以改善加载时间,由于要遵循逻辑分离,我们通常建议为每个环境写一个彼此独立的webpack配置 </li><li>首先我们需要安装webpack-merge (帮我合并webpack代码)</li><li>这就要求我们配置三个webpack配置环境分别是common(共同的环境)product(开发环境)dev(生产环境)</li><li><p>common环境中一般保存有入口文件,输出文件,插件有清除目标,清除目标目录的插件,和一个自动生成html文件的插件</p></li><li><p>开发环境中,一般保存有共同的环境,和报错信息(devetol),实时预览(devServer)</p></li><li><p>生产环境中,一般保存有压缩输出.不需要报错信息和实时预览的功能,但是在4中已经变成了默认配置</p></li></ul><h3 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h3><p><strong>防止重复</strong></p><ul><li>CommonsChunkPlugin 插件可以将公众的依赖模块提取到已有的入口chunk中,或者提取到新生成的chunk中.</li><li>注意:在web4中使用<code>optimization:{splitChunks:all}</code>, CommonsChunkPlugin已经被弃用.</li><li>注意:使用   </li></ul><h3 id="webpack的划片有什么作用"><a href="#webpack的划片有什么作用" class="headerlink" title="webpack的划片有什么作用?"></a>webpack的划片有什么作用?</h3><ol><li>防止bundle文件过大</li><li>按需加载,只加载利用的js文件</li><li>提取公共模块,避免代码重复</li></ol><p><strong>缓存</strong></p><ul><li>浏览器是有缓存的,第一次打开很慢,第二次打开的时候因为上一次打开浏览器的有些文件已经被浏览器缓存了,当路径相同时,浏览器不会重新加载文件,而是会复用.这样的话,如果我们只修改图片的内容,但是图片的路径和图片名称不变,浏览器会默认请求已经缓存的图片,这样就会导致我们明明更新了代码但是页面图片并不会更新</li><li>webpack可以避免这种缓存带来的问题</li><li>我们需要在导出的时候<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">output:&#123;</span><br><span class="line">    filename:&apos;[name].[contenthash].js&apos; //[contenthash]只要内容发生了变化,就会生成一个新的hash值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;webpack知识总结&quot;&gt;&lt;a href=&quot;#webpack知识总结&quot; class=&quot;headerlink&quot; title=&quot;webpack知识总结&quot;&gt;&lt;/a&gt;webpack知识总结&lt;/h2&gt;&lt;h3 id=&quot;webpack简介&quot;&gt;&lt;a href=&quot;#webpack简
      
    
    </summary>
    
      <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>Vuex知识总结</title>
    <link href="http://yoursite.com/2019/04/26/vuex%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/26/vuex知识总结/</id>
    <published>2019-04-26T12:06:37.000Z</published>
    <updated>2019-04-28T06:08:09.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex知识总结"><a href="#Vuex知识总结" class="headerlink" title="Vuex知识总结"></a>Vuex知识总结</h2><h3 id="Vuex基本概念"><a href="#Vuex基本概念" class="headerlink" title="Vuex基本概念"></a>Vuex基本概念</h3><ul><li>Vuex是一个专门为vue.js应用程序开发的状态管理模式,它集中式存储管理应用的所有组件的状态,并以相应的规则保证状态以一种可预测的方式发生变化.</li></ul><h3 id="最简单的store"><a href="#最简单的store" class="headerlink" title="最简单的store"></a>最简单的store</h3><ul><li>每一个Vuex应用的核心就是store(仓库),’store’基本上就是一个容器,他包含这你应用中的大部分的状态(state).Vuex的单纯的全局对象有以下两点不同?</li></ul><ol><li>Vuex的状态存储是响应式的.当Vue组件从store中读取状态的时候,若store中的状态发生变化,那么相应的组件也会相应的得到高效更新</li><li>你不能直接改变store中的状态,改变store中的状态的唯一途径就是显存地提交(commit)mutation.这样使得我们可以方便地跟踪每一个状态的变化,从而让我们能够实现一些工具帮助我们更好地了解我们应用</li></ol><h3 id="Vuex的基本脚手架"><a href="#Vuex的基本脚手架" class="headerlink" title="Vuex的基本脚手架"></a>Vuex的基本脚手架</h3><p><strong>State</strong> </p><ul><li>用于保存需要共享的数据,不可直接修改</li><li>Vuex使用单一状态树,用一个对象就包含了全部的应用层级状态,至此它便作为’唯一数据源SSTO’,这也意味着,每个应用将仅仅包含一个store实例对象,单一状态数让我们能够直接地定位任意特定的状态片段,在调试的时候,也能轻易地取得整个当前应用的状态快照</li><li>官方文档这句话说的就是,一个Vuex只能包含一个store(存储数据的库),这样你在访问数据的时候好找些,store的其中一个配置就是state,和这个state,我们可以把它比作是vue实例的data选项,就是可以把数据放在里面.</li><li>获取数据可以使用<code>$this.store.state.xxx</code></li></ul><p><strong>Mutations</strong> </p><ul><li>更改Vuex中的store中状态的唯一方法就是提交mutation.</li><li>输入格式:$store.commit(‘xx’,n)</li><li>接收的第一个参数为state,对面参数可以接收值,也可以接收对象 </li><li>在组件里可以调用mutations中的方法,进而修改states中的值</li><li>注意:Mutation中的方法必须是同步函数 </li><li>注意:组件内部如果想要修改state中的属性,必须要发送一个commit请求,调用mutations中的方法</li></ul><p><strong>提交荷载(Payload)</strong></p><ul><li>你可以向store.commit传入额外的参数,即mutation的荷载(payload)</li><li>在Vuex中,mutation都是同步事务</li></ul><p><strong>Actions</strong> </p><ul><li>用于异步请求数据并调用mutations进而修改state</li><li>输入格式: $store.dispatch(xx,{n:xxx})</li><li>action类似于mutation,不同在于action提交的是mutation,而不是直接变更状态,action可以包含任意异步操作</li><li>action函数接收一个与store实例具有相同方法和属性的context对象,因此你可以调用context.commit提交一个mutation,或者通过context.state和context.getters来获取state和getters.当我们在之后介绍到Modules时,你就知道context对象为什么不是store实例本身. </li><li>actions方法里面传入一个上下文对象context,通过这个上下文对象来调用commit,执行mutations里面的方法.</li><li>注意:在组件里调用action里面的方法,使用的是dispatch</li><li>注意:actions虽然同样支持荷载模式和对象方式进行分发,但是第二个参数必须使用对象类型(也就是说在action中传递载荷的方式只能是对象类型)</li></ul><p><strong>getters</strong> </p><ul><li>当前Vuex的state对象中的属性的计算属性 </li><li>从字面上意思就可以看出,他是用来取数据,得到数据的</li><li>虽然我们可以使用state直接获取数据,但是经常会出现一些情况是对拿到的数据做一些处理,例如格式化,过滤数据,这时候就会用到getter</li><li>依赖于state对象中的属性,</li><li>输入格式:this.$store.getters.xxxx</li></ul><p><strong>Action</strong></p><ul><li>Action类似于mutation,不同在于:<ul><li>Action提交的是mutation,而不是直接变更状态</li><li>Action可以包含任意异步操作</li></ul></li><li>也就是说Action执行的还是Muation,只不过他可以异步执行,差不多就是给Muation外边包一层函数</li><li>我们前面已经了解了mutation中的数据必须同步执行,但是Action就不受约束,我们可以在aciton内部执行异步操作</li><li>另外通过this.$store.dispatch(‘xxx’)即可调用</li></ul><p><strong>Module</strong></p><ul><li>由于使用单一状态数,应用的所有状态会集中到一个比较大的对象,当应用变得非常复杂的时候,store对象就有可能变得相当臃肿.为了解决</li></ul><h3 id="Vuex的项目结构"><a href="#Vuex的项目结构" class="headerlink" title="Vuex的项目结构"></a>Vuex的项目结构</h3><blockquote><p>对于大型应用,我们希望把Vuex相关代码分割到代码块中,下面是项目结构示例;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">store</span><br><span class="line">    - index.js //我们组装模块并导出store的地方</span><br><span class="line">    - actions // 根级别的actions</span><br><span class="line">    - mutations //根据别的mutation</span><br><span class="line">    - modules</span><br><span class="line">        - cart.js //购物车组件</span><br><span class="line">        - product.js 产品模块</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="分模块发送commit"><a href="#分模块发送commit" class="headerlink" title="分模块发送commit"></a>分模块发送commit</h3><ul><li>在分模块下发送commit调用mutaions中的方法,必须使用commit(‘cart/insCount); 通过模块名加上方法来修饰来发送这个mutaions,从而调用mutation中的方法.</li><li>注意: 前提是必须加上命名空间,否则会报错,给每个需要调用commit方法的模块,加上命名空间(name),</li></ul><h3 id="跨模块获取信息"><a href="#跨模块获取信息" class="headerlink" title="跨模块获取信息"></a>跨模块获取信息</h3><ul><li>buyListInfo(state,getters,rootStates,rootGetters)</li><li>遍历并修改每一个元素,并用每一个元素的id从跨模块的对象中获取明细?</li></ul><p><strong>难点:如何比配?</strong>  </p><ul><li>rootStates根节点,</li><li>map()通过使用map遍历方法修改每一个元素,并用每一个元素的id从product里获取明细</li><li>通过rootStates根节点找到product.all中所有元素节点,并调用find方法找出id相同的一项</li><li>然后把item和product合并为一个对象 Object.assign({},product,item) item会覆盖product相同的属性</li><li>注意:这里需要将item放在后面,这样才可以将product中相同的属性(如商品的数量, item为购买的数量,product为库存的数量)</li></ul><h3 id="调用其他模块的mutaions"><a href="#调用其他模块的mutaions" class="headerlink" title="调用其他模块的mutaions"></a>调用其他模块的mutaions</h3><p><strong>业务需求:</strong></p><ul><li>通过在actions定义一个异步请求(可以同时调用两个模块的mutations),可以调用自己的mutations方法,并且还可以调用其他模块的mutations方法</li></ul><p><strong>注意几个点</strong></p><ul><li>content可以解构为{state,commit…. }</li><li>action中更新库存,方便调用其他模块的mutations({dispatch,commit,getters,rootGetters},obj){</li><li>commit(‘其他模块’/mutation方法),obj.id,{root:true} } 也就是说调用cart/addTocart 传递obj.id的负载对象 调用的是根节点的方法,在调用其他模块中的mutations时,可以传入一个对象,也就是context可以解构成dispatch,commit,getters,rootGetters,还需要传入一个id</li></ul><h3 id="购物车难点解析"><a href="#购物车难点解析" class="headerlink" title="购物车难点解析"></a>购物车难点解析</h3><p><strong>业务需要一:如何将api中的数据获取并存入到哪里,可以实现多个模块共享</strong> </p><ul><li>通过actions异步请求数据,并将请求到的数据通过调用mutations中的方法存入到state中,记住:必须将数据放在store中,因为只有放入store中才能实现商品列表和购物车数据实现双向通信</li><li>注意:actions异步操作需要传入一个context上下文对象,通过commit调用mutation方法,传入获取到的数据,最后存入state中.</li></ul><p><strong>业务需求二:如何在组件中调用模块中的方法,从而将模块中请求到数据呈现在视图层</strong></p><ol><li>因为模块中通过异步请求获取数据,所有我们在组件中需要通过dispatch来调用模块中异步请求数据的方法,来获取数据,异步请求数据调用mutations中的方法,最后将数据存入到store中,</li><li>注意:因为我们希望在页面刷新时就获取到数据,所以我们需要将方法初始化时调用</li><li>最后,官方也建议我们通过计算属性的时候获取到模块中state中的数据</li></ol><p><strong>业务需求三:如何在购物车中添加对应的商品id和数量</strong></p><ul><li>在商品列表中点击按钮,商品库存减一,并且将商品的id和数量添加到购物车中,需要在购物车中添加到购物车的方法()</li><li>思路: 在点击商品列表对应的按钮时,需要调用购物车添加的方法,并且需要将对应的id传递过去</li></ul><ol><li>购物车中需要添加方法,state中首先创建一个数组,用来保存对应的id和数量的.</li><li>product中调用购物车模块中mutation的方法,利用find()方法,判断购物车中存不存在当前id,如果存在count+1,如果不存在,将id和count=1push到数组中.<br><strong>同时商品列表库存需要减少</strong></li></ol><ul><li>同样可以使用find()方法,判断当点击的这个id等于当前id的时候,就将对应商品库存减少</li></ul><p><strong>业务需要四:购物车按钮还应该有一个点击按钮点击以后购物车对应的商品数量减一,当数量小于等于1的时候,这个商品将会被删除</strong></p><ol><li>首先应该理解,购物车中商品的id来自于商品详情中传入的id,也就是在添加购物车对应的商品的时候传入的商品id,</li><li>购物车逻辑,当商品大于1时count–,否则移除商品,可以使用for循环遍历,存在购物车中的商品id,当点击商品对应的id等于商品列表中的某一个id是,获取当前商品的下标.</li><li>如果存在这个下标,如果这个下标大于1,则商品数量–</li><li>否则将在购物车中移除这个商品</li></ol><p><strong>业务逻辑五:我们需要知道买的是什么商品,光知道商品id来不够,通常我们还需要知道商品的明细,但是将所有属性扔给购物车又不合理</strong></p><ul><li>我们可以使用getters用来跨模块获取信息</li><li>通过getters 中的rootState就可以获取到product中的元素,遍历并修改每一个元素,并用每一个元素的id从product里获取明细,</li><li>我们需要用到getters中的state和rootState属性.rootState是根节点<br><strong>难点一</strong></li><li>使用map()方法可以遍历每一个元素,并修改</li><li>find()返回第一个于条件匹配的元素</li><li>我们可以使用map()方法遍历购物车中的数据,并配合find方法在商品详情中寻找id相同的数据(如何获取product上面已经说明了);</li><li>找到相同的id的数据,这时我们可以将商品详情和购物车合并;注意:我们需要将合并的商品详情放在前面,购物情况放在后面合并,</li><li>在购物车组件中调用这个getters方法 注意:调用getters方法需要使用[]形式,因为存在命名空间,需要哪个模块下的哪个方法</li><li>最后返回的是合并后的结果</li></ul><p><strong>业务逻辑六:更新库存</strong></p><ul><li>更新库存,如果想调用其他模块的mutations,例如这里就需要调用购物车中的cartToAdd</li><li>注意:在actions中传递的第二个参数,必须是对象类型的值,在action中调用commit,并且把obj传递过去,负载对象调用的是根节点的方法</li><li>调用别的模块commit 需要{root:true},同时还修改自己.调用自己的commit.</li><li>注意:在商品列表组件中分别调用两个模块的方法,可以使用anctions中的异步请求.</li><li>调用别的模块的方法 需要传递{root:true}</li></ul><p><strong>业务逻辑七:还原商品列表的库存</strong> </p><ul><li>就需要在购物车中调用商品详情中的方法,actions同时将购物车中获取到对应id的商品添加到商品详情中 跨模块调用方法传递</li><li>在product中设置一个还原库存的方法,遍历添加进购物车中的商品,并且遍历商品详情的id,当两个id相同时,将购物车中的数量加入对应商品列表的count,然后返回当前商品列表的对象</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vuex知识总结&quot;&gt;&lt;a href=&quot;#Vuex知识总结&quot; class=&quot;headerlink&quot; title=&quot;Vuex知识总结&quot;&gt;&lt;/a&gt;Vuex知识总结&lt;/h2&gt;&lt;h3 id=&quot;Vuex基本概念&quot;&gt;&lt;a href=&quot;#Vuex基本概念&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Vuex" scheme="http://yoursite.com/categories/Vuex/"/>
    
    
      <category term="Vue.js" scheme="http://yoursite.com/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>vue导航守卫</title>
    <link href="http://yoursite.com/2019/04/26/vue%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"/>
    <id>http://yoursite.com/2019/04/26/vue导航守卫/</id>
    <published>2019-04-26T00:54:35.000Z</published>
    <updated>2019-04-26T05:26:57.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue导航守卫"><a href="#Vue导航守卫" class="headerlink" title="Vue导航守卫"></a>Vue导航守卫</h2><h3 id="导航守卫详解"><a href="#导航守卫详解" class="headerlink" title="导航守卫详解"></a>导航守卫详解</h3><blockquote><p>正如其名,vue-router导航守卫主要是用来通过跳转或取消的方式守卫导航.有多种机会植入导航过程中:</p><ul><li>全局导航守卫(beforeEach,affterEach,beforeResolve),单个路由独享的(beforeEnter),或者组件级的(beforeRouteEnter,beforeRouteUpdate,beforeRouteLeave)</li></ul></blockquote><h3 id="全局守卫"><a href="#全局守卫" class="headerlink" title="全局守卫"></a>全局守卫</h3><blockquote><p>全局守卫,就是导航触发时的前后执行相关逻辑,可为全局前置守卫(导航发生跳转之前beforeEach),全局后置守卫(导航发生跳转之后affterEach)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// 全局前置导航守卫router,为v-router实例化对象</span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123; //to :去哪里 from:从哪里来,next(验证信息,回调函数一定要执行)</span><br><span class="line">console.log(to)</span><br><span class="line">console.log(from)</span><br><span class="line">if(to.name==&apos;router&apos;)&#123;//全局拦截,如果跳转到指定路由router1的话,使其不能跳转或相关逻辑</span><br><span class="line">next(false);</span><br><span class="line">return;</span><br><span class="line">&#125;else&#123;</span><br><span class="line"> next();</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//全局后置导航守卫</span><br><span class="line">router.afterEach((to,from)=&gt;&#123;</span><br><span class="line">    console.log(to);</span><br><span class="line">    console.log(from);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//路由独享的守卫</span><br><span class="line">在路由规则配置beforeEnter,当路由进入相关配置路由,会触发相关逻辑</span><br><span class="line">routes:[</span><br><span class="line">    &#123;</span><br><span class="line">        path:&apos;/&apos;,</span><br><span class="line">        name: &apos;home&apos;,</span><br><span class="line">        component:home,</span><br><span class="line">        beforeEnter:(to,form,next)=&gt;&#123;</span><br><span class="line">            console.log(to);</span><br><span class="line">            console.log(from);</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">//组件内的守卫</span><br><span class="line">就是将路由变化入口写在组件内部</span><br><span class="line"></span><br><span class="line">export default&#123;</span><br><span class="line">    name: &apos;router1&apos;,</span><br><span class="line">    data()&#123;</span><br><span class="line">        return()&#123;</span><br><span class="line">            str: &apos;hello&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouterEnter(to,from,next)&#123;</span><br><span class="line">        console.log(to);</span><br><span class="line">        console.log(from);</span><br><span class="line">        console.log(this) //undefined;</span><br><span class="line">        //在渲染该组件对应的路由被confirm前调用</span><br><span class="line">        //不能获取组件实例this</span><br><span class="line">        //因为当守卫执行前,组件实例还没有被创建</span><br><span class="line">        next();</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeRouteUpdate(to,from,next)&#123;</span><br><span class="line">        //在当前路由改变,但是该组件被复用时调用 </span><br><span class="line">        //举个列子来说,对于一个有动态参数的路径/foo/:id  在/foo/1和/foo/2之间跳转的时候,</span><br><span class="line">        由于会渲染同样的foo组件,因此组件实例会被复用,而这个钩子就会在这种情况下被复用</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beforeRouterLeave(to,from,next)&#123;</span><br><span class="line">        console.log(to);</span><br><span class="line">        console.log(from);</span><br><span class="line">        //导航离开该组件的对应时被调用,</span><br><span class="line">        //可以访问组件实例 &apos;this&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由元信息"><a href="#路由元信息" class="headerlink" title="路由元信息"></a>路由元信息</h3><blockquote><p>定义一个路由的时候可以设置meta字段,可以存储该路由相关信息(例如:设置每个路由的title,取路由的title设置为选项卡的标题)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:&apos;/router2&apos;,</span><br><span class="line">    name:&apos;router2&apos;,</span><br><span class="line">    component: &apos;router2&apos;,</span><br><span class="line">    meta:&#123;</span><br><span class="line">        title:&apos;router2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 全局前置守卫</span><br><span class="line">router.beforeEach((to,from,next)=&gt;&#123;</span><br><span class="line">    console.log(to);</span><br><span class="line">    console.log(from);</span><br><span class="line">    if(to.meta.title)&#123;</span><br><span class="line">        document.title = to.meta.title;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        document.title= &apos;我是默认的title&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>总结: </li><li>每个守卫接收三个参数</li><li>to:Route即将要进入的目标路由对象</li><li>from:Route当前导航正要离开的路由</li><li>next:function;一定要调用这个方法来resolve,执行效果依赖next方法的调用参数.<ul><li>next():进行管道中的下一个钩子.如果全部钩子执行完了,则导航状态就是comfirmed(确认的)</li><li>next(false):中断当前导航.如果浏览器的URL改变了(可能是用户手动或者浏览器后退按钮),那么URL地址会重置到from路由对应的地址</li><li>next(‘/‘)或者next({path:’/‘}); 跳转到一个不同的地址,当前的导航被中断,然后进行一个新的导航.你可以向next传递任意位置对象,且允许设置诸如:replace:true, name:’home’,之类的选项,以及任何用在router-link的to,prop或router.push中的选项</li></ul></li></ul><h3 id="vue-router路由元信息meta"><a href="#vue-router路由元信息meta" class="headerlink" title="vue-router路由元信息meta"></a>vue-router路由元信息meta</h3><ul><li>当产生判断当前路由是否允许登录,是否需要身份验证,权限认证等,虽然可以采用路由匹配的方式if(to.path==’/url’),很显然当需要验证的路由较多时,会增加太多的if判断,这不利于代码的维护,此时可在定义路由的时候可以配置meta字段,通过设置一些属性值,可以便于我们对当前路由做一些处理,也可以使用next()重定到其他路由</li><li>使用,在定义路由时,定义一个需要验证的meta信息:meta{requiresAuth:true}</li><li>meta字段就是路由元信息字段,requireAuth时自己起的字段名字,用来标记这个路由信息是否需要检测,true表示要检测.</li><li>注意:路由是可以嵌套的,因此,当一个路由匹配成功后,他可能匹配多个路由记录,例如,根据下面的路由配置,/foo/bar这个URL将会匹配到父路由的记录,以及子路由记录</li></ul><ol><li>路由器中routes配置中的每个路由对象为路由记录</li><li>路由记录可以嵌套,所以当一个路由匹配成功后,可能同时需要匹配多个路由记录</li><li>商品:/product</li><li>商品列表:/product/productList</li><li>商品详情:/product/productList/detail/:id</li><li>当匹配到商品详情的时候,同时也会匹配到商品和商品列表</li><li>$route对象中的$route.matched数组记录路由匹配到的所有路由记录</li><li>因此可以通过遍历$route.matched数组检查路由记录中的meta字段</li></ol><h3 id="路由元信息的应用"><a href="#路由元信息的应用" class="headerlink" title="路由元信息的应用"></a>路由元信息的应用</h3><p><strong>需求</strong></p><ol><li>通过上面的分析可以做出一个需求,当导航切换时</li><li>如果页面需要授权才能访问,判断是否授权,若未授权跳转至登录页面</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Vue导航守卫&quot;&gt;&lt;a href=&quot;#Vue导航守卫&quot; class=&quot;headerlink&quot; title=&quot;Vue导航守卫&quot;&gt;&lt;/a&gt;Vue导航守卫&lt;/h2&gt;&lt;h3 id=&quot;导航守卫详解&quot;&gt;&lt;a href=&quot;#导航守卫详解&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="vue基础" scheme="http://yoursite.com/categories/vue%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="导航守卫" scheme="http://yoursite.com/tags/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/"/>
    
  </entry>
  
  <entry>
    <title>前端面试总结之JS篇</title>
    <link href="http://yoursite.com/2019/04/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8BJS%E7%AF%87/"/>
    <id>http://yoursite.com/2019/04/21/前端面试总结之JS篇/</id>
    <published>2019-04-21T03:04:20.000Z</published>
    <updated>2019-05-24T15:09:58.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javaScript"><a href="#javaScript" class="headerlink" title="$javaScript"></a>$javaScript</h2><p>###节点</p><p><strong>节点是什么?</strong></p><ul><li>文档是由节点构成的集合,只不过此时的节点是文档树上的树枝和树叶而已</li><li>常见的节点类型<ul><li>元素节点,根元素节点为html最外层节点,诸如body,head,p这些元素</li><li>文本节点,文本节点总是包含在元素节点内部</li><li>属性节点,用来对元素做出更具体描述,属性节点都是被包含在元素节点中,并非所有元素都包含着属性,但是所有属性都被元素包含</li></ul></li></ul><h3 id="常见的DOM操作有哪些"><a href="#常见的DOM操作有哪些" class="headerlink" title="常见的DOM操作有哪些?"></a>常见的DOM操作有哪些?</h3><ol><li><p>通过使用 getElementById() 方法匹配元素的id属性来访问元素节点，对元素节点进行操作</p></li><li><p>通过使用 getElementsByTagName() 方法匹配元素的tagName来访问元素节点，对元素节点进行操作</p></li><li><p>通过使用 getElementsByClassName() 方法匹配元素的className来访问元素节点，对元素节点进行操作</p></li><li><p>需要注意的一点是后两种方法因为其访问的节点中的可能为复数的属性,所以会得到一个数组形式来体现出来的元素节点的集合,我们可以通过打印获取dom节点来判断类型</p></li></ol><p>###常见的DOM事件</p><ul><li>onclick事件 –当用户点击时执行</li><li>onload事件 –当用户进入时执行</li><li>onunload事件 –当用户离开时执行</li><li>onmouseover –当鼠标指针移入时执行</li><li>onmouseout –当鼠标指针离开时执行</li><li>onmousedown –当鼠标摁下时执行</li><li>onmouseup –当鼠标</li></ul><p><strong>dom操作是同步还是异步的?</strong></p><ul><li>dom操作其实是同步的,但是渲染时异步的,因为javascript引擎线程跟gui渲染引擎线程是互斥的</li></ul><p><strong>性能考虑</strong></p><ol><li>尽量减少访问DOM和尽量减少标记 访问DOM节点对脚本性能会产生很大影响,例如当我们访问所有div中其中某一个节点时,我们不知道有多少个div元素面对我们,所以浏览器会搜索整个DOM树,从中查找可能匹配的元素</li><li>另一个是减少文档中的标记数量,过多不必要的元素只会增加DOM树的规模,进而增加遍历DOM树以查找特定元素的时间</li><li><p>合并和放置脚本 我们需要通过合并文件来减少加载页面时发送请求的数量,减少请求数量通常是性能优化最先考虑的.放置脚本,引入的js文件,我们通常将在放在文档的最下面,因为浏览器解析到src属性,就会暂停其他的资源的下载和处理,直到将该资源加载,编译,执行完毕.</p></li><li><p>压缩脚本,通过将脚本中不必要的字符统统删除,比如空格注释等,从而达到压缩脚本的目的</p></li></ol><h3 id="1-闭包"><a href="#1-闭包" class="headerlink" title="1.闭包"></a>1.闭包</h3><ul><li>闭包就是能够读取其他函数内部变量的函数</li><li>闭包就是有权访问另一个函数作用域中变量的函数,创建闭包最常见的方式就是在一个函数内创建另一个函数,通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用域链</li></ul><p><strong>闭包的特性</strong></p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外部函数的参数与变量</li><li>参数与变量不会被垃圾回收器回收</li></ul><p><strong>谈谈你对闭包的理解</strong></p><ul><li><p>我认为使用闭包主要为了设计私有的方法和变量.闭包的优点是可以避免全局变量被污染,缺点是闭包会常驻内存,增大内存的使用量,使用不当容易造成内存泄漏,在js中,函数即闭包,只有在函数中才能产生作用域的概念</p></li><li><p>闭包的最大用处有两个,一个是可以读取函数内部的变量,另一个就是让这些变量始终保存在内存中</p></li><li>闭包的另一个用处,是封装对象的私有属性和私有方法.</li></ul><p><strong>闭包的总结</strong></p><ul><li>好处:能够实现封装和缓存等</li><li>坏处:就是消耗内存,使用不当会造成内存泄漏</li><li>解决办法是,在退出函数之前,将不使用的局部变量全部删除</li></ul><h3 id="2-谈谈你对作用域链的理解"><a href="#2-谈谈你对作用域链的理解" class="headerlink" title="2.谈谈你对作用域链的理解"></a>2.谈谈你对作用域链的理解</h3><ul><li>全局作用域和局部作用域中变量的访问权限,其实是由作用域链决定的</li><li>每次进入一个新的执行环境,都会创建一个用于搜索变量和函数的作用域链.作用域链是函数被创建的作用域中<strong>对象</strong>的集合.作用域链可以保证对执行环境有权访问的变量和函数有序访问</li><li>作用域链最前端始终是当前执行代码所在环境的变量对象(如果该环境是函数,则将其活动对象作为变量对象),下一变量对象来自包含环境(包含当前还运行环境的环境),下一个变量对象来自包含环境的包含环境，依次往上，直到全局执行环境的变量对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。</li></ul><p><strong>总结:</strong>作用域链的变量只能向上访问,变量访问到全局作用域(也就是window对象)即停止访问,作用域链向下访问是不被允许的,简单来说作用域就是变量与函数的可访问范围,即作用域控制这变量与函数的可见性和生命周期]</p><h3 id="3-JavaScript原型-原型链-有什么特点"><a href="#3-JavaScript原型-原型链-有什么特点" class="headerlink" title="3.JavaScript原型,原型链?有什么特点?"></a>3.JavaScript原型,原型链?有什么特点?</h3><ul><li>每个对象都会在其内部初始化一个属性,就是prototype(原型)当我们访问一个对象的属性时,如果这个对象不存在这个属性,那么他就会去prototype里找这个属性,这个prototype会有自己的prototype,于是就这样一直找下去,也就是我们平时所说的原型链的概念</li><li>javascript对象是通过引用来传递的,我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时,与之相关的对象也会继承这一改变.</li><li>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性,如果没有的就会查找他的Prototype对象是否有这个属性，如此递推下去,一直检索到 Object 内建对象.</li></ul><h3 id="4-请解释什么是事件代理"><a href="#4-请解释什么是事件代理" class="headerlink" title="4.请解释什么是事件代理?"></a>4.请解释什么是事件代理?</h3><ul><li>事件代理(Event Delegation),又称为事件委托.是javascript中常用的绑定事件常用的技巧.顾名思义:’事件代理’即将原本需要绑定的事件委托给父元素,让父元素担当事件监听的职务.事件代理的原理是DOM元素事件冒泡.使用事件代理的好处可以提供性能</li><li>可以大量节省内存,减少事件注册,比如在table上代理所有td的click事件</li><li>可以实现新增子对象时无需再次对其绑定</li></ul><h3 id="5-谈谈你对this的理解"><a href="#5-谈谈你对this的理解" class="headerlink" title="5.谈谈你对this的理解"></a>5.谈谈你对this的理解</h3><ul><li>this总是指向函数的直接调用者(而非间接调用者)</li><li>如果有new关键字,this指向new出来的这个对象</li><li>在事件中,this指向触发这个事件的对象</li></ul><h3 id="6-事件模型"><a href="#6-事件模型" class="headerlink" title="6.事件模型"></a>6.事件模型</h3><ul><li>W3C中定义了事件发生的三个阶段:捕获阶段(capturing),目标阶段(targetin),冒泡阶段(bubbling)</li><li>冒泡型事件:当你使用事件冒泡时,子级元素先触发,父级元素后触发</li><li>捕获型事件:当你使用事件捕获时,父级元素先触发,子级元素后触发</li><li>DOM事件流:同时支持两种事件模型:捕获事件和冒泡事件</li></ul><h3 id="7-new操作符具体干了什么"><a href="#7-new操作符具体干了什么" class="headerlink" title="7.new操作符具体干了什么?"></a>7.new操作符具体干了什么?</h3><ul><li>创建一个空对象</li><li>将构造函数的作用域赋给新对象,因此this就指向了这个新对象</li><li>属性和方法被加入到this引用的对象中</li><li>返回新对象</li></ul><h3 id="8-Ajax原理"><a href="#8-Ajax原理" class="headerlink" title="8.Ajax原理"></a>8.Ajax原理</h3><ul><li>Ajax的原理简单来说就是在用户和服务器之间加了一个中间层(AJax引擎),通过XmlhttpRequest对象来向服务器发送异步请求,从服务器获取数据,然后用javascript来操作DOM更新页面,使用户操作与服务器响应异步化,这其中最关键的一步就是从服务器获得请求数据</li><li>Ajax的过程只涉及Javascript,XmlHttpRequest和DOM.XmlhttpRequest是ajax的核心机制</li></ul><p><strong>优点</strong></p><ul><li>通过异步模式,提升了用户体验</li><li>优化了浏览器和服务器之间的传输,减少不必要的数据往返,减少了带宽占用</li><li>Ajax在客户端运行,减少了一部分本来在浏览器承担的工作,减少了大用户量下的服务器负载</li><li>Ajax可以实现动态不刷新(局部刷新)</li></ul><p><strong>缺点</strong></p><ul><li>安全问题Ajax暴露了与服务器交互的细节</li><li>对搜索引擎的支持比较弱,不利用seo优化</li><li>不容易调试</li></ul><h3 id="9-谈谈你对Webpack的看法"><a href="#9-谈谈你对Webpack的看法" class="headerlink" title="9.谈谈你对Webpack的看法"></a>9.谈谈你对Webpack的看法</h3><ul><li>WebPack是一个模块打包工具,你可以使用WebPack管理你的模块依赖,并编译输出模块们所需要的静态文件.它能够很好的管理,打包web开发中所用到的HTML,Javascript,CSS以及各种静态文件(图片,字体)等,让开发更加高效.对于不同类型的资源,webpack有对应的模块加载器,web模块加载器会分析模块之间的依赖关系,最后生成优化并且合并后的静态资源</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;javaScript&quot;&gt;&lt;a href=&quot;#javaScript&quot; class=&quot;headerlink&quot; title=&quot;$javaScript&quot;&gt;&lt;/a&gt;$javaScript&lt;/h2&gt;&lt;p&gt;###节点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点是什么?&lt;/strong&gt;
      
    
    </summary>
    
      <category term="前端面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端面试总结之CSS篇</title>
    <link href="http://yoursite.com/2019/04/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B9%8BCSS%E7%AF%87/"/>
    <id>http://yoursite.com/2019/04/20/前端面试总结之CSS篇/</id>
    <published>2019-04-20T14:40:05.000Z</published>
    <updated>2019-04-29T00:55:55.620Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><h3 id="1-CSS-Sprite是什么-有什么优缺点"><a href="#1-CSS-Sprite是什么-有什么优缺点" class="headerlink" title="1.CSS Sprite是什么?有什么优缺点?"></a>1.CSS Sprite是什么?有什么优缺点?</h3><ul><li>概念: 精灵图片将多个小图片拼接到一个图片中,通过background-postion和元素尺寸调节需要显示的背景图案</li></ul><p><strong>优点</strong></p><ul><li>减少了http请求,极大地提高了页面的加载速度</li><li>增加了图片的信息重复度,提高压缩比,减少了图片大小</li><li>更换风格方便,只需要在一张或几张图片上修改颜色或者样式即可实现</li></ul><p><strong>缺点</strong></p><ul><li>图片合并麻烦</li><li>维护麻烦,修改一个图片可能需要从新布局整个图片,样式.</li></ul><h3 id="2、display-none-与visibility-hidden-的区别"><a href="#2、display-none-与visibility-hidden-的区别" class="headerlink" title="2、display: none;与visibility: hidden;的区别"></a>2、display: none;与visibility: hidden;的区别</h3><ul><li>联系：它们都能让元素不可见</li><li>区别：</li><li>display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li><li>display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式</li><li>修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。</li><li>读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容</li></ul><h3 id="3-link和-import的区别"><a href="#3-link和-import的区别" class="headerlink" title="3.link和@import的区别"></a>3.link和@import的区别</h3><ul><li>link是html方式,@import是CSS方式</li><li>link最大限度支持并行下载,@import过多嵌套会导致串行下载,出现fouc</li><li>link可以通过rel=”alternate stylesheet”指定候选样式</li><li>浏览器对link支持早于@import，可以使用@import对老浏览器隐藏样式</li><li>@import必须在样式规则之前,可以在CSS文件中引用其他文件</li><li>总结来说: link优于@import</li></ul><h3 id="4-什么是Fouc-如何避免"><a href="#4-什么是Fouc-如何避免" class="headerlink" title="4.什么是Fouc?如何避免?"></a>4.什么是Fouc?如何避免?</h3><ul><li>Flash of Ustyled Content: 用户定义样式表加载之前浏览器使用默认样式显示文档,用户样式加载渲染之后再重新显示文档,造成页面闪烁;</li><li><strong>解决办法</strong>:把样式表放到文档的head</li></ul><h3 id="5-清除浮动的几种方式，各自的优缺点"><a href="#5-清除浮动的几种方式，各自的优缺点" class="headerlink" title="5.清除浮动的几种方式，各自的优缺点"></a>5.清除浮动的几种方式，各自的优缺点</h3><ul><li>父级定义height</li><li>结尾处加空div标签:clear:both</li><li>父级div定义伪类:after和zoom</li><li>父级div定义overflow:hidden;</li><li>父级也浮动:需要定义宽度</li><li>结尾处加br标签clear:both</li></ul><h3 id="6-为什么要初始化CSS样式"><a href="#6-为什么要初始化CSS样式" class="headerlink" title="6.为什么要初始化CSS样式?"></a>6.为什么要初始化CSS样式?</h3><ul><li>为什么浏览器的兼容问题,不同浏览器对有些标签的默认是不同的,如果没有对CSS进行初始化往往会出现浏览器之间的页面显示差异</li><li>当然,初始化样式会对SEO有一定的影响,但是鱼和熊掌不可兼得,但是力求在影响最小的情况下进行初始化</li></ul><h3 id="7-CSS3有哪些新特性"><a href="#7-CSS3有哪些新特性" class="headerlink" title="7.CSS3有哪些新特性?"></a>7.CSS3有哪些新特性?</h3><ul><li>新增各种css选择器</li><li>圆角border-radius</li><li>多列布局</li><li>阴影和反射</li><li>文字特效 text-shadow</li><li>线性渐变</li><li>旋转 transform</li></ul><h3 id="8-CSS3新增的伪类有哪些"><a href="#8-CSS3新增的伪类有哪些" class="headerlink" title="8.CSS3新增的伪类有哪些?"></a>8.CSS3新增的伪类有哪些?</h3><ul><li>p:first-of-type 选择属于其父元素的首个p元素的每一个p元素</li><li>p:last-of-type 选择属于其父元素的最后p元素的每个p元素 </li><li>p:only-of-type 选择属于其父元素唯一的p元素的每个p元素</li><li>p:only-child  选择属于其父元素的唯一子元素的每个p元素</li><li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个p元素</li><li>:after在元素之前添加内容,也可以用来清除浮动</li><li>:before在元素之后添加内容</li><li>:enabled</li><li>:disabled 控件表单控件的禁用状态</li><li>:checked单选框或复选框被选中</li></ul><h3 id="9-display有哪些值-说明他的作用"><a href="#9-display有哪些值-说明他的作用" class="headerlink" title="9.display有哪些值 说明他的作用"></a>9.display有哪些值 说明他的作用</h3><ul><li>block 转化成块状元素</li><li>none: 像行内元素那样显示</li><li>inline-block 像行内元素一样显示,但是其内容像块类型元素一样显示</li><li>list-item 像块级元素一样显示,并添加样式列表标记</li><li>table 此元素会作为块级表格来显示</li><li>inherit 规定应该从父元素继承 display 属性的值</li></ul><h3 id="10-介绍一下标准的CSS盒子模型-低版本IE的盒子模型有什么不同"><a href="#10-介绍一下标准的CSS盒子模型-低版本IE的盒子模型有什么不同" class="headerlink" title="10.介绍一下标准的CSS盒子模型?低版本IE的盒子模型有什么不同?"></a>10.介绍一下标准的CSS盒子模型?低版本IE的盒子模型有什么不同?</h3><ul><li>有两种,IE盒子模型,W3C盒子模型</li><li>盒模型:内容(content),填充(padding),边界(margin),边框(border)</li><li>区别: IE的content把padding和border计算进去了</li></ul><h3 id="11-CSS优先级算法如何计算"><a href="#11-CSS优先级算法如何计算" class="headerlink" title="11.CSS优先级算法如何计算?"></a>11.CSS优先级算法如何计算?</h3><ul><li>优先就近原则,同权重情况下样式定义最近者为准.</li><li>载入样式以最后载入的定位为准</li><li>优先级:!important &gt; id &gt; class&gt; tag &gt;important比内联优先级高!!!</li></ul><h3 id="12-谈谈浮动和清除浮动"><a href="#12-谈谈浮动和清除浮动" class="headerlink" title="12.谈谈浮动和清除浮动"></a>12.谈谈浮动和清除浮动</h3><ul><li>浮动的框可以向左向右浮动,直到他的外边缘碰到包含框或者另一个浮动框为止.由于浮动框不在普通文档流中,所以文档中的普通的快框表现得就像浮动框不存在一样.浮动框会漂浮在文档普通流的快框上.</li></ul><h3 id="13-position的值-relative和absolute定位原点是"><a href="#13-position的值-relative和absolute定位原点是" class="headerlink" title="13.position的值,relative和absolute定位原点是"></a>13.position的值,relative和absolute定位原点是</h3><ul><li>absolute:生成绝对定位的元素,相对于static定位以外的第一个父元素进行定位</li><li>fixed:生成固定定位的元素,相对于浏览器窗口进行定位</li><li>relative:生成相对定位的元素,相对于其正常位置进行定位</li><li>static:默认值,没有定位,元素出现在正常的文档流中</li><li>inherit:规定从父元素继承position的值</li></ul><h3 id="14-PNG-JPG-GIF的区别及如何选择"><a href="#14-PNG-JPG-GIF的区别及如何选择" class="headerlink" title="14.PNG,JPG,GIF的区别及如何选择"></a>14.PNG,JPG,GIF的区别及如何选择</h3><ul><li><p>GIF</p><ul><li>8位像素,256色</li><li>无损压缩</li><li>支持简单动画</li><li>支持boolean透明</li><li>适合简单动画</li></ul></li><li><p>JPEG</p><ul><li>颜色限于256</li><li>有损压缩</li><li>可控制压缩质量</li><li>不支持透明</li><li>适合照片</li></ul></li><li><p>PNG</p><ul><li>适合图标,背景,按钮</li></ul></li></ul><h3 id="15-行内元素float-left后是否变为块级元素"><a href="#15-行内元素float-left后是否变为块级元素" class="headerlink" title="15.行内元素float:left后是否变为块级元素"></a>15.行内元素float:left后是否变为块级元素</h3><ul><li>浮动后,行内元素不会变成块级元素,但是浮动元素可以设置宽高,行内元素如果想变成块级元素可以设置display:block,但是如果浮动以后设置,那么就不会独占一行</li></ul><h3 id="16-在网页应该使用奇数还是偶数字体-为什么"><a href="#16-在网页应该使用奇数还是偶数字体-为什么" class="headerlink" title="16.在网页应该使用奇数还是偶数字体?为什么?"></a>16.在网页应该使用奇数还是偶数字体?为什么?</h3><ul><li>偶数字体相对来说更容易和Web设计的其他部分构成比例</li></ul><h3 id="17-before和-after中双冒号和单冒号-有什么区别-解释一下这两个伪元素的作用"><a href="#17-before和-after中双冒号和单冒号-有什么区别-解释一下这两个伪元素的作用" class="headerlink" title="17.::before和:after中双冒号和单冒号 有什么区别?解释一下这两个伪元素的作用"></a>17.::before和:after中双冒号和单冒号 有什么区别?解释一下这两个伪元素的作用</h3><ul><li>单冒号(:)用于css3伪类,双冒号用于(::)css3伪元素</li><li>用于区分伪类和伪元素</li></ul><h3 id="18-列出你所知道的可以改变页面布局的属性"><a href="#18-列出你所知道的可以改变页面布局的属性" class="headerlink" title="18.列出你所知道的可以改变页面布局的属性"></a>18.列出你所知道的可以改变页面布局的属性</h3><ul><li>position,display,margin,padding,border,width,height,top,left,right</li></ul><h3 id="19-CSS在性能优化方面的实践"><a href="#19-CSS在性能优化方面的实践" class="headerlink" title="19.CSS在性能优化方面的实践"></a>19.CSS在性能优化方面的实践</h3><ul><li>css压缩与合并,Gzip压缩</li><li>css文件放在head里,不使用@import</li><li>尽量用缩写,避免用滤镜,合理使用选择器</li></ul><h3 id="20-CSS3动画-简单动画的实现-如旋转"><a href="#20-CSS3动画-简单动画的实现-如旋转" class="headerlink" title="20.CSS3动画(简单动画的实现,如旋转)"></a>20.CSS3动画(简单动画的实现,如旋转)</h3><ul><li>依靠css3中提出的三个属性:transition,transform,animation</li><li>transtion:定义了元素在变化过程中是怎么样的</li><li>transform:定义了元素变化的结果:包含rotate,scale,skew,trasnlate</li><li>animation:动画定义了动作每一帧(@keyframes)有什么效果.</li></ul><h3 id="sass-less的区别"><a href="#sass-less的区别" class="headerlink" title="sass/less的区别"></a>sass/less的区别</h3><ul><li>均含有’变量’,’混合’,’嵌套’,’继承’,’颜色混合’五大基本特性</li><li>sass没有全局变量的概念</li><li>sass基于ruby语言的,less是基于node.js下的npm的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS部分&quot;&gt;&lt;a href=&quot;#CSS部分&quot; class=&quot;headerlink&quot; title=&quot;CSS部分&quot;&gt;&lt;/a&gt;CSS部分&lt;/h2&gt;&lt;h3 id=&quot;1-CSS-Sprite是什么-有什么优缺点&quot;&gt;&lt;a href=&quot;#1-CSS-Sprite是什么-有什么
      
    
    </summary>
    
      <category term="前端面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>区分伪类与伪元素</title>
    <link href="http://yoursite.com/2019/04/19/%E5%8C%BA%E5%88%86%E4%BC%AA%E7%B1%BB%E4%B8%8E%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/04/19/区分伪类与伪元素/</id>
    <published>2019-04-18T23:36:48.000Z</published>
    <updated>2019-04-19T01:30:33.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区分伪类与伪元素"><a href="#区分伪类与伪元素" class="headerlink" title="区分伪类与伪元素"></a>区分伪类与伪元素</h2><h3 id="一-伪类"><a href="#一-伪类" class="headerlink" title="一:伪类"></a>一:伪类</h3><p><strong>1:定义:</strong></p><ul><li>css伪类用于向某些选择器添加特殊效果(本质还是一个类,因此主要作用仍然是用来选择元素而后设定具体的样式)</li><li>伪类其实与普通css类相似,可以为已有的元素添加样式,但是他只有在处于DOM无法描述的状态才能为文档树中的元素添加样式,所以称其为伪类.(这种文档树无法描述的状态是什么呢?,当一个元素在用户不同行为下,就变化成不同的状态这个行为的变化dom就无法描述,就要产生伪类,来为一些选择器添加特殊的效果)</li><li>应用场景:用户的交互动作(悬停,激活)等会导致元素状态发生变化,这时class对这些动态变化无能为力</li></ul><p><strong>2.什么是文档树(DOM)?</strong></p><ul><li>DOM实际上是以面向对象的方式描述的文档模型,DOM定义了表示修改文档所需的对象,这些对象的行为和属性,以及这些对象之间的关系,所以可以把DOM认为是页面上数据与结构的一个树形表示.</li></ul><p><strong>3.伪类选择器有哪些:</strong></p><ol><li>:link向未被选中的链接添加样式</li><li>:visited向已被访问过的链接添加样式</li><li>:hover当鼠标悬浮在元素时,向元素添加样式(没有特别指定是链接,所以这个标签被大量用于定义任何一个块/行元素在鼠标经过时的样式)</li><li>:active向被激活的元素添加样式(当鼠标点击时的样式,要主要是点击时的样式变化,这个也不是只有超链接才能用的伪类选择器)</li><li>:focus向用于键盘输入焦点的元素添加样式(比如input输入框鼠标点击时产生背景颜色的变化,注意是键盘输入焦点,有些浏览器不支持)</li><li>:first-child<ul><li>用于匹配父元素中的第一个元素.例如E:first-child,找的是E元素，E元素必须是他的父元素的第一位元素(扩展:nth-child(n))用于匹配父元素的第n个元素E,这个父元素必须是元素E的父元素</li></ul></li><li>:lang向带有指定lang属性的元素添加样式,（在标签中设置lang的属性，在样式表中对这种确切lang属性值的元素进行样式的设定，即使你有能力为不同的语言定义特殊的规则）</li></ol><p><strong>4.注意:</strong></p><ul><li>伪类选择器:”link”和”visited”只能用于定义链接的未被访问的样式和已被访问过的样式</li><li>伪类选择器: “hover”和:active可以用于定义任何一个块或行元素在鼠标经过时点击时的样式</li></ul><p><strong>5.重点:</strong></p><ul><li>上述:四个伪类选择器的顺序必须是固定的.否则将不会产生期望中的变化.</li><li>记忆技巧:love  hate(变化)</li></ul><h3 id="二-伪元素"><a href="#二-伪元素" class="headerlink" title="二:伪元素"></a>二:伪元素</h3><p><strong>1.伪元素</strong></p><ul><li>用于创建一些文档树中的元素,并且为他添加样式,举个列子:使用伪元素”::bofore”可以在一个元素后面创建一个新的元素,增加一些文本,并且为这个文本添加样式,虽然用户可以在页面上看到一些文本,但是这些文本是不存在于文档树中的.</li></ul><p><strong>2.几种常见的伪元素</strong></p><ol><li>:first-letter用于向文本中第一个字母添加样式</li><li>:first-line用于向文本的首行添加样式</li><li>:before在元素之前添加内容</li><li>:after在元素之后添加内容</li></ol><h3 id="三-伪元素和伪类的区别"><a href="#三-伪元素和伪类的区别" class="headerlink" title="三:伪元素和伪类的区别:"></a>三:伪元素和伪类的区别:</h3><ol><li>伪类和伪元素的最大区别就在于有没有创建一个文档树以外的元素,伪元素创建了一个伪元素以外的元素(虚拟容器)并为它添加样式,这个容器不包含任何DOM元素但是可以包含内容.</li><li>换句话说,伪类和伪元素的区别就是伪类的操作对象是文档树中已有的元素,而伪元素则创建了一个文档树以外的元素.</li><li>伪类使用的是单冒号,但是在css3中伪元素使用的是双冒号,但是除了少部分的伪元素必须使用双冒号以外,像after还有before都是支持单引号的.为了兼容性,所以目前还是在使用一些常见的伪元素的时候还是采用单冒号比较委托</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区分伪类与伪元素&quot;&gt;&lt;a href=&quot;#区分伪类与伪元素&quot; class=&quot;headerlink&quot; title=&quot;区分伪类与伪元素&quot;&gt;&lt;/a&gt;区分伪类与伪元素&lt;/h2&gt;&lt;h3 id=&quot;一-伪类&quot;&gt;&lt;a href=&quot;#一-伪类&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="CSS选择器" scheme="http://yoursite.com/categories/CSS%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
    
      <category term="伪类" scheme="http://yoursite.com/tags/%E4%BC%AA%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>js执行上下文理解</title>
    <link href="http://yoursite.com/2019/04/15/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/15/js执行上下文理解/</id>
    <published>2019-04-15T12:42:04.000Z</published>
    <updated>2019-05-05T00:29:01.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="javascript执行上下文理解"><a href="#javascript执行上下文理解" class="headerlink" title="javascript执行上下文理解"></a>javascript执行上下文理解</h2><blockquote><p>可以理解当前代码的运行环境,代码的运行环境分为三种:</p><ol><li>全局级别的代码</li><li>函数级别的代码</li><li>Eval的代码 -在Eval函数函数体内运行的代码</li></ol></blockquote><ul><li>注意一点: 作用域在函数定义完的时候就已经创建了,而不是在函数调用的时候,这点特点重要</li><li>然后按照程序执行的顺序,一步步把各个上下文环境加上</li></ul><ol><li>第一步首先在加载程序的时候,就已经确定了全局的上下文环境,并随着程序的的执行改变对变量的赋值</li><li>函数的执行上下文是在调用函数后建立的,执行上下文的第一个阶段时在函数调用后,在代码执行之前的进行,执行上下文的第二个阶段时在具体代码执行的时候进行</li><li>作用域只是一个’区域’,一个抽象的概念,其中没有变量的,要通过作用域对应的执行上下环境来获取相应的变量,同一个作用域下,不同的调用会产生不同的的执行上下文环境,继而产生不同的变量</li><li>所以,如果要一个作用域下某个变量的值,就需要找到这个作用域对应的执行上下文环境,在其中变量的值.</li></ol><h3 id="执行上下文栈的理解"><a href="#执行上下文栈的理解" class="headerlink" title="执行上下文栈的理解"></a>执行上下文栈的理解</h3><ul><li>在浏览器中,javascript引起的工作方式是单线程的,也就是说,某一时刻只有唯一的一个事件是被激活处理的.其他事件被放入列中,等待处理</li><li>具体的工作原理:<ul><li>在js代码文件被浏览器载入后,默认最先进入的是一个全局的执行上下文,当在上下文中调用一个执行函数时,程序就会进入该被调用的函数内,此时在引擎就会为该函数创建一个新的执行上下文环境,并且将其压入到执行上下文堆栈的顶部,浏览器总是执行上下文对栈顶部的上下文,一旦执行完毕,该上下文环境就会被弹出,然后,进入其中的上下文执行代码,这样堆栈中上下文就会被弹出.只到只剩下全局的上下文.</li></ul></li></ul><h3 id="执行上下文的建立过程"><a href="#执行上下文的建立过程" class="headerlink" title="执行上下文的建立过程"></a>执行上下文的建立过程</h3><ul><li>我们已经知道,每当我们调用一个函数时,一个新的执行上下文就会被创建出来,然而在js内部,这个过程分为两个阶段</li></ul><p><strong>建立阶段</strong></p><ol><li>建立阶段(发生在函数调用之后,在执行函数内部具体代码之前)</li><li>建立变量,函数,参数对象,并给参数赋值</li><li>建立作用域链</li><li>确定this值</li><li>也就是说除了argument,函数声明,以及参数被赋予的具体的值,其他变量值都是undefined</li></ol><p><strong>执行阶段</strong></p><ol><li>变量赋值,执行其他代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">            console.log(typeof foo); // function pointer</span><br><span class="line">            console.log(typeof bar); // undefined</span><br><span class="line"></span><br><span class="line">            var foo = &apos;hello&apos;,</span><br><span class="line">                bar = function() &#123;</span><br><span class="line">                    return &apos;world&apos;;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            function foo() &#123;</span><br><span class="line">                return &apos;hello&apos;;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;());​</span><br></pre></td></tr></table></figure><ul><li>问题一:为什么我们可以在声明foo变量以前就可以访问到foo呢？</li><li>因为在上下文的建立阶段,显示处理参数声明,然后是函数声明,最后才是变量声明,</li></ul><ol><li>在发现foo函数声明后,就会在variableObject下面建立一个foo属性,其值是一个指向函数的引用,当处理变量声明的时候,发现有var foo的声明,但是variableObject已经具有foo属性,所以函数声明会忽略后来的变量声明.</li></ol><ul><li>问题二:为什么bar是undefined呢?</li></ul><ol><li>因为bar是变量的声明,在建立阶段的时候,被赋予的默认的值是undefined,由于它只有在代码执行阶段才会被赋予具体的值.所以在调用typeof(bar)输出值的时候,输出undefined.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    console.log(typeof foo); //function</span><br><span class="line">    var foo；</span><br><span class="line">    function foo()&#123;&#125;； </span><br><span class="line">    //因为在执行上下文的准备阶段中先找函数声明，后找变量声明，所以取前面的函数声明，忽略后面的同名的变量声明，即在fooExecutionContext里会生成一句：foo: pointer to function c()，即foo的属性值为指向函数c()的指针</span><br><span class="line"></span><br><span class="line">    foo = &quot;foo&quot;;  //执行上下文的执行阶段，会对变量进行赋值，会把foo的值赋为&quot;foo&quot;</span><br><span class="line">    console.log(typeof foo); //string.对foo的string赋值会覆盖掉foo的原来的属性值，它原来的属性值为指向函数c()的指针，现在在fooExecutionContext里名为foo的属性为foo: &quot;foo&quot;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line"></span><br><span class="line">    alert(typeof foo);//undefined</span><br><span class="line"></span><br><span class="line">    var foo=function()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;;//同名的变量，只不过其中一个赋值为函数。按照在执行上下文的准备阶段中先找函数声明，后找变量声明，但两个都为变量，他俩优先级相同，js引擎默认取前面的声明，忽略后面的声明。故最终fooExecutionContext里会生成一句：foo: undefined。</span><br><span class="line">    var foo=&quot;foo&quot;;</span><br><span class="line"></span><br><span class="line">    alert(typeof foo);//string，因为执行上下文的执行阶段，会对变量进行赋值，这个就是按照代码的先后顺序执行了，所以typeof foo为string.</span><br><span class="line">    &#125;;</span><br><span class="line"> a();</span><br></pre></td></tr></table></figure><ul><li><p>总的来说,在建立执行上下文阶段,声明不重要,重要的是执行阶段的赋值,不管建立阶段执行上下文阶段的时候一个属性声明是怎么样的.仍旧可以被的赋值成不同类型的值.这也就是为什么javascript是弱类型语言.</p></li><li><p>在执行上下文第一阶段的准备阶段里变量的声明总结起来有三条:</p><ol><li>函数形参在声明的时候已经指定其形参的值.</li><li>之前的函数声明会忽略之后再声明的同名声明,不是后来同名声明是函数声明还是变量声明.</li><li>普通的变量声明,不会覆盖之前的同名声明,会被忽略此次声明.</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;javascript执行上下文理解&quot;&gt;&lt;a href=&quot;#javascript执行上下文理解&quot; class=&quot;headerlink&quot; title=&quot;javascript执行上下文理解&quot;&gt;&lt;/a&gt;javascript执行上下文理解&lt;/h2&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="js执行上下文环境" scheme="http://yoursite.com/categories/js%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="js深入了解" scheme="http://yoursite.com/tags/js%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>this指针问题总结</title>
    <link href="http://yoursite.com/2019/04/15/this%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/15/this指针问题总结/</id>
    <published>2019-04-15T12:35:39.000Z</published>
    <updated>2019-04-15T12:41:04.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this指针问题总结"><a href="#this指针问题总结" class="headerlink" title="this指针问题总结"></a>this指针问题总结</h2><h3 id="this实例代码"><a href="#this实例代码" class="headerlink" title="this实例代码"></a>this实例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个全局变量</span><br><span class="line">var type = &quot;全局&quot;; </span><br><span class="line"> </span><br><span class="line">// 定义函数aa</span><br><span class="line">function aa () &#123;</span><br><span class="line">var type = &apos;局部&apos;;</span><br><span class="line">console.log(this.type);</span><br><span class="line">&#125;</span><br><span class="line">aa(); // &quot;全局&quot;</span><br><span class="line"> </span><br><span class="line">// 定义对象bb</span><br><span class="line">var bb = &#123;</span><br><span class="line">type: &apos;局部&apos;,</span><br><span class="line">getType: function () &#123;</span><br><span class="line">console.log(this.type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">bb.getType(); // “局部”</span><br><span class="line"> </span><br><span class="line">// 定义对象cc</span><br><span class="line">var cc = &#123;</span><br><span class="line">type: &apos;局部&apos;,</span><br><span class="line">getType: function () &#123;</span><br><span class="line">return function () &#123;</span><br><span class="line">return this.type</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">cc.getType(); // “全局”（非严格模式下）</span><br></pre></td></tr></table></figure><ol><li>第一个函数的运行在全局环境中.所以this指向window.</li><li>bb是一个对象,当函数作为一个对象的方法被调用时,this指向调用的对象</li><li>cc第三个比较复杂,这个和JS的活动对象有关。每个函数在被调用时，其活动对象都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索其活动对象为止，活动对象为当前所在执行环境的变量对象，当前所在的执行环境是一个立即执行的匿名函数，变量对象里并没有this.type，所以this还是指向window。</li></ol><h3 id="改变this的几种方法"><a href="#改变this的几种方法" class="headerlink" title="改变this的几种方法**"></a>改变this的几种方法**</h3><p><strong>1.apply()接收两个参数,一作用域,二是参数(可以是数组也可以是arguments对象)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function test (test1, test2) &#123;</span><br><span class="line">console.log(test1 + test2);</span><br><span class="line">&#125;</span><br><span class="line">function applyTest1 (test1, test2) &#123;</span><br><span class="line">return test.apply(this, [test1, test2]); // 传入数组</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function applyTest2 (test1, test2) &#123;</span><br><span class="line">return test.apply(this, arguments); // 传入arguments</span><br><span class="line">&#125;</span><br><span class="line">applyTest1 (50, 50); // 100</span><br><span class="line">applyTest2 (50, 50); // 100</span><br></pre></td></tr></table></figure></p><ul><li>这个例子里将test函数的this指向了applyTest系列函数，同时参数为applyTest系列函数传入的参数为数组和arguments对象都可以正常执行并返回正确的结果。</li></ul><p><strong>2.call()</strong></p><ul><li><p>call()的使用和apply()基本是一样的，不同的是参数的传递，call()必须明确的传入每一个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test (test1, test2) &#123;</span><br><span class="line">console.log(test1 + test2);</span><br><span class="line">&#125;</span><br><span class="line">function applyTest1 (test1, test2) &#123;</span><br><span class="line">return test.call(this, test1, test2); // 明确传入参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当然，传递参数并不是apply()和call()真正的用武之地，其真正强大的地方还是在于通过传入作用域来扩充函数赖以运行的作用域。通过传入的作用域不同，来改变函数的this指向.</p></li></ul><h3 id="call-方法和apply-方法的区别"><a href="#call-方法和apply-方法的区别" class="headerlink" title="call()方法和apply()方法的区别."></a>call()方法和apply()方法的区别.</h3><ul><li>相同点: 都用来改变this的指向 都是调用一个对象的方法,(功能相同)</li><li>例如： B.call(A, args1,args2);即A对象调用B对象的方法 F.apply(G, arguments);即G对象应用F对象的方法</li><li>不同点: 参数书写方式不同.<ul><li>call()第一个参数是this需要指向的对象.后来是参数列表,可以是任意类型的值.当第一个参数为null/undefined时.默认指向window.</li><li>apply():第一个参数是this所要指向的对象.第二个参数是一个数组.</li></ul></li></ul><h3 id="call和bind区别"><a href="#call和bind区别" class="headerlink" title="call和bind区别"></a>call和bind区别</h3><ul><li>相同点:都是用来改变this的指向</li><li>不同点:call改变this指向后,会立即执行函数,bind改过this后,不执行函数,会返回一个绑定新this的函数.需要手动调用</li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li>call的应用</li><li>利用call()来判断数据类型</li><li><p>在判断数据类形式使用typeof，一般不是太准确的，我们可以使用Object.prototype.toString.call()方法来判断一个数据的数据类型.</p></li><li><p>使用apply可以找出数组中的最大值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [2,4,5,1];</span><br><span class="line">console.log(Math.max.apply(arr,[2,4,5,1]));</span><br></pre></td></tr></table></figure></li><li><p>注意:Math是一个对象, 第一个arr表示让arr借用max这个方法,相当于替换了Math对象.第二个参数是数组.</p></li><li>apply(执行的操作)1.执行Math.max[1,2,3,5];2.把内部的this改成arr</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;this指针问题总结&quot;&gt;&lt;a href=&quot;#this指针问题总结&quot; class=&quot;headerlink&quot; title=&quot;this指针问题总结&quot;&gt;&lt;/a&gt;this指针问题总结&lt;/h2&gt;&lt;h3 id=&quot;this实例代码&quot;&gt;&lt;a href=&quot;#this实例代码&quot; cla
      
    
    </summary>
    
      <category term="this指针" scheme="http://yoursite.com/categories/this%E6%8C%87%E9%92%88/"/>
    
    
      <category term="-this" scheme="http://yoursite.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>js常用字符串方法总结归纳</title>
    <link href="http://yoursite.com/2019/04/15/js%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    <id>http://yoursite.com/2019/04/15/js常用字符串方法总结归纳/</id>
    <published>2019-04-15T01:38:30.000Z</published>
    <updated>2019-04-15T02:08:53.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用JS-string字符串方法"><a href="#常用JS-string字符串方法" class="headerlink" title="常用JS-string字符串方法"></a>常用JS-string字符串方法</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>我们刚刚总结了数组的一些常用方法,这次我们来总结一下字符串的常用方法,总结完希望对数组和字符串的方法有一个清楚的认知</p></blockquote><h3 id="1-字符串的分割"><a href="#1-字符串的分割" class="headerlink" title="1.字符串的分割"></a>1.字符串的分割</h3><h3 id="1-slice-start-end"><a href="#1-slice-start-end" class="headerlink" title="1. slice(start,end)"></a><strong>1. slice(start,end)</strong></h3><ul><li>关于这个方法,要搞懂四个关键点<ol><li>截取时的下标不包括下标为<strong>end</strong>的元素</li><li>end是可选参数,没有时,默认从start截取到结束的所有字符串</li><li>String.slice与Array.slice区别</li><li>参数:参数为负数时,是如何处理的?</li></ol></li></ul><h3 id="2-substr-start-length"><a href="#2-substr-start-length" class="headerlink" title="2. substr(start,length)"></a><strong>2. substr(start,length)</strong></h3><ul><li>关于这个方法,也有几个要搞懂的点<ol><li>第二个参数是字符串中的字符数,必须是数值.可以没有</li><li>参数为负数时,如何进行处理</li><li>最重要的一点来自官网说明,如下所示</li></ol></li><li>由于substr()的参数指定了子串的开始位置和长度,因此可以使用substring(),slice()代替使用它</li></ul><h3 id="3-substring-start-end"><a href="#3-substring-start-end" class="headerlink" title="3. substring()(start,end)"></a><strong>3. substring()(start,end)</strong></h3><ul><li>和slice类型,关于这个方法,同样需要搞懂几个关键点：<ol><li>返回的字符串中不包括<strong>end</strong>处的字符</li><li>参数为负数时如何进行处理</li><li>如果参数 start 与 stop 相等，那么该方法返回的就是一个空串(即长度为 0 的字符串)</li><li>如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数</li></ol></li></ul><p><strong>区别和使用</strong></p><ol><li>都接收两个参数,slice和substring接收的是起始位置和结束位置(注意:不包括结束位置),而substr接收的则是起始位置和索要返回的字符串的长度</li><li>需要注意的是:substring是以两个参数中较小的一个作为起始位置,较大的参数作为结束位置</li></ol><h3 id="4-split-字符串-正则-length"><a href="#4-split-字符串-正则-length" class="headerlink" title="4.split(字符串/正则,length)"></a><strong>4.split(字符串/正则,length)</strong></h3><ul><li>split()把一个字符串string分割成判断创建一个字符串数组,可选的参数1指定字符串或正则,参数2指定数组的最大长度</li></ul><p><strong>5. replace(seacrchValue,replaceValue)</strong></p><ul><li>作用:replace方法对string进行查找和替换操作,并返回一个新的字符串</li><li>取值:参数searchValue可以是一个字符串或者一个正则表达式对象</li><li>第一种情况:如果searchValue是一个字符串,那么searchValue只会在第一次出现的地方替换</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用JS-string字符串方法&quot;&gt;&lt;a href=&quot;#常用JS-string字符串方法&quot; class=&quot;headerlink&quot; title=&quot;常用JS-string字符串方法&quot;&gt;&lt;/a&gt;常用JS-string字符串方法&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="字符串方法总结" scheme="http://yoursite.com/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="javascript基础" scheme="http://yoursite.com/tags/javascript%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数组方法总结归纳</title>
    <link href="http://yoursite.com/2019/04/14/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3/"/>
    <id>http://yoursite.com/2019/04/14/数组方法总结归纳/</id>
    <published>2019-04-14T12:54:21.000Z</published>
    <updated>2019-04-15T01:35:30.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js中常用的数组方法的总结"><a href="#js中常用的数组方法的总结" class="headerlink" title="js中常用的数组方法的总结"></a>js中常用的数组方法的总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>我认为学习完一个知识点,想要真正掌握它,最好的方式就是你用自己的话把内容表达清楚,现在我开始将以前学习的关于数组的知识整合起来,和大家一起提高</p></blockquote><h3 id="1-Array-map"><a href="#1-Array-map" class="headerlink" title="1.Array.map()"></a>1.Array.map()</h3><ul><li>此方法是将数组中的每一元素调用一个提供的函数</li><li>作用:数组中的元素为原始数组调用函数处理后的值</li><li>参数:arr.map(function(item,index,arr){}) item:每一项,index:当前索引,ary:当前数组</li><li>返回值:作为一个新的数组返回</li><li>是否改变原始数组:不改变原数组,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">    let newArr = arr.map(x =&gt; x*2)</span><br><span class="line">    //arr= [1, 2, 3, 4, 5]   原数组保持不变</span><br><span class="line">    //newArr = [2, 4, 6, 8, 10] 返回新数组</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Array-forEach"><a href="#2-Array-forEach" class="headerlink" title="2.Array.forEach()"></a>2.Array.forEach()</h3><ul><li>此方法是将数组中的每一个元素执行提供的函数,没有返回值,直接改变原数组,注意与map方法区分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">   arr.forEach(x =&gt; x*2)</span><br><span class="line">   // arr = [2, 4, 6, 8, 10]  数组改变,注意和map区分</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-Array-filter"><a href="#3-Array-filter" class="headerlink" title="3.Array.filter()"></a>3.Array.filter()</h3><ul><li>此方法是将所有的元素进行判断,将满足条件的元素作为一个新数组返回,</li><li>作用:创建一个新数组,新数组中的元素是通过检查指定数组中符合条件的所有元素</li><li>返回值:返回一个新数组,</li><li>是否改变原始数组:不会改变原始数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">    const isBigEnough =&gt; value =&gt; value &gt;= 3</span><br><span class="line">    let newArr = arr.filter(isBigEnough )</span><br><span class="line">    //newNum = [3, 4, 5] 满足条件的元素返回为一个新的数组</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-Array-some"><a href="#4-Array-some" class="headerlink" title="4.Array.some()"></a>4.Array.some()</h3><ul><li>此方法是将所有元素都进行判断返回一个布尔值,如果存在元素都满足判断条件,</li><li>作用:检测数组中的元素是否满足指定条件</li><li>返回值:布尔值则返回true,若所有元素都不满足判断条件,则返回fasle</li><li>是否改变原始数组: 不改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr= [1, 2, 3, 4, 5]</span><br><span class="line">    const isLessThan4 =&gt; value =&gt; value &lt; 4</span><br><span class="line">    const isLessThan6 =&gt; value =&gt; value &gt; 6</span><br><span class="line">    arr.some(isLessThan4 ) //true</span><br><span class="line">    arr.some(isLessThan6 ) //false</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-Array-reduce"><a href="#5-Array-reduce" class="headerlink" title="5.Array.reduce()"></a>5.Array.reduce()</h3><ul><li>此方法是所有元素调用返回函数,返回值为最后结果,传入的值必须是函数类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">   const add = (a, b) =&gt; a + b</span><br><span class="line">   let sum = arr.reduce(add)</span><br><span class="line">   //sum = 15  相当于累加的效果</span><br><span class="line">   与之相对应的还有一个 Array.reduceRight() 方法，区别是这个是从右向左操作的</span><br></pre></td></tr></table></figure></li></ul><h3 id="6-Array-push"><a href="#6-Array-push" class="headerlink" title="6.Array.push()"></a>6.Array.push()</h3><ul><li>作用:此方法在数组的后面添加新元素</li><li>参数:要添加的项</li><li>返回值:新数组的长度</li><li>是否改变原数组:改变</li></ul><h3 id="7-Array-pop"><a href="#7-Array-pop" class="headerlink" title="7.Array.pop()"></a>7.Array.pop()</h3><ul><li>作用:pop为从数组中删除最后一个元素</li><li>参数:无</li><li>返回值:被删除的项</li><li>是否改变原数组:改变</li><li>数组为空时返回undefined。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].pop();</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-Array-unshift"><a href="#8-Array-unshift" class="headerlink" title="8.Array.unshift()"></a>8.Array.unshift()</h3><ul><li>作用:此方法是将一个或多个元素添加到数组的开头</li><li>参数:要添加的项,多项用逗号隔开</li><li>返回值:返回新数组的长度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">    arr.unshift(6, 7)</span><br><span class="line">    console.log(arr) //[6, 7, 2, 3, 4, 5]</span><br><span class="line">    console.log(arr.length) //7</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-Array-shift"><a href="#9-Array-shift" class="headerlink" title="9.Array.shift()"></a>9.Array.shift()</h3><ul><li>作用:此方法在数组后面删除第一个元素</li><li>返回值:并返回被删除的项</li><li>是否改变原数组:改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5]</span><br><span class="line">    arr.shift()</span><br><span class="line">    console.log(arr) //[2, 3, 4, 5]</span><br><span class="line">    console.log(arr.length) //4</span><br></pre></td></tr></table></figure></li></ul><h3 id="10-Array-isArray"><a href="#10-Array-isArray" class="headerlink" title="10.Array.isArray()"></a>10.Array.isArray()</h3><ul><li>判断一个对象是不是数组，返回的是布尔值</li></ul><h3 id="11-Array-concat"><a href="#11-Array-concat" class="headerlink" title="11. Array.concat()"></a>11. Array.concat()</h3><ul><li>用于连接两个或多个数组</li><li>参数:参数可以是具体的值,也可以是数组对象.可以是任意多个</li><li>返回值:返回连接后的数组</li><li>是否改变原数组:不改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [1, 2, 3]</span><br><span class="line">      arr2 = [4, 5]</span><br><span class="line">  let arr = arr1.concat(arr2)</span><br><span class="line">  console.log(arr)//[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></li></ul><h3 id="12-Array-toString"><a href="#12-Array-toString" class="headerlink" title="12.Array.toString()"></a>12.Array.toString()</h3><ul><li>此方法将数组转化成字符串,并返回结果,默认用逗号分隔<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, 2, 3, 4, 5];</span><br><span class="line">   let str = arr.toString()</span><br><span class="line">   console.log(str)// 1,2,3,4,5</span><br></pre></td></tr></table></figure></li></ul><h3 id="13-Array-join"><a href="#13-Array-join" class="headerlink" title="13.Array.join()"></a>13.Array.join()</h3><ul><li>用指定的分隔符将数组每一项拼接成字符串</li><li>参数:指定的分隔符,如果省略该参数,则使用逗号作为分隔符</li><li>返回值:拼接好的字符串</li><li><p>是否改变原始数组:不改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.join(&apos;-&apos;);</span><br><span class="line">console.log(ary);  // [1, 2, 3, 4, 5]</span><br><span class="line">console.log(res);  // 1-2-3-4-5</span><br></pre></td></tr></table></figure></li><li><p>通过上面这个列子可以看出和tostring的区别,join可以设置元素之间的间隔</p></li></ul><h3 id="14-Array-splice"><a href="#14-Array-splice" class="headerlink" title="14.Array.splice()"></a>14.Array.splice()</h3><ul><li>作用:万能方法可以实现增删改,</li><li>返回值:被删除的项目</li><li>是否改变原始数组:该方法会改变原始数组</li><li>语法:Array.splice(index,howmany,item1….,itemn)</li><li><p>index表示添加/删除项目的位置,howmany要删除项目的数量,item1…要新增的项目</p><p> <strong>1.增加功能</strong></p></li><li><code>ary.splice(n,0,x，......,y);</code></li><li><p>从数组的索引n开始，删除0项,在索引n的前边增加新的项，第三个参数开始都是用来填补删除的项目位置的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.splice(1,0,6,7);</span><br><span class="line">console.log(ary);  // [1, 6, 7, 2, 3, 4, 5]</span><br><span class="line">console.log(res);  // [] 删除0项，返回一个空数组</span><br></pre></td></tr></table></figure><p> <strong>2.删除的功能</strong></p></li><li><code>ary.splice(n,m);</code></li><li><p>从数组的索引n开始,删除m项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.splice(1,2);</span><br><span class="line">console.log(ary);  // [1，4，5]</span><br><span class="line">console.log(res);  // [2，3]</span><br></pre></td></tr></table></figure><p> <strong>3.修改的功能</strong></p></li><li><code>ary.splice(n,m,x);</code></li><li><p>从数组的索引n开始，删除m项，把x添加到索引n前边</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.splice(1,2,6,7);</span><br><span class="line">console.log(ary);  // [1, 6, 7, 4, 5]</span><br><span class="line">console.log(res);  // [2，3]</span><br></pre></td></tr></table></figure></li><li><p>模拟push(尾部添加) 与push二者返回值不同,push返回数组的长度,splice返回被删除的项</p></li><li><code>arr.splice(arr.length,0,新的项)</code>  因为splice是在索引前添加,所以是arr.length</li><li>模拟pop(尾部删除)</li><li><code>arr.splice(arr.length-1,1)</code></li><li>模拟shift(首项删除)</li><li><code>arr.splice(0,1)</code></li><li>模拟unshift(首项添加)和unshift二者返回值不同</li><li><p>arr.splice(0,0,新的项)</p></li><li><p>此外</p></li><li>arr.splice(n) 表示从索引n开始删除和末尾</li><li>arr.splice(0) 表示删除整个数组 有克隆数组的效果,利用返回值</li></ul><h3 id="15-slice"><a href="#15-slice" class="headerlink" title="15.slice"></a>15.slice</h3><ul><li>作用:截取数组(复制数组)</li><li>参数:`array.slice(start,end) 删除的时候不包括end这一项</li><li>返回值:返回一个新数组</li><li><p>是否改变原数组:不改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.slice(1,3);</span><br><span class="line">var res2 = ary.slice(-3,-1)</span><br><span class="line">console.log(ary);  // [1,2,3,4,5]</span><br><span class="line">console.log(res);  // [2,3]</span><br><span class="line">console.log(res2)  //[3,4] slice支持负参数，从最后一项开始算起，-1为最后一项，-2为倒数第二项</span><br></pre></td></tr></table></figure></li><li><p>注意与splice区别,slice不改变原数组,返回值为一个新数组,splice返回值为被删除的项,返回值一个新数组</p></li></ul><h3 id="16-sort"><a href="#16-sort" class="headerlink" title="16.sort"></a>16.sort</h3><ul><li>作用:对数组元素进行排序</li><li>参数:可选(函数)规定排序规则,默认排序顺序默认为字母升序</li><li>返回值:排好序的原数组</li><li>是否改变原数组:改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,5,7,9,12,24,56,87,92];</span><br><span class="line">var ary2 = [1,5,7,9,12,24,56,87,92];</span><br><span class="line">var ary3 = [1,5,7,9,12,24,56,87,92];</span><br><span class="line">var res = ary.sort();</span><br><span class="line">var res2 = ary2.sort(function(a,b)&#123;</span><br><span class="line">    return a-b;</span><br><span class="line">&#125;)</span><br><span class="line">var res3 = ary3.sort(function(a,b)&#123;</span><br><span class="line">    return b-a;</span><br><span class="line">&#125;)</span><br><span class="line">// sort的参数函数总的形参a,b就是数组排序时候的相邻比较的两项</span><br><span class="line">console.log(res);  // [1, 12, 24, 5, 56, 7, 87, 9, 92]</span><br><span class="line">console.log(res2); // [1, 5, 7, 9, 12, 24, 56, 87, 92]</span><br><span class="line">console.log(res3); // [92, 87, 56, 24, 12, 9, 7, 5, 1]</span><br></pre></td></tr></table></figure></li></ul><h3 id="17-reverse"><a href="#17-reverse" class="headerlink" title="17.reverse"></a>17.reverse</h3><ul><li>作用:倒序数组</li><li>参数:无</li><li>返回值:倒序后的原数组</li><li>是否改变原数组:改变</li><li>注意: 返回值与原数组的值相同<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5];</span><br><span class="line">var res = ary.reverse();</span><br><span class="line">console.log(ary);  // [5, 4, 3, 2, 1]</span><br><span class="line">console.log(res);  // [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure></li></ul><h3 id="18-indexOf"><a href="#18-indexOf" class="headerlink" title="18.indexOf"></a>18.indexOf</h3><ul><li>作用:查找指定元素的位置</li><li>参数:array.indexOf(item,start) item:查找元素 start:字符串中开始检索的位置</li><li>返回值:返回第一次查到的索引,为找到返回-1,</li><li>是否改变原数组:不改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ary = [1,2,3,4,5]</span><br><span class="line">var res = ary.indexOf(3);</span><br><span class="line">console.log(ary);  // [1,2,3,4,5]</span><br><span class="line">console.log(res);  // 2</span><br><span class="line">var ary = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;c&apos;];</span><br><span class="line">var res = ary.indexOf(&apos;c&apos;,3);</span><br><span class="line">console.log(res) // 4</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;js中常用的数组方法的总结&quot;&gt;&lt;a href=&quot;#js中常用的数组方法的总结&quot; class=&quot;headerlink&quot; title=&quot;js中常用的数组方法的总结&quot;&gt;&lt;/a&gt;js中常用的数组方法的总结&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; cla
      
    
    </summary>
    
      <category term="数组" scheme="http://yoursite.com/categories/%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="javascript基础" scheme="http://yoursite.com/tags/javascript%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题总结之HTML， HTTP，web综合问题</title>
    <link href="http://yoursite.com/2019/04/13/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/13/前端面试题总结/</id>
    <published>2019-04-13T12:33:00.000Z</published>
    <updated>2019-05-13T00:27:31.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML，-HTTP，web综合问题"><a href="#HTML，-HTTP，web综合问题" class="headerlink" title="HTML， HTTP，web综合问题"></a>HTML， HTTP，web综合问题</h2><h3 id="1-什么是CSS预处理"><a href="#1-什么是CSS预处理" class="headerlink" title="1.什么是CSS预处理"></a>1.什么是CSS预处理</h3><ul><li>css预处理定义:<ul><li>定义了一种新的语言,其基本思想是同一种专门变成语言,为CSS增加了一些编程特性,将css作为目标生成文件,开发者就只要使用这种语言进行编码工作,就会让你的代码可读性更强,层级关系更加分明,更便于代码的维护</li></ul></li><li><p>几种预处理语言</p><ul><li>sass</li><li>less</li><li>stylus</li><li>burbine</li><li>switch css</li><li>dt css</li><li>css cacheer  </li></ul></li><li><p>sass是最早也是最成熟的预处理器,拥有ruby社区的支持和compass这一强大的框架,目前已经兼容css的scss</p></li><li>less,优点简单,兼容css,twitter bootstrap就是采用less做底层语言的</li><li>stylus:来自node.js,主要在node项目中进行css预处理支持</li></ul><h3 id="2-Javascript中的定时器有哪些？他们的区别及用法是什么"><a href="#2-Javascript中的定时器有哪些？他们的区别及用法是什么" class="headerlink" title="2.Javascript中的定时器有哪些？他们的区别及用法是什么?"></a>2.Javascript中的定时器有哪些？他们的区别及用法是什么?</h3><ul><li>setTimeOut 只会执行一次</li><li>setInterval 会一直重复执行</li></ul><h3 id="3-请描述一下cookies-sessionStorage与loaclStorage区别"><a href="#3-请描述一下cookies-sessionStorage与loaclStorage区别" class="headerlink" title="3.请描述一下cookies sessionStorage与loaclStorage区别"></a>3.请描述一下cookies sessionStorage与loaclStorage区别</h3><ul><li>cookie是网站为了标示用户身份而存储在用户本地终端(Client Side)上的数据(通常是经过加密的)</li><li>第一个请求数据不会存在于服务器中</li><li>相同点:都存储在客户端</li><li>不同点:</li></ul><ol><li>存储大小 <ul><li>cookies数据大小不能超过4k</li><li>sessionStorage和localStorage虽然也有大小的限制,但是比cookie大的多,可以达到5M或更大</li></ul></li><li>有效时间<ul><li>loaclStorage存储持久数据,在浏览器关闭后数据不会丢失,除非主动删除</li><li>sessionStorage数据在浏览器关闭后数据自动删除</li><li>cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li><li>数据与服务器之间的交互方式<ul><li>cookie的数据会自动的传递到服务器，服务器端也可以写cookie到客户端</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存</li></ul></li></ol><h3 id="4-编写一个方法去掉数组里面-重复的内容-var-arr-1-2-3-4-5-1-2-3"><a href="#4-编写一个方法去掉数组里面-重复的内容-var-arr-1-2-3-4-5-1-2-3" class="headerlink" title="4.编写一个方法去掉数组里面 重复的内容  var arr=[1,2,3,4,5,1,2,3]"></a>4.编写一个方法去掉数组里面 重复的内容  var arr=[1,2,3,4,5,1,2,3]</h3><p><strong>一个数组去重的实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;abc&apos;,&apos;abcd&apos;,&apos;sss&apos;,&apos;2&apos;,&apos;d&apos;,&apos;t&apos;,&apos;2&apos;,&apos;ss&apos;,&apos;f&apos;,&apos;22&apos;,&apos;d&apos;];</span><br><span class="line">//定义一个新的数组</span><br><span class="line">var s = [];</span><br><span class="line">//遍历数组</span><br><span class="line">for(var i = 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(s.indexOf(arr[i]) == -1)&#123;  //判断在s数组中是否存在，不存在则push到s数组中</span><br><span class="line">        s.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(s);</span><br><span class="line">//输出结果：[&quot;abc&quot;, &quot;abcd&quot;, &quot;sss&quot;, &quot;2&quot;, &quot;d&quot;, &quot;t&quot;, &quot;ss&quot;, &quot;f&quot;, &quot;22&quot;]</span><br></pre></td></tr></table></figure></p><h3 id="5-计算一个数组arr所有元素的和"><a href="#5-计算一个数组arr所有元素的和" class="headerlink" title="5.计算一个数组arr所有元素的和"></a>5.计算一个数组arr所有元素的和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr1=[1,2,3,4,5,6,7,8,9];</span><br><span class="line">var sum1=0;</span><br><span class="line">for (var i=0;i&lt;=arr1.length;i++) &#123;</span><br><span class="line">if (typeof arr1[i]==&quot;number&quot;) &#123;</span><br><span class="line">sum1+=arr1[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">document.write(sum1);</span><br></pre></td></tr></table></figure><h3 id="6-ajax的步骤"><a href="#6-ajax的步骤" class="headerlink" title="6.ajax的步骤"></a>6.ajax的步骤</h3><blockquote><p></p><p style="color:red;font-weight:bold">什么是ajax</p> <p></p><ul><li>ajax(异步javascript xml)能够刷新局部网页数据,而不是重新加载整个网页</li><li>如何使用ajax<ol><li>第一步,创建xmlhttpquest对象,var xmlhttp = new XMLhttpRequest();XMLHttpRequest对象用来和服务器交换数据</li><li>第二步,使用xmlhttpquest对象的open()和send()方法发送资源请求给服务器.<ul><li>open()中需要发送method get/post url在文件上的位置,async true异步/fasle同步</li></ul></li><li>第三部,使用xmlhttpquest对象的responseText和responseXML属性获取服务器的响应</li><li>第四步,onreadystatechange函数,当发送请求到服务器,我们想要服务器响应执行一些功能,就需要使用onreadystatechange函数,每次xmlhttpquest对象的readystate发生改变都会触发onreadystatechange函数.</li></ol></li></ul></blockquote><h3 id="7-XML和json的区别"><a href="#7-XML和json的区别" class="headerlink" title="7.XML和json的区别"></a>7.XML和json的区别</h3><ul><li>XML可扩展标记语言,HTML是用来显示数据,XML的作用是传输和存储数据,作用是将数据从html中分离出去</li><li>json相对XML来讲,数据的体积更小,传递的速度更快</li><li>JSON与javaScript交互更加方便,更容易解析处理,更好的进行数据交互</li><li>XML对数据的描述比json好</li><li>JSON的速度要远远快于XML</li></ul><p>###(新增加内容)HTML和XML有什么区别</p><ul><li>XML的出生是为了完善HTML的缺陷和局限性</li></ul><ol><li>作用:HTML是为了显示数据,XML是为了传输和存储数据</li><li>语法:几乎没有什么要求,要求嵌套,配对,并遵循DTD的树形结构</li><li>空格:多个时只显示一个,XML有几个就显示几个</li><li>大小写敏感:HTML不敏感,XML敏感</li></ol><h3 id="8-清除浮动的方法"><a href="#8-清除浮动的方法" class="headerlink" title="8.清除浮动的方法"></a>8.清除浮动的方法</h3><ol><li>父div定义height</li></ol><ul><li>原理:父级div手动定义height,就解决了父级div无法自动获取高度的问题</li><li>缺点:只适合高度固定的布局,要给出精确的高度,如果高度和父级div不一样,会产生问题</li></ul><ol start="2"><li>结尾处加上空div标签:clear:both</li></ol><ul><li>原理: 添加一个空的div,利用css提供的clear:both清除浮动,让父级div自动就能获取到高度</li></ul><ol start="3"><li>父级div定义 伪类:after 和 zoom</li></ol><ul><li>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE专有属性)可解决ie6,ie7浮动问题 </li></ul><ol start="4"><li>父级div定义 overflow:hidden</li></ol><ul><li>原理:必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度</li><li>缺点:不能和position配合使用，因为超出的尺寸的会被隐藏。 </li></ul><h3 id="9-box-sizing常用的属性有哪些？分别有什么作用？"><a href="#9-box-sizing常用的属性有哪些？分别有什么作用？" class="headerlink" title="9.box-sizing常用的属性有哪些？分别有什么作用？"></a>9.box-sizing常用的属性有哪些？分别有什么作用？</h3><ul><li>属性值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box-sizing：content-box</span><br><span class="line">box-sizing：border-box</span><br><span class="line">box-sizing：inherit</span><br></pre></td></tr></table></figure></li></ul><p><strong>content-box</strong></p><pre><code>- 这是box-sizing的默认属性值- 在CSS中定义的宽度和高度对应元素的内容框- 在CSS中定义的宽度和高度之外绘制元素的内外边距和边框 </code></pre><p><strong>border-box</strong></p><pre><code>- 在CSS中微元素设定的宽度和高度就决定了元素的边框的盒- 即为元素的内边框和边框是在已经定义好的宽度和高度之间之内绘制的- CSS中的设定的高度和宽度减去边框的内外边距,才能得到元素内容所占的实际宽度和高度</code></pre><ul><li>即centent-box是在定义的宽度的高度之外绘制元素的内边距和边框(元素的默认效果)</li><li>border-box:元素指定的任何内边框和边框都将在定义的高度和宽度之间的进行绘制,通过已设定的高度和宽度减去内边距和边框的和得到的才是内容的宽度和高度</li></ul><h3 id="10-CSS选择器有哪些-选择器的权重的优先级"><a href="#10-CSS选择器有哪些-选择器的权重的优先级" class="headerlink" title="10.CSS选择器有哪些?选择器的权重的优先级"></a>10.CSS选择器有哪些?选择器的权重的优先级</h3><p><strong>选择器类型:</strong></p><ol><li>id选择器 #id</li><li>class选择器 .calss</li><li>标签选择器 p</li><li>通用 *</li><li>属性选择器 [type=”text”]</li><li>伪类选择器 :hover</li><li>伪元素选择器 ::first-line</li><li>子选择器,相邻选择器</li></ol><p><strong>权重:</strong></p><ol><li>第一等:表示内联样式,如style=””,权值1000</li><li>第二等:id选择器 权值为100</li><li>第三等:class选择器 权值为10</li><li>第四等:代表类型选择器和伪元素选择器,如div p 权值为1</li><li>通配符,子选择器,相邻选择器等的.如.&gt;.+权值为0</li><li>继承样式没有权值</li></ol><h3 id="11-js有几种数据类型-其中基本数据类型有哪些"><a href="#11-js有几种数据类型-其中基本数据类型有哪些" class="headerlink" title="11.js有几种数据类型,其中基本数据类型有哪些?"></a>11.js有几种数据类型,其中基本数据类型有哪些?</h3><ul><li>五种基本数据类型:undefined,Null,Bollean,Number和String</li><li>一种复杂数据类型-Object,Object本质上是由一组无序的名值对组成</li><li>Object,Array,Function则属于引用数据类型</li></ul><h3 id="12-undefined和null的区别"><a href="#12-undefined和null的区别" class="headerlink" title="12.undefined和null的区别"></a>12.undefined和null的区别</h3><ul><li>null:Null类型,代表是空值,代表一个空对象的指针,使用typeof运算得到一个object,所以你可以认为它是一个特殊的对象值(声明了赋值了只是值为null)</li><li>undefined:Undefined类型,当一个声明了的变量没有初始化,得到的值就是undefined</li><li>null是javascript关键字,可以认为是对象类型,它是一个空对象指针,和其他语言一样都代表是”空值”</li><li>javaScript权威指南:null 和 undefined 都表示“值的空缺”，你可以认为undefined是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。</li></ul><h3 id="13-http和https有何区别-如何灵活使用"><a href="#13-http和https有何区别-如何灵活使用" class="headerlink" title="13.http和https有何区别?如何灵活使用"></a>13.http和https有何区别?如何灵活使用</h3><ul><li>http是HTTP协议运行在TCP之上.所有传输的内容都是明文,客户端和服务器端都无法验证对方的身份</li><li>https是HTTP运行SSL/TLS之上,SSL/TLS运行在TCP之上.所有传输都经过加密,加密采用对称加密.</li></ul><h3 id="14-原型链的解释"><a href="#14-原型链的解释" class="headerlink" title="14.原型链的解释"></a>14.原型链的解释</h3><ul><li>由于<em>proto</em>是任何对象都有的属性,而js里万物都有对象,所以会形成一条由<em>proto</em>连起来的链条,递归访问_proto必须最终到头,并且值是null</li></ul><blockquote><p><strong>属性的设置</strong></p><ul><li>读取对象属性时,会自动在原型链的中查找</li><li>设置对象属性时,不会查找原型链,如果是当时中没有的属性,直接添加属性并设置此值</li><li>方法一般定义在原型中.属性一般通过构造函数定义在函数本身.</li></ul></blockquote><ul><li>注意:这里有一个特别的函数Function() 它是new自己创建的.它自己的显式原型与隐式原型属性指向同一个原型对象</li></ul><h3 id="15-对前端路由的理解-前后端路由的区别"><a href="#15-对前端路由的理解-前后端路由的区别" class="headerlink" title="15.对前端路由的理解?前后端路由的区别?"></a>15.对前端路由的理解?前后端路由的区别?</h3><ul><li>前端路由和后端路由在实现原理上不一样,但是原理都是一样的.在HTML的history API出现之前,前端的路由都是通过hash来实现的,hash能兼容低版本的浏览器</li></ul><p><strong>服务器路由</strong>:每次跳转到不同URL,都是重新访问服务端,然后服务端返回页面,页面也可以是服务端获取数据，然后和模板组合，返回HTML，也可以是直接返回模板HTML，然后由前端JS再去请求数据，使用前端模板和数据进行组合，生成想要的HTML。</p><p><strong>前端路由</strong>:每次跳转到不同URL都是使用前端的锚点路由.实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合，当然模板有可能是请求服务端返回的，这就是 SPA 单页程序。</p><h3 id="16-解释一下call函数和apply函数的作用-及其用法"><a href="#16-解释一下call函数和apply函数的作用-及其用法" class="headerlink" title="16.解释一下call函数和apply函数的作用,及其用法"></a>16.解释一下call函数和apply函数的作用,及其用法</h3><blockquote><p><strong>改变对象的内部指针,即改变对象的this指向问题</strong></p><ol><li>call()</li></ol><ul><li>语法:<code>obj1.call(obj2[,param1,param2,...])</code> 定义:用obj2对象代替obj1,并且调用obj1的方法.即将obj1应用到obj2上;</li><li>说明: call方法可以用来代替另一个对象调用一个方法,call方法可将一个函数的对象上下文从初始的上下文改变为由obj2指定的新对象,扩充对象的能力</li></ul><ol start="2"><li>apply()</li></ol><ul><li>语法: <code>obj1.call(obj2[,arrArg])</code>,定义：用obj2对象来代替obj1，调用obj1的方法，即将obj1应用到obj2上，说明：call ()和apply()作用一样，但是call()可以接收任何类型的参数，而apply()只能接收数组参数。</li></ul></blockquote><h3 id="17-作用域与执行上下文的区别"><a href="#17-作用域与执行上下文的区别" class="headerlink" title="17.作用域与执行上下文的区别"></a>17.作用域与执行上下文的区别</h3><ol><li>对应的创建和产生的时间:作用域是函数被定义的时候产生的,执行上下文是函数被调用,代码执行之前</li><li>活动状态:作用域是静态的,定义好了就一直存在,且不会发生变化,上下文环境是动态的,函数调用的时候创建,函数调用结束时,被释放.</li><li>从属关系:执行上下文环境,从属于所在的作用域</li></ol><h3 id="18-为什么会存在函数名-变量名提升"><a href="#18-为什么会存在函数名-变量名提升" class="headerlink" title="18.为什么会存在函数名,变量名提升?"></a>18.为什么会存在函数名,变量名提升?</h3><ul><li>就是在执行上下文的预处理,在执行全局数据或者局部数据之前,对全集数据进行预处理,比如var定义的全局变量==&gt;undefined,添加为window的属性</li></ul><h3 id="19-执行下上文"><a href="#19-执行下上文" class="headerlink" title="19.执行下上文"></a>19.执行下上文</h3><ul><li>代码分类(位置)<ul><li>全局代码</li><li>函数(局部)代码</li></ul></li><li>执行全局上下文<ul><li>在执行全局代码前,将window确定全局执行上下文对象</li></ul></li><li>对全局数据进行预处理,<ul><li>var定义的全局变量==&gt;undefined,添加为window的属性</li><li>function声明的全局函数,==&gt;赋值(fun),添加为window的方法</li><li>this==&gt;赋值(window)</li></ul></li><li><p>开始执行全局代码</p></li><li><p>函数执行上下文</p><ul><li>在调用函数,准备执行函数体之前,创建对应的函数执行上下文对象.(存在于栈中,虚拟的).</li><li>对局部数据进行预处理<ul><li>形参变量赋值为实参, ==&gt;添加为执行上下文的属性.</li><li>arguments==&gt;赋值(实参列表)==&gt;添加为执行上下文的属性.</li><li>var定义的局部变量==&gt;undefined,==&gt;添加为执行上下文的属性.</li><li>function声明的函数==&gt;赋值(fun)==&gt;添加为执行上下文的方法.</li><li>this==&gt;(赋值)调用函数的对象.</li></ul></li><li>调用函数(次数),window.导致产生执行上下文栈 (后进先出).数据进行预处理</li></ul></li><li><p>在js代码执行前,js引擎就会创建一个栈来管理所有的执行上下文对象(虚拟的)</p></li><li>在全局执行上下文(window)创建后,将其添加上到栈中</li><li>在当函数执行完后,将栈顶的对象移出(出栈)</li><li>当所有代码执行完毕后,栈中只剩下window</li></ul><h3 id="20-实例与对象的区别"><a href="#20-实例与对象的区别" class="headerlink" title="20.实例与对象的区别"></a>20.实例与对象的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var person = new Object();</span><br><span class="line">var person = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>通过new object创建的对象,可以称之为object的实例</li><li>第二个采用对象字面量的形式生成的person也是如此.</li><li>但是他没有调用new object(),而是通过JSON()初始化的方式</li><li>将现有的引用指向person</li><li>对象与实例的区别<ul><li>实例是对象的具象化产品</li><li>而对象是一个具有多种属性的内容结构.</li><li>实例都是对象,但是对象不全部是实例</li></ul></li><li>实例与对象的区别总结: </li></ul><ol><li>实例是对象的具体化产品,而对象是一个具有多种属性的内容结构.</li><li>实例一定是对象,但是对象不全都是实例.</li></ol><h3 id="21-继承问题"><a href="#21-继承问题" class="headerlink" title="21.继承问题"></a>21.继承问题</h3><blockquote><p><strong>object</strong>构造函数模式</p><ul><li>套路:先创建一个空的object对象,再动态的添加属性/方法</li><li>使用场景:起始不太确定对象内部数据</li><li>语句太多</li></ul></blockquote><blockquote><p><strong>对象字面量模式</strong></p><ul><li>套路:使用{}创建对象,同时指定属性/方法</li><li>使用场景:起始时,对象内部数据是确定的,适用于创建单个对象</li><li>问题:如果创建多个对象,有重复代码,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var user = &#123;</span><br><span class="line">name: &apos;张三&apos;,</span><br><span class="line">age: 30,</span><br><span class="line">say:function () &#123;</span><br><span class="line">alert(&apos;hello,world!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>工厂创建模式</strong></p><ul><li>套路:通过工厂函数动态创建对象并返回</li><li>使用场景:需要创建多个对象</li><li>问题:对象没有一个具体的类型.都是Object类型 (区分不开类型)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name, age, job)&#123;</span><br><span class="line">var o = new Object();</span><br><span class="line">o.name = name;</span><br><span class="line">o.age = age;</span><br><span class="line">o.job = job;</span><br><span class="line">o.sayName = function()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p><strong>自定义构造函数模式</strong></p><ul><li>套路:自定义构造函数,通过new创建对象</li><li>使用场景:需要创建多个类型创建的对象</li><li>问题:每个对象都要相同的数据,浪费内存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.job = job;</span><br><span class="line">// this在此时无法知道指向谁,必须等到调用的时候才确定</span><br><span class="line">this.sayName = function()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 如果使用关键词new,那么this指向 创建出来的实例对象本身</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br></pre></td></tr></table></figure></li></ul></blockquote><p><strong>组合使用构造函数模式和原型模式</strong></p><ul><li>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式</li><li><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age, job)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">this.job = job;</span><br><span class="line">this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">constructor : Person,</span><br><span class="line">sayName : function()&#123;</span><br><span class="line">alert(this.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</span><br><span class="line">person1.friends.push(&quot;Van&quot;);</span><br><span class="line">alert(person1.friends); //&quot;Shelby,Count,Van&quot;</span><br><span class="line">alert(person2.friends); //&quot;Shelby,Count&quot;</span><br></pre></td></tr></table></figure></li><li><p>好处:每个实例都有自己的一份实例属性的副本,但是同时又共享着对方法的引用,最大限度地节省了内存.这种混成模式还支持向构造函数传递参数,可谓是集两种模式之长</p></li></ul><p><strong>区别:</strong></p><ul><li>没有显示的创建对象</li><li>没有直接将属性和方法赋值给this对象</li><li>没有return语句</li><li><p>创建自定义构造函数意味着将来可以将它的实例标识为一种特定的类型,而这正是构造函数模式胜过工厂模式的地方</p></li><li><p>要创建Person的新实例,必须使用new操作符.以这种方式调用构造函数会经历以下四个步骤</p></li></ul><ol><li>创建一个新对象</li><li>将构造函数作用域赋值给新对象(因此this就指向了这个对象)</li><li>执行构造函数中的代码(为这个新对象添加属性)</li><li>返回新对象</li></ol><h3 id="22-检测数据类型的方法"><a href="#22-检测数据类型的方法" class="headerlink" title="22.检测数据类型的方法"></a>22.检测数据类型的方法</h3><ul><li>typeof 只能检测基本数据类型,对于复杂数据类型,都是object</li><li>insaneof 用来检测对象的类型,返回值为布尔值</li></ul><h3 id="23-TCP-IP-HTTP的区别"><a href="#23-TCP-IP-HTTP的区别" class="headerlink" title="23.TCP/IP HTTP的区别"></a>23.TCP/IP HTTP的区别</h3><ul><li>TPC/IP协议是传输层协议,主要解决数据如何在网络中传输.而HTTP是应用层协议，主要解决如何包装数据。</li><li>可以这样理解,我们在传输数据时,可以只使用(传输层)TCP/IP协议,但是那样的话,如果没有应用层协议,便无法识别数据,如果想要使传输的数据有意义，则必须使用到应用层协议，WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上.</li><li>术语TCP/IP代表传输控制协议/网际协议,把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等.</li><li>TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。</li><li>HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议.客户端使用web浏览器发起HTTP请求给web服务器.Web服务器发送被请求的信息给客户端</li></ul><h3 id="24-前端要注意哪些SEO"><a href="#24-前端要注意哪些SEO" class="headerlink" title="24.前端要注意哪些SEO"></a>24.前端要注意哪些SEO</h3><ul><li>合理的title、description、keyword:搜索对三项的权重逐一减小,title值注意递减,重要关键词不要超过两次,而且靠前,不同页面title要有所不同,description把页面内容高度概括,长度合适,不可过分堆砌关键词,不同页面description有所不同,keywords列举出重要关键词即可</li><li>语义化html代码,符合W3C规范,语义化代码让搜索引擎容易理解网页,</li><li>重要html代码放在最前,搜索引擎抓取html是从上到下的,有的搜索引擎对抓取长度有限制,保证重要内容一定被抓取</li><li>重要内容不要用js输出,爬虫不会执行js获取内容</li><li>少用iframe:搜索引擎不会抓取iframe中的内容</li><li>非装饰性img必须加alt</li><li>提高网站速度:网站速度是搜索引擎排序的一个重要指标</li></ul><h3 id="25-img的title和alt有什么区别"><a href="#25-img的title和alt有什么区别" class="headerlink" title="25.img的title和alt有什么区别"></a>25.img的title和alt有什么区别</h3><ul><li>alt是img特有的标签,是图片内容的等价描述,用于图片无法加载时显示、读屏器阅读图片,提供图片可访问性,搜索引擎会重点分析</li></ul><h3 id="26-从在浏览器地址输入url到页面显示的步骤"><a href="#26-从在浏览器地址输入url到页面显示的步骤" class="headerlink" title="26.从在浏览器地址输入url到页面显示的步骤"></a>26.从在浏览器地址输入url到页面显示的步骤</h3><ol><li>浏览器根据请求的URL交给(域名系统)DNS域名解析,找到真实的IP,向服务器发起请求;</li><li>服务器交给后台处理完成后返回数据,浏览器接收文件(html,js,css,图像等);</li><li>浏览器对加载到的资源(html,css,js等),进行语法解析,建立相应的的内部数据结构(如html的DOM)</li><li>载入解析到的资源文件,渲染页面,完成</li></ol><h3 id="27-如何进行网站的性能优化"><a href="#27-如何进行网站的性能优化" class="headerlink" title="27.如何进行网站的性能优化"></a>27.如何进行网站的性能优化</h3><p><strong>content方法</strong></p><ol><li>减少http请求:合并文件,css精灵图片,inline image</li><li>减少DNS查询:DNS缓存,将资源分布到恰当数量的主机名</li><li>减少DOM元素数量</li></ol><p><strong>service</strong></p><ol><li>使用CDN</li><li>配置ETag</li><li>对组件使用Gzip压缩</li></ol><p><strong>css</strong></p><ol><li>将样式表放到页面顶部</li><li>不使用css表达式</li><li>使用link不适用@import(为什么?)</li></ol><p><strong>javascript</strong></p><ol><li>将脚本放到页面底部</li><li>将javascript和css从外引入</li><li>压缩javascript和css</li><li>删除不需要的脚本</li><li>减少DOM访问</li></ol><p><strong>图片方面</strong></p><ol><li>优化图片,根据实际情况需要选择色深,压缩</li><li>优化css精灵</li><li>不要在html中拉伸图片</li></ol><h3 id="新增-移动端性能优化"><a href="#新增-移动端性能优化" class="headerlink" title="(新增)移动端性能优化"></a>(新增)移动端性能优化</h3><ol><li>尽量使用css3动画,开启硬件加速</li><li>适当使用touch事件来替代click事件</li><li>避免使用css3渐变阴影</li><li>不滥用float,float在渲染时计算量较大,尽量减少使用,</li></ol><h3 id="28-HTTP状态码及其含义"><a href="#28-HTTP状态码及其含义" class="headerlink" title="28.HTTP状态码及其含义"></a>28.HTTP状态码及其含义</h3><ul><li><p>1XX:信息状态码</p><ul><li>100 continue继续,一般在post请求时,已发送了http header之后服务端将返回此信息,表示确认,之后发送具体参数信息</li></ul></li><li><p>2XX:成功状态码</p><ul><li>200 ok正常返回信息</li><li>201 created请求成功并且服务器创建了新的资源</li><li>202 Accepted 服务器已接受请求,但是尚未处理</li></ul></li><li><p>3XX:重定向</p><ul><li>301 Moved Permanently 请求的网页已永久移动到新位置。</li><li>302 Found     临时性重定向。</li><li>303 See Other  临时性重定向,且总是使用 GET 请求新的 URI。</li><li>304 Not Modified 自从上次请求后，请求的网页未修改过。</li></ul></li><li>4XX: 客户端错误<ul><li>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li><li>401 Unauthorized 请求未授权。</li><li>403 Forbidden 禁止访问。</li><li>404 Not Found 找不到如何与 URI 相匹配的资源。</li></ul></li><li>5XX: 服务器端错误<ul><li>500 Internal Server Error 最常见的服务器端错误。</li><li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）</li></ul></li></ul><h3 id="29-说说你对语义化的理解"><a href="#29-说说你对语义化的理解" class="headerlink" title="29.说说你对语义化的理解"></a>29.说说你对语义化的理解</h3><ul><li>说通俗一点就是让正确的标签做正确的事</li><li>html的语义化就是让页面内容结构化,便于浏览器和搜索引擎解析</li><li>并且在没有css样式下也是一种文档格式显示,并且是容易阅读的</li><li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重,利于SEO.</li><li>让阅读源代码的人对网站更容易将网站分块,便于阅读维护理解</li></ul><h3 id="30-谈谈你对浏览器内核的理解"><a href="#30-谈谈你对浏览器内核的理解" class="headerlink" title="30.谈谈你对浏览器内核的理解"></a>30.谈谈你对浏览器内核的理解</h3><ul><li>主要分为两个部分: 渲染引擎和js引擎</li><li><strong>渲染引擎</strong>: 负责取得网页的内容(html,xml,图像),整理讯息(例如加入css等),以及计算网页的显示方式,然后输出至显示器或打印器.浏览器的内核的不同对于网页的语法解释也不同,所以渲染出来的效果也不同.所有的网页路浏览器,电子邮件客户端以及它需要编辑,显示网页内容的应用程序都需要内核</li><li><strong>js引擎</strong>: 解析和执行javascript来实现网页的动态效果</li><li>最开始渲染引擎和js引擎并没有区分的很明确.后来js引擎越来越独立,内核就倾向于只渲染引擎</li></ul><h3 id="31-html5有哪写新特性-移除了哪写内容"><a href="#31-html5有哪写新特性-移除了哪写内容" class="headerlink" title="31.html5有哪写新特性,移除了哪写内容?"></a>31.html5有哪写新特性,移除了哪写内容?</h3><ul><li>主要是关于图像,位置,存储,多任何等功能的增加<ul><li>绘画canvas</li><li>用于媒介回放的video和audio元素</li><li>本地离线存储localStorage长期存储数据,浏览器关闭后数据不会丢失</li><li>sessionStorage的数据在浏览器关闭后会自动删除</li><li>语义化更好的内容元素:article,footer,header,nav,section</li><li>表单控件,calendar,date,time,email,url,search</li></ul></li><li><p><strong>移出的元素</strong></p><ul><li>纯表现的元素:basefont,big,center,font,s,strike,</li><li>对可用性产生负面影响的元素:frame,frameset,noframes</li></ul></li><li><p>支持HTML5新标签</p><ul><li>IE8/IE7/IE6支持通过docuemnt.creatElement方法产生的标签</li><li>可以利用这一特性让这些浏览器支持html5新标签</li><li>浏览器支持新标签后,还需要添加标签默认的样式</li></ul></li></ul><h3 id="32-浏览器怎么对HTML5的离线存储资源进行管理和加载的呢"><a href="#32-浏览器怎么对HTML5的离线存储资源进行管理和加载的呢" class="headerlink" title="32.浏览器怎么对HTML5的离线存储资源进行管理和加载的呢?"></a>32.浏览器怎么对HTML5的离线存储资源进行管理和加载的呢?</h3><ul><li><p>在线的情况下,浏览器发现html头部有mainfest属性,它请求mainfest文件,如果是第一次访问app,那么浏览器会根据mainfest文件的内容,下载相应资源并且进行离线存储.如果已经访问过app并且资源已经离线下载存储了,那么浏览器就会使用离线的资源加载页面,然后浏览器会对比新的mainfest文件与旧的mainfest文件,如果文件没有变化,就不做任何操作,如果文件改变了,那么重新下载文件中的资源,并进行离线存储。</p></li><li><p>离线的情况下，浏览器就直接使用离线存储的资源</p></li></ul><h3 id="33-iframe-有些缺点"><a href="#33-iframe-有些缺点" class="headerlink" title="33.iframe 有些缺点?"></a>33.iframe 有些缺点?</h3><ul><li>iframe会阻塞主页面的Onload事件</li><li>索引引擎的检索程序无法解读这种页面,不利用seo</li><li>iframe和主页面共享连接池,而浏览器对相同域的连接有限制,所以会影响页面的并行加载</li><li>使用iframe之前需要考虑这两个缺点,如果要使用iframe,最好是通过javscript动态给iframe添加src属性值,这样可以绕开这两个问题</li><li>注意:什么是并行下载?<ul><li>同一时间,针对同一域名下的请求,一般情况下,ifame和所在页面在同一个域下面,而浏览器的并行加载的数量是有限的</li></ul></li></ul><h3 id="34-WEB标准以及W3C标准是什么"><a href="#34-WEB标准以及W3C标准是什么" class="headerlink" title="34.WEB标准以及W3C标准是什么?"></a>34.WEB标准以及W3C标准是什么?</h3><ul><li>标签闭合,标签小写,不乱嵌套,使用外链css和js,结构行为表现分离</li></ul><h3 id="35-XHTML和-HTML有什么区别"><a href="#35-XHTML和-HTML有什么区别" class="headerlink" title="35.XHTML和 HTML有什么区别?"></a>35.XHTML和 HTML有什么区别?</h3><ul><li>一个是功能上的差别<ul><li>主要是XHTML可兼容各大浏览器,手机以及PDA,并且浏览器也能快读解析编译网页</li></ul></li><li>另一个是书写习惯的差别<ul><li>XHTML元素必须被正确的嵌套,闭合,区分大小写,文档必须拥有根元素</li></ul></li></ul><h3 id="36-DocType作用-严格模式与混杂模式如何区分-它们有何意义"><a href="#36-DocType作用-严格模式与混杂模式如何区分-它们有何意义" class="headerlink" title="36.DocType作用?严格模式与混杂模式如何区分?它们有何意义?"></a>36.DocType作用?严格模式与混杂模式如何区分?它们有何意义?</h3><ul><li>页面被加载时,link会同时被加载,而@import页面被加载时,link会同时被加载,而@import引用的css会等到页面被加载完再加载</li><li>@import只有ie5以上才能被识别,而link是XHTML标签,无需考虑兼容问题</li><li>link是XHTML标签,无需考虑兼容问题.</li><li>link支持使用javascript控制DOM改变样式</li><li>link方式的样式的权重高于@import的权重</li><li>&lt;!doctype&gt;声明位于文档中的最前面,处于<code>&lt;html&gt;</code>标签之前,告知浏览器解析器,用什么文档类型来解析这个文档</li><li>严格模式的排版和js运行模式是以该浏览器支持的最高标准运行</li><li>在混杂模式中,页面以宽松的向后兼容的方式显示,模拟老浏览器的行为防止站点无法工作,DocType不存在或格式不正确会导致文档以混杂模式呈现</li></ul><h3 id="37-行内元素有哪些-块状元素有哪些-空-viod-元素有哪些-行内元素和块级元素有什么区别"><a href="#37-行内元素有哪些-块状元素有哪些-空-viod-元素有哪些-行内元素和块级元素有什么区别" class="headerlink" title="37.行内元素有哪些?块状元素有哪些?空(viod)元素有哪些?行内元素和块级元素有什么区别?"></a>37.行内元素有哪些?块状元素有哪些?空(viod)元素有哪些?行内元素和块级元素有什么区别?</h3><ul><li>行内元素有:a b span img  input select</li><li>块状元素: div ul ol li  dl dt dd  h1 h2 h3</li><li>空元素: br hr img  input  link meta</li><li>行内元素对宽高无效,不独占一行</li><li>块状元素可以设置宽高,独占一行</li></ul><h3 id="38-html全局属性-global-attribute-有哪些"><a href="#38-html全局属性-global-attribute-有哪些" class="headerlink" title="38.html全局属性(global attribute)有哪些?"></a>38.html全局属性(global attribute)有哪些?</h3><ul><li>class: 为元素设置标识</li><li>data-*:为元素增加自定义属性</li><li>draggable: 设置元素是否可拖拽</li><li>id:元素id,文档内唯一</li><li>lang:元素内容的语言</li><li>style:行内css样式</li><li>title:元素相关的建议信息</li></ul><h3 id="39-Canvas和SVG有什么区别"><a href="#39-Canvas和SVG有什么区别" class="headerlink" title="39.Canvas和SVG有什么区别"></a>39.Canvas和SVG有什么区别</h3><ul><li>svg绘制出来的每一个图形的元素都是独立的DOM节点,能够方便的绑定事件或用来修改.canvas输出的一整幅画布</li><li>svg输出的图形是矢量图形,后期可以修改参数来自由方法缩小,不会是真和锯齿</li><li>而canvas输出标量画布,就像一张图片一样,放大会失真或者锯齿</li></ul><h3 id="如何实现浏览器内多个标签页的通信"><a href="#如何实现浏览器内多个标签页的通信" class="headerlink" title="如何实现浏览器内多个标签页的通信"></a>如何实现浏览器内多个标签页的通信</h3><p><strong>方法一</strong></p><ul><li>localstorage在一个标签页里被添加,修改,删除的的时候,都会触发另一个标签页里监听storage事件, 即可得到localstorage存储的值,实现不同标签之间的通信</li></ul><p><strong>方法二</strong></p><ul><li>使用cookie+setinterval,将需要传递的信息存储在cookie中,每隔一定事件读取cookie信息,即可随时获取要传递的信息</li></ul><h3 id="https和http有别区别-有何灵活使用"><a href="#https和http有别区别-有何灵活使用" class="headerlink" title="https和http有别区别?有何灵活使用?"></a>https和http有别区别?有何灵活使用?</h3><ul><li><p>超文本传输协议HTTP协议,被应用于Web浏览器和网站服务器之间传递信息,HTTP协议以<em>明文方式</em>发送内容,不提供任何方式的<em>数据加密</em>,如果攻击者截取了Web浏览器和网站服务器之间的传输报文,就可以直接读懂其中的信息,因为,http协议不适合传输一些敏感信息,比如,支付密码,信用卡号等支付信息</p></li><li><p>为了解决HTTP协议这一缺陷,需要使用另一种协议:HTTPS,为了数据传输的安全,HTTPS在HTTP的基础上加入了SSL协议,SSL协议本身依靠证书来验证网站服务器的身份,并在Web浏览器和网站服务器之间的通信加密</p></li></ul><h3 id="HTTP和HTTPS的基本概念"><a href="#HTTP和HTTPS的基本概念" class="headerlink" title="HTTP和HTTPS的基本概念"></a>HTTP和HTTPS的基本概念</h3><ul><li><p>HTTP:是互联网上应用最广泛的一种网络协议,是一个客户端和服务器端请求和应答的标准TCP,用于从WWW服务器传输超文本到本地浏览器的传输协议,它可以使浏览器更加高效,使网络传输减少</p></li><li><p>HTTPS:是以安全为目标的HTTP通道,简单讲是HTTP安全版,即HTTP下加入SSL层,HTTPS的安全基础是SSL,因此加密的详细内容就需要SSL</p></li></ul><h3 id="https和http有别区别"><a href="#https和http有别区别" class="headerlink" title="https和http有别区别"></a>https和http有别区别</h3><ol><li>https协议需要用到ca申请证书,一般免费证书较少,因而需要一定的费用</li><li>http是超文本传输协议,信息是明文传输,https则是具有安全性的SSL加密传输协议</li><li>使用完全不同的连接方式,用的端口也不一样,前者的是80,后者是443</li><li>http的连接很简单,是无状态的.HTTPS协议是由SSL+http协议构建的可进行加密传输,身份认证的的网络协议,比http协议安全</li></ol><h3 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h3><ul><li>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤</li></ul><ol><li>客户端使用https的URL访问Web服务器,要求与Web服务器建立SSL连接</li><li>web服务器端响应客户端的请求,会将网站的证书信息(证书中包含公钥)传送一份给客户端</li><li>客户端的浏览器与Web服务器开始协商SSL连接的安全等级,也就是信息加密的等级</li><li>客户端浏览器根据双方同意的安全等级,建立会话密钥,然后利用网站提供的公钥,将会话密钥加密,并传给网站</li><li>Web服务器利用自己的私钥解密出会话密钥.</li><li>Web服务器利用会话密钥会话加密双方的通信</li></ol><h3 id="HTTPS缺点"><a href="#HTTPS缺点" class="headerlink" title="HTTPS缺点:"></a>HTTPS缺点:</h3><ol><li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li><li>HTTPS连接缓存不如HTTP高效,会增加数据开销和功耗,甚至已有的安全措施也会因此受到影响</li><li>SSL证书需要钱,功能越强大的证书,费用越高</li></ol><h3 id="px和em-rem的区别"><a href="#px和em-rem的区别" class="headerlink" title="px和em rem的区别"></a>px和em rem的区别</h3><ul><li>px表示像素(计算机屏幕上的一个点:1px=1/96pin,是绝对单位,不会因为其他元素的尺寸变化而变化)</li><li>em表示相对于父元素的字体大小.em是相对单位,没有一个固定的度量值,而是由其他元素尺寸来决定的相对值</li><li>rem是css3新增的一个相对单位,这个单位有em有什么区别?</li><li>区别在于使用<em>rem</em>为元素设定字体大小时,仍是相对大小,但相对的只是HTML根元素(font-size计算值的倍数).通过它可以做到只修改根元素就成比例地调整所有字体大小.</li><li>目前除了IE8及更早的版本,所有浏览器均支持<em>rem</em></li></ul><h3 id="Rem布局原理"><a href="#Rem布局原理" class="headerlink" title="Rem布局原理"></a>Rem布局原理</h3><ul><li>rem布局的本质是等比缩放</li><li>举个列子</li><li>如果我们设计稿的宽度是600px,移动设备是600px,此时设置的html的font-size=设备宽度/设计稿宽度*100=100px,那么1rem= 100px,此时一个盒子的宽度为width=1rem(即100px),此时这个盒子屏占比为:1/6.</li><li>移动设备/设计稿宽度  是渲染效果相对设计稿的缩放比</li><li>然后  移动设备 / 设计稿宽度 * 100   乘以100是为了把font-size(=rem)放大100倍，因为当font-size小于浏览器支持最小字体大小的时候，浏览器会把fon-size默认为最小字体大小。也可以乘以其他值如50，但是为了好计算，一般设置为10或100，</li></ul><p><em>如何设置html的font-size大小</em></p><ul><li>例如：设计稿为720px；当设备大于720px时，渲染比例1:1，当小于720px时，按照相应的比例缩小.</li></ul><h3 id="对标签有什么理解"><a href="#对标签有什么理解" class="headerlink" title="对标签有什么理解"></a>对<meta>标签有什么理解</h3><ul><li>meta标签提供关于HTML文档的元数据,它不直接出现在页面上,但是对于机器可读的.可用于浏览器(如何显示内容或者重新加载页面),搜索引擎(关键词),或其他Web服务</li><li>meta里的数据是供机器解读的,告诉机器该如何解析这个页面,还有一个用途是可以添加发送到浏览器的http头部内容</li></ul><h3 id="请你写出你对闭包的理解-并列出简单的解释"><a href="#请你写出你对闭包的理解-并列出简单的解释" class="headerlink" title="请你写出你对闭包的理解,并列出简单的解释"></a>请你写出你对闭包的理解,并列出简单的解释</h3><ul><li>使用闭包主要是为了设计私有的方法和变量.闭包的有点是可以避免全局变量被污染,缺点是闭包常驻内存,会增大内存的使用量,使用不当会造成内存泄漏</li><li>闭包的是三个特性</li></ul><ol><li>函数嵌套函数</li><li>函数内部会引用函数外部的参数和变量</li><li>内部的参数和变量不会被垃圾回收机制回收</li></ol><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><p><strong>JSONP</strong></p><ul><li>原理:动态插入script标签,通过script标签引入一个js文件,这个js文件载入成功后会执行我们在url参数中指定的函数,并且会把我们需要的json数据作为参数传入</li></ul><h3 id="谈谈你对ES6的理解"><a href="#谈谈你对ES6的理解" class="headerlink" title="谈谈你对ES6的理解"></a>谈谈你对ES6的理解</h3><ul><li>新增了模板字符串(为javascript提供了简单的字符串插值功能)</li><li>箭头函数(操作符左边为参数,右边则是进行的操作以及返回的值)</li><li>提供了promise对象,提供了原生的promise对象.</li><li>增加了let和const命名,用来声明变量.增加了块级作用域</li><li>引入了module模块的概念</li></ul><h3 id="对前端工程师的这个职位的理解是怎么样的-它的前景怎么样"><a href="#对前端工程师的这个职位的理解是怎么样的-它的前景怎么样" class="headerlink" title="对前端工程师的这个职位的理解是怎么样的?它的前景怎么样?"></a>对前端工程师的这个职位的理解是怎么样的?它的前景怎么样?</h3><ul><li>前端是最贴近用户的程序员,比后端,数据库,产品经理,运营,安全都接近</li></ul><ol><li>实现界面交互</li><li>提升用户体验</li><li>有了node.js前端可以实现服务端的一些事情</li></ol><ul><li>参与项目,快速高质量的完成实现效果图,精确到1px</li><li>与团队成员,ui设计,产品经理沟通</li><li>做好页面结构,页面重构,和用户体验</li><li>处理hack,兼容,写出优美的代码格式</li><li>针对服务器优化,拥抱最新前端技术</li></ul><h3 id="href与src的区别"><a href="#href与src的区别" class="headerlink" title="href与src的区别"></a>href与src的区别</h3><ul><li>href表示为超文本引用,在link和a等元素上使用,src表示来源地址,在img,script,iframe等元素上</li><li>src的内容,是页面必不可少的一部分,是引入.href的内容,是与该页面有关联,引用.区别就是引入和引用</li></ul><ol><li>请求资源类型不同</li></ol><ul><li>href是Hypertext Reference的缩写,表示超文本引用,用来建立当前元素和文档之间的链接,常用的标签有link,a</li><li>在请求src资源时会将其指向的资源下载并应用到文档中,常用的有script,img,iframe</li></ul><ol start="2"><li>作用的结果不同</li></ol><ul><li>href用于在当前文档和引用资源之间确定联系</li><li>src用于替换当前内容</li></ul><ol start="3"><li>浏览器的解析方式不同</li></ol><ul><li>若在文档中添加href,浏览器会识别该文档为CSS文件,就会并行下载资源,并且不会停止对当前文档的处理</li><li>当浏览器解析到src,会暂停其他资源的下载和处理,直到将该资源加载,编译,执行完毕,图片和框架等等也是如此,类似于将所指向资源应用到当前内容.</li></ul><h3 id="json的理解"><a href="#json的理解" class="headerlink" title="json的理解"></a>json的理解</h3><ul><li>json(javascript object Nonation)javascript对象表示法</li><li>json存储和交换文本信息的语法.类似于xml</li><li>json比xml更小,更快,更容易解析</li><li><p>这是一种轻量级,基于文本的,可读的格式</p></li><li><p>复合类型的值只能是数组或对象,不能是函数,正则表达式对象,日期对象</p></li><li>简单类型的值只有四种,字符串,数值(必须以十进制表示),布尔值,和null</li><li>字符串必须使用双引号,不能使用单引号</li><li>对象的键名必须放在双引号里面</li><li>数组或对象最后一个成员的后面,不能加逗号</li><li>需要注意的是:空数组和空对象都是合格的json值,null本身也是一个合格的json的值</li></ul><h3 id="同步与异步的区别"><a href="#同步与异步的区别" class="headerlink" title="同步与异步的区别"></a>同步与异步的区别</h3><ul><li><p>同步我的理解就是一种线性执行的方式,执行的流程不能跨越.一般用于流程性比较强的程序,我们做的用户登录功能也是同步处理的,必须用户通过用户名和密码验证才能进入系统的操作</p></li><li><p>异步,是一种并行处理的方式,不必等待一个程序执行完,可以执行其他任务.在程序中异步处理的结果通过是使用回调函数来处理结果.在javascript中实现异步的方式主要有Ajax和H5新增的Web Worker</p></li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><ul><li>盒子模型一共分为两种一种为标准盒子模型,一种为怪异盒子模型</li></ul><ol><li>当我们在头部写了<code>&lt;!Doctype html&gt;</code>的声明的时候,无论在哪种浏览器内核下,盒子模型都会被解析为标准盒子模型即width=content,即我们单独设置的宽度只显示在内容上,比如我设置css样式width:100px这个100px指的就是content的宽度</li></ol><p><strong>总宽度=我们设置的宽度width+padding+border</strong></p><ol start="2"><li>但是在我们没写声明或者声明丢失的时候,部分有IE内核的浏览器则会触发怪异模型(6,7,8) width = content + padding + border<br><strong>总宽度=width</strong></li></ol><ul><li>css3中我们可以通过box-sizing的属性来完成标准或者怪异模式之间的切换</li></ul><ol><li>box-sizing:content-box采用标准模式</li><li>box-sizing:border-box采用怪异模式</li></ol><h3 id="如果后台数据刷新比较频繁-那么前端该怎么展示-有什么解决的办法"><a href="#如果后台数据刷新比较频繁-那么前端该怎么展示-有什么解决的办法" class="headerlink" title="如果后台数据刷新比较频繁,那么前端该怎么展示,有什么解决的办法?"></a>如果后台数据刷新比较频繁,那么前端该怎么展示,有什么解决的办法?</h3><ol><li>ajax短连接:客户端每隔一秒钟发送一次请求,服务器收到请求后会立刻返回结果,不管有没有新数据.</li><li>ajax长连接:客户端发送一次请求,服务器收到请求后查询有没有新数据,直到有新数据或者超时为止,</li></ol><h3 id="vuex有localstorage有什么不同"><a href="#vuex有localstorage有什么不同" class="headerlink" title="vuex有localstorage有什么不同"></a>vuex有localstorage有什么不同</h3><ul><li><p>vuex是vue中的状态管理机制,可以方便组件之间通信的,组件数据共享,一个组件数据的变化会映射到使用这个数据的其他组件上,再说localstorage,而localstorage是本地存储,并且有5M的限制,是将数据存储到浏览器上的方法,一般是在跨页面传递数据的时候使用</p></li><li><p>vuex存的是状态,表示与view对应的数据,存的位置是在内存中</p></li><li><p>loaclstorage是浏览器提供的接口让你存的是文件,存在你电脑的磁盘上,当然页可以把状态存方法在本地</p></li><li><p>vuex管理的是应用于当前运行状态下的一些数据,而storage保存的是由应用告诉浏览器需要保存的数据,区别是网页一刷新,vuex数据没了,storage不受影响</p></li></ul><h3 id="vuex的实现原理是什么"><a href="#vuex的实现原理是什么" class="headerlink" title="vuex的实现原理是什么?"></a>vuex的实现原理是什么?</h3><ul><li>vuex是一种状态管理机制,将全局组件的共享状态抽取出来为一个store.以一个单例模式简单存在,应用任何一个组件中都可以使用,vuex更改state的唯一途径是通过mutation,mutation需要commit触发,action实际触发的是mutation,其中mutation处理同步任务,action处理异步任务</li></ul><h3 id="移动端适配的技术方案"><a href="#移动端适配的技术方案" class="headerlink" title="移动端适配的技术方案"></a>移动端适配的技术方案</h3><ol><li>通过媒体查询的方式即css3的media queries</li></ol><ul><li>media queries的方式可以说是我早期采用的布局方式,它主要通过查询设备的宽度来执行不同的css代码,最终达到界面的配置</li></ul><p><strong>优点</strong></p><ul><li>media可以做到设备像素比的判断,方法简单,成本低,特别是对移动和pc维护同一套代码的时候,目前像bootstarp等框架使用这种方式布局</li><li>图片便于修改,只需要修改css文件</li><li>调整屏幕宽度的时候,不用刷新页面即可响应式展示.</li></ul><p><strong>缺点</strong></p><ul><li>代码量大,不方便维护.</li><li>为了兼顾移动端和PC端各自响应式的展示效果，难免会损失各自特有的交互方式</li></ul><ol start="2"><li>flex弹性布局</li></ol><ul><li>它的viewport是固定,高度定死,宽度自适应,元素都采用px单位</li></ul><ol start="3"><li><p>rem+viewpoint缩放</p></li><li><p>rem方式</p></li></ol><h3 id="图片如何垂直居中-兼容ie8的该怎么做"><a href="#图片如何垂直居中-兼容ie8的该怎么做" class="headerlink" title="图片如何垂直居中,兼容ie8的该怎么做?"></a>图片如何垂直居中,兼容ie8的该怎么做?</h3><ol><li>利用display:table-cell,然后vertical-align:middle,text-align:center</li><li><p>采用背景法<code>background: url(wgs.jpg) no-repeat center center;</code></p></li><li><p>在图片外可以用一个p标签,通过设置line-height使图片垂直居中:</p></li><li><p>flex布局  <code>display: flex;justify-content: center;align-items: center;</code></p></li><li><p>绝对定位加transform</p></li><li><p>只需要将display:table让他成为一个块级表格元素,子元素table-cell使子元素成功表格单元格,然后就像在表格里一样,给子元素加上一个vertical-align:middle,多行文字就可以居中了</p></li></ol><h3 id="Bootstrap和Vue的不同"><a href="#Bootstrap和Vue的不同" class="headerlink" title="Bootstrap和Vue的不同"></a>Bootstrap和Vue的不同</h3><ul><li>特点是栅格系统,专为响应式而生,一套代码就可以自适应平板电脑和PC</li></ul><p><strong>vue特点</strong></p><ol><li>数据的双向绑定,数据改,页面改,页面改,数据改</li><li>页面的呈现据说比React还快</li><li>组件化</li><li>单html开发,它的开发模式,是一个html,然后不停的替换组件对应的js来切换显示效果,理论上</li><li>结合node.js的webpack等,可以形成体系的打包发布</li></ol><h3 id="bootstrap遇到的问题"><a href="#bootstrap遇到的问题" class="headerlink" title="bootstrap遇到的问题?"></a>bootstrap遇到的问题?</h3><p><strong>同一个页面使用多个swiper,多个轮播出现冲突的问题?</strong></p><ul><li>首先可以给swiper-container这个层级的div加多个专属类名,然后分页面或者左右切换的按钮也是如此.</li><li>swiper-container必须是区域的顶层元素,即它应该是body的子元素,而且他的height:100%属性值不能改,否则布局会乱掉</li><li>a链接失效,没有设置一个参数preventClicks,该参数默认为ture,如果需要加入a链接需要设置为false</li></ul><h3 id="前端HTML几种存储方式总结"><a href="#前端HTML几种存储方式总结" class="headerlink" title="前端HTML几种存储方式总结"></a>前端HTML几种存储方式总结</h3><ul><li>h5之前,存储主要是使用cookies.cookies缺点有在请求上带着数据,大小是4k之内,</li><li>主要应用于:购物车,客户登录</li></ul><p><strong>目标</strong></p><ul><li>解决4k大小的问题</li><li>解决请求头常带储存信息的问题</li><li>解决关系型存储问题</li><li>跨浏览器</li></ul><ol><li>本地存储localstorage</li></ol><p><strong>存储方式</strong></p><ul><li>以键值对(key-value)的方式存储,永久存储,永不失效,除非手动删除</li><li>大小:每个域名5M</li><li>注意:IE9 localStorage不支持本地文件,需要将项目部署到服务器上</li></ul><ol start="2"><li>本地存储sessionstorage</li></ol><ul><li>HTML5 的本地存储 API 中的 localStorage 与 sessionStorage 在使用方法上是相同的，区别在于 sessionStorage 在关闭页面后即被清空，而 localStorage 则会一直保存。</li></ul><h3 id="js的运行机制"><a href="#js的运行机制" class="headerlink" title="js的运行机制"></a>js的运行机制</h3><ul><li>javascript是一门单线程语言,</li><li>通过事件循环(event loop机制,就理解了js的执行机制)</li></ul><h3 id="IE9以下版本浏览器兼容css3新属性"><a href="#IE9以下版本浏览器兼容css3新属性" class="headerlink" title="IE9以下版本浏览器兼容css3新属性"></a>IE9以下版本浏览器兼容css3新属性</h3><ul><li>下载ie-css3.htc文件</li><li>导入 </li></ul><h3 id="什么是闭包-为什么要用到它"><a href="#什么是闭包-为什么要用到它" class="headerlink" title="什么是闭包,为什么要用到它?"></a>什么是闭包,为什么要用到它?</h3><ul><li>我的个人理解,闭包就是函数里嵌套的函数,并且内部函数需要访问外部函数的变量,也就是说,外部的变量是这个内部函数的一部分</li></ul><p><strong>闭包的作用</strong></p><ul><li>使用闭包可以访问函数中的变量</li><li>可以使变量长期保存在内存中,生命周期比较长</li><li>注意:闭包不能滥用,否则会导致内存泄漏,影响网页的性能,闭包使用完后,要立即释放资源,将引用变量指向null</li></ul><h3 id="谈谈你对盒子模型的理解"><a href="#谈谈你对盒子模型的理解" class="headerlink" title="谈谈你对盒子模型的理解"></a>谈谈你对盒子模型的理解</h3><ul><li><p>盒子模型有两种,一种是标准盒子模型(w3c盒子模型),一种是怪异盒子模型(ie盒子模型)</p></li><li><p>标准盒子模型包括margin,border,padding,content,元素的width等于content的宽度</p></li><li><p>IE盒子模型与w3c盒子模型的唯一区别就是元素的宽度,元素的width=content+padding+border</p></li><li><p><strong>个人理解</strong>我个人认为w3c盒子模型和ie盒子模型,ie定义的盒子模型比较合理,元素的宽度应该包含border(边框)和padding(填空),这个和我们现实生活的盒子是一样的.w3c也意识到了自己的问题,所以在css3中新增了一个样式box-sizing,包含两个函数content-box和border-box</p></li><li><p><em>content-box</em> 元素的width= content+padding+border</p></li><li><p><em>border-box</em> 元素width=width</p></li><li>加分项:</li></ul><ol><li>对于行内函数来说,margin-top和margin-bottom对于上下元素无效,对于margin-left和margin-right有效</li><li>对于相邻的块级元素,margin-top和margin-bottom的取值方式<ol><li>都是正数:取最大值</li><li>都是负数:取最小值</li><li>上面是正数，下面是负数或者 上面是负数，下面是正数： 正负相加</li></ol></li></ol><h3 id="样式导入有哪些方式"><a href="#样式导入有哪些方式" class="headerlink" title="样式导入有哪些方式"></a>样式导入有哪些方式</h3><p><strong>样式导入的方式</strong></p><ul><li>link</li><li>@import</li></ul><p><strong>不同点</strong></p><ul><li>link除了除了引入样式文件,还可以引入图片等资源文件,而import只引入样式文件</li><li>兼容性不同,link不存在兼容性的问题,import在ie5以上支持</li><li>link引用css时,在页面载入时同时加载,@import需要在网页完全载入以后加载</li><li><p>link支持使用javascript控制DOM去改变样式,而@import不支持</p></li><li><p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</p></li><li>（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</li><li>（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题;</li><li><p>（4）link方式的样式的权重高于@import的权重。</p></li><li><p>加分项</p></li><li>推荐使用 @import url(index.css);</li></ul><h3 id="before和-bofore的区别"><a href="#before和-bofore的区别" class="headerlink" title=":before和::bofore的区别"></a>:before和::bofore的区别</h3><p><strong>相同点</strong></p><ol><li>都可以用来表示伪类对象,用来设置对象前的内容</li><li>:bofore和::before写法是等效的</li></ol><p><strong>不同点</strong></p><ol><li>:before是css2写法,::befoe是css3写法</li><li>:before的兼容性要比::before好 ，不过在H5开发中建议使用::before比较好</li></ol><ul><li>加分项</li><li>伪类对象要配合content属性一起使用</li><li>伪类对象不会出现在dom元素中,所以不能通过js来操作,仅仅在css中渲染层加入</li><li>伪类对象的特效通常要通过使用:hover伪类样式来激活</li></ul><h3 id="css样式的的优先级"><a href="#css样式的的优先级" class="headerlink" title="css样式的的优先级"></a>css样式的的优先级</h3><p><strong>样式优先级规则</strong></p><ul><li>优先级顺序!important&gt;style&gt;权重值</li><li>如果权重相同,则后面定义的样式起效果,但是应该避免这种情况</li></ul><p><strong>权重规则</strong></p><ul><li>标签的权重为1</li><li>class选择器权重为10</li><li>id选择器权重为100</li></ul><h3 id="如何居中一个元素-正常-绝对定位-浮动元素"><a href="#如何居中一个元素-正常-绝对定位-浮动元素" class="headerlink" title="如何居中一个元素(正常,绝对定位,浮动元素)?"></a>如何居中一个元素(正常,绝对定位,浮动元素)?</h3><p><strong>元素水平居中的方式</strong></p><ol><li>行内元素水平居中(父元素设置text-align:center)</li><li>块级元素水平居中(margin:0 auto)</li><li>浮动元素水平居中<br> 当浮动元素宽度不固定的时候<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">.outerbox&#123;</span><br><span class="line">float:left; </span><br><span class="line">position:relative; </span><br><span class="line">left:50%; </span><br><span class="line">&#125; </span><br><span class="line">.innerbox&#123; </span><br><span class="line">float:left; </span><br><span class="line">position:relative; </span><br><span class="line">right:50%;</span><br></pre></td></tr></table></figure></li></ol><p><strong>元素垂直居中对齐</strong></p><ol><li>对行内元素垂直居中对齐,height等于line-height</li><li>对块级元素垂直居中对齐<ul><li>父类元素高度固定的情况下:设置父类盒子高度等于行高,并且把内部盒子转成行内块元素,设置vertical-align:midddle</li><li>在父类元素高度不固定的情况下:父类的padding-top和padding-bottom一样</li></ul></li></ol><h3 id="css样式-display有哪些作用"><a href="#css样式-display有哪些作用" class="headerlink" title="css样式-display有哪些作用"></a>css样式-display有哪些作用</h3><p><strong>元素默认的display值的情况如下:</strong></p><ul><li>block(块级元素)</li><li><p><code>div p ,ul,ol,form</code></p></li><li><p>inline(内联元素)</p></li><li><p><code>span a img input select label....</code></p></li><li><p>list-item(项目列表)</p></li><li><p>li</p></li><li><p>none(不显示,且不占据原来的位置)</p></li><li><p>表格系列方面的显示</p></li><li>table</li><li>table-row</li></ul><h3 id="为什么我们要初始化css样式"><a href="#为什么我们要初始化css样式" class="headerlink" title="为什么我们要初始化css样式?"></a>为什么我们要初始化css样式?</h3><p><strong>初始化样式的原因</strong></p><ul><li>因为浏览器的兼容的问题,不同的浏览器有些标签的默认值是不同的,如果没有css初始化往往会出现浏览器之间的页面显示差异</li><li>注意:初始化样式会对seo有一定的影响,但是鱼和熊掌不可兼得.但是力求在影响最小的情况下实现初始化</li></ul><h3 id="用纯css创建一个三角形的原理是什么"><a href="#用纯css创建一个三角形的原理是什么" class="headerlink" title="用纯css创建一个三角形的原理是什么?"></a>用纯css创建一个三角形的原理是什么?</h3><ul><li>采用均分原理</li><li>保证元素是块级元素</li><li>设置元素的边框</li><li>不需要显示的边框使用<strong>透明色(transparent)</strong></li></ul><h3 id="如何清除元素浮动"><a href="#如何清除元素浮动" class="headerlink" title="如何清除元素浮动?"></a>如何清除元素浮动?</h3><ol><li><p>使用clear:both清除浮动</p><ul><li>使用空的div</li><li>使用br 设置clear=”all”</li><li>在父标签中设置伪类对象::after 设置clear:both,并且在父类标签中设置<code>zoom:1</code></li></ul></li><li><p>使用overflow属性,在父类标签中设置overflow:hidden或者auto都可以</p></li><li><p>使用display属性:设置display:inline-block,要使元素水平居中,在父元素中使用text-align;center(因为行内块元素的高可以靠内容撑起)</p></li><li><p>父元素设置浮动,父元素不能水平居中,可以使用定位</p></li></ol><h3 id="javascript中如何翻转一个字符串"><a href="#javascript中如何翻转一个字符串" class="headerlink" title="javascript中如何翻转一个字符串"></a>javascript中如何翻转一个字符串</h3><ol><li><p>使用字符串函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function reverseString(str) &#123; </span><br><span class="line">     return str.split(&apos;&apos;).reverse().join(&apos;&apos;);;</span><br></pre></td></tr></table></figure></li><li><p>使用for循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function reverseString(str) &#123;   </span><br><span class="line">var newStr=&quot;&quot;;</span><br><span class="line">for(var i=str.length-1;i&gt;=0;i--)&#123;</span><br><span class="line">newStr+=str[i];</span><br><span class="line">&#125;</span><br><span class="line">return newStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="原型是什么-原型链是什么"><a href="#原型是什么-原型链是什么" class="headerlink" title="原型是什么?原型链是什么?"></a>原型是什么?原型链是什么?</h3><ul><li>在javascript中,原型是一个prototype对象,用于表示类型间的关系</li><li>JavaScript万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。</li></ul><h3 id="ajax是什么-如何创建一个ajax"><a href="#ajax是什么-如何创建一个ajax" class="headerlink" title="ajax是什么?如何创建一个ajax?"></a>ajax是什么?如何创建一个ajax?</h3><p><strong>ajax是什么?</strong></p><ul><li>ajax是一种异步请求数据的技术,对于改善用户的体验和程序的性能很有帮助</li></ul><p><strong>ajax的使用</strong></p><ol><li>创建Ajax核心对象XMLHttpRequest</li><li>向服务器发送请求xmlhttp.(method,url,async),send(string)</li></ol><ul><li>注意:open的参数要记牢,method(请求类型get/post),url(文件在服务器上的位置)asnyc(true为异步,false同步)</li><li>注意:send(string)方法post请求时才使用字符串参数,否则不带参数</li><li>注意:post请求一定要设置请求头格式内容</li></ul><ol start="3"><li>服务器响应数据</li></ol><ul><li>responseText获得字符串格式的响应数据</li><li>responseXML获得XML形式的响应数据</li><li>如果是同步处理直接在send()后面处理返回的数据</li><li><p>如果是异步处理则需要在请求状态改变事件中处理onreadystatechange</p></li><li><p><strong>xmlhttp.status:</strong> 响应状态码</p></li><li>200:OK</li><li>403(禁止) 服务器禁止请求</li><li>404(未找到) 服务器未找到请求网页</li><li>408(请求超时) 服务器等候请求时发生超时</li><li>500(服务器内部发生错误) 服务器遇到错误,无法完成请求 </li></ul><h3 id="javascript有几种类型的值-你能画一下他们的内存图吗"><a href="#javascript有几种类型的值-你能画一下他们的内存图吗" class="headerlink" title="javascript有几种类型的值,你能画一下他们的内存图吗?"></a>javascript有几种类型的值,你能画一下他们的内存图吗?</h3><p><strong>两大类</strong></p><ul><li>栈:原始数据类型(undefined,null,boolean,number,string)</li><li>堆:引用数据类型(对象,数组,函数)</li></ul><p><strong>区别:</strong></p><ul><li>两个类型的数据:存储位置不同</li><li>原始数据类型存储在栈(stack)中,占据空间小,大小固定,属于被频繁使用数据.</li><li>引用数据类型存储在堆内存中对象,占据空间大,大小不固定,引用数据在栈中存储了指针,该指针指向堆中该起始的地址.当解释器寻找引用值时,首先会检索其在栈中的地址,然后根据地址值从堆内存中获取相应的数据</li></ul><h3 id="谈谈你对this的理解"><a href="#谈谈你对this的理解" class="headerlink" title="谈谈你对this的理解"></a>谈谈你对this的理解</h3><p><strong>this的指向</strong></p><ul><li>this表示当前执行上下文对象,this的指向是根据调用的上下文对象决定的.默认指向window对象,指向window对象可以省略不写</li><li>调用的上下文环境包括全局和局部</li></ul><p><strong>局部环境</strong></p><ul><li>在全局作用域下直接调用函数,this指向window</li><li>对象函数调用,哪个对象调用就指向哪个对象</li><li>使用new实例化对象,在构造函数中this指向实例化对象</li><li><p>注意:使用apply和call可以改变this的指向</p></li><li><p>加分项:</p></li><li>用于区别全局变量与局部变量,需要使用this</li></ul><h3 id="谈谈你对模块化开发的理解"><a href="#谈谈你对模块化开发的理解" class="headerlink" title="谈谈你对模块化开发的理解"></a>谈谈你对模块化开发的理解</h3><p><strong>什么是模块化</strong></p><ul><li>所谓模块化开发就是封装细节,提供使用接口,彼此之间不受影响,每个模块都是实现某一特定的功能,模块化开发的基础就是函数</li></ul><p><strong>立即执行函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var oj= (function()&#123;</span><br><span class="line">　　　　var _age= 0;</span><br><span class="line">　　　　var func1= function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　var func2= function()&#123;</span><br><span class="line">　　　　　　//...</span><br><span class="line">　　　　&#125;;</span><br><span class="line">　　　　return &#123;</span><br><span class="line">　　　　　　m1 : func1,</span><br><span class="line">　　　　　　m2 : func2</span><br><span class="line">　　　　&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><ul><li>上面的写法:外部代码无法读取内部的age变量</li></ul><h3 id="如何实现浏览器内多个标签间的通信"><a href="#如何实现浏览器内多个标签间的通信" class="headerlink" title="如何实现浏览器内多个标签间的通信?"></a>如何实现浏览器内多个标签间的通信?</h3><p><strong>方法一:使用localstorage</strong> </p><ul><li>使用localstorage.setItem(key,value)添加内容</li><li>使用storage事件监听添加,修改,删除的动作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;storage&quot;,function(event)&#123;</span><br><span class="line">        $(&quot;#name&quot;).val(event.key+”=”+event.newValue);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="new操作符到底干了些什么"><a href="#new操作符到底干了些什么" class="headerlink" title="new操作符到底干了些什么?"></a>new操作符到底干了些什么?</h3><ul><li>new共经历了4个阶段</li></ul><ol><li>创建一个空对象</li><li>设置原型链 (将构造函数的prototype属性赋值给空对象的proto属性),也就是说新对象的proto属性指向构造函数的prototype属性</li><li>让构造函数的this指向新创建的空对象,也就是将作用域赋值给新对象</li><li>执行构造函数内部的代码,将属性添加给新创建的对象</li><li>返回新对象</li></ol><h3 id="浏览器渲染页面过程"><a href="#浏览器渲染页面过程" class="headerlink" title="浏览器渲染页面过程"></a>浏览器渲染页面过程</h3><ol><li>解析HTML文件,创建DOM树<ul><li>浏览器通过HTMLParser(HTML解析器)根据深度遍历的原则把HTML解析成DOM Tree</li><li>自上而下,遇到任何样式(link,style)与脚本(script)都会阻塞(外部样式不阻塞后续外部脚本的加载)</li></ul></li><li>解析css<ul><li>将css解析成css规则树</li><li>每个css文件都被分析成一个Stylesheet对象</li><li>优先级:优先级默认设置</li></ul></li><li>将css与dom合并,构建渲染树</li><li>遍历渲染数,开始布局,计算每个节点的位置大小信息</li><li>布局和绘制,重绘(repaint)和重排(reflow)</li></ol><p><strong>渲染阻塞</strong></p><ul><li>当浏览器遇到一个script标记时,DOM树将暂停,直至脚本执行完毕,然后继续去构建DOM树,每次去执行Javascript脚本都会严重的阻塞DOM树的构建.</li><li>scirpt标签在实际使用时,必须要遵循两个原则<ul><li>CSS优先引入,引入顺序上,CSS文件要先与Javascript资源</li><li>JS置后,我们通过把JS代码放到页面底部,且Javascript应尽量少影响DOM的构建</li></ul></li></ul><h3 id="检测数组的几种方式"><a href="#检测数组的几种方式" class="headerlink" title="检测数组的几种方式"></a>检测数组的几种方式</h3><ul><li>Array.isArray(),只在es6中支持</li><li>toString.call 可以判断对象类型的数据,还可以判断正则</li><li>arr.constructor 使用constructor判断不严谨,因为他是一个可读可写的属性</li><li>instanceof 检测实例对象是否是数组对象的实例</li></ul><h3 id="W3C标准的事件绑定方式"><a href="#W3C标准的事件绑定方式" class="headerlink" title="W3C标准的事件绑定方式"></a>W3C标准的事件绑定方式</h3><ul><li>A.非IE浏览器</li><li>addEventListener(‘click,function(){},true) </li></ul><ol><li>如果说给同一个元素绑定了两次或者多次相同类型,所以的绑定将会依次触发</li><li>支持DOM事件流</li><li>进行事件绑定传参不需要on前缀</li><li>第三个参数默认为true,就是在事件获取阶段执行</li><li>第三个参数为fasle,就是在事件冒泡下进行</li></ol><h3 id="javascript如何实现继承"><a href="#javascript如何实现继承" class="headerlink" title="javascript如何实现继承"></a>javascript如何实现继承</h3><ol><li>原型链继承</li></ol><ul><li>如何让一个构造函数拥有另一个构造函数的属性和方法?</li><li>让这个构造函数的prototype属性指向另一个构造函数.那么它就自动拥有了另一个构造函数对象的属性和方法</li></ul><ol start="2"><li><p>借用构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    this.age = 20;</span><br><span class="line">&#125;</span><br><span class="line">function Cat()&#123;</span><br><span class="line">    this.name = &quot;jacy&quot;</span><br><span class="line">    Animal.call(this); //这一步就让Cat构造函数对象所创建的所有实例对象都自动拥有了Animal构造函数上的所有属性和方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>原型链加构造函数混合继承</p></li></ol><h3 id="javascript同源策略"><a href="#javascript同源策略" class="headerlink" title="javascript同源策略"></a>javascript同源策略</h3><ul><li>一段脚本只能读取来自同一来源的窗口和文档的属性,这里的同一来源指的是主机名,协议和端口号的组合</li><li>协议:http协议,https协议</li><li>主机名:localhost</li><li>端口号:80</li><li>http协议默认端口号:80</li><li>http协议默认端口号:8083</li><li>同源策略带来的麻烦,ajax在不同域名下的请求无法实现</li><li>如果来想要请求其他源的js文件,或者json数据,那么可以通过jsonp来解决</li><li>jsonp的实现原理:通过动态创建script标签127.0.0.1</li></ul><h3 id="Http请求行-请求头-请求体详解"><a href="#Http请求行-请求头-请求体详解" class="headerlink" title="Http请求行,请求头,请求体详解"></a>Http请求行,请求头,请求体详解</h3><p><strong>HTTP请求报文解析</strong></p><ul><li>主要分为请求行,请求头,请求体</li></ul><p><strong>请求行</strong></p><ul><li>包括:<ul><li>请求方法,get,post是最常见的请求方法,</li><li>请求对应的URL地址,它来报头的host属性组成完整的URL,</li><li>还包括HTTP协议名称和版本号</li></ul></li></ul><p><strong>请求头</strong></p><ul><li>包括:<ul><li>包含若干属性,格式为属性名:属性值,服务端据此获取客户端的信息</li></ul></li><li>常见的HTTP请求报文头属性<ul><li>Accept:通过这个报文头属性可以告诉服务器端,客户端接收什么类型的响应</li><li>cookie:客户端的cookie值就是通过这个报文头属性传送给服务器端</li><li>Referer:表示这个请求头从哪个地方过来的,</li><li>Cache-Control: 对缓存进行控制,如果一个请求希望响应返回的数据的在客户端保存一年,或者不希望被保存就可以通过这个属性进行控制</li></ul></li></ul><p><strong>如何访问请求报文头</strong></p><ul><li>由于请求报文头是客户端发送过来的,服务器端当前只能读取了,通过httpservleRequest通过一些提供的api读取数据</li></ul><h3 id="HTTP响应报文解析"><a href="#HTTP响应报文解析" class="headerlink" title="HTTP响应报文解析"></a>HTTP响应报文解析</h3><p><strong>响应报文结构</strong></p><ul><li>响应行,响应头,响应体</li></ul><p><strong>响应行</strong></p><ul><li>报文协议及版本, 状态码描述</li></ul><p><strong>响应状态码</strong></p><ul><li>和请求头相比,响应报文多了一个”响应状态码”,它以”清晰明确”的语言告诉客户端本次请求的处理结果</li><li>1xx消息,一般是告诉客户端,请求已经收到了,正在处理,别急</li><li>2xx处理成功,一般表示:请求收悉,我明白您要的,请求已受理,以及处理完成等信息.</li><li>3xx重定向到其他地方,它让客户端再发起一个请求已完成整个过程</li><li>4xx处理发生错误,责任在客户端,如果客户端发送一个不存在的资源,客户端未被授权,禁止访问等</li><li><p>5xx处理发生错误,责任在服务器端,如服务器端抛出异常,路由出错,或者HTTP版本不支持等</p></li><li><p>列子:</p></li></ul><ol><li>200 OK 你最希望看到的,即处理成功</li><li>303 See Other 我把你redirect到其他页面,目标URL通过响应报文的localtion告诉你</li><li>304 Not Modified 告诉客户端,你请求的这个资源和你上次取得后,并没有发生更改, 你直接用本地的缓存把</li><li>404 Not Found 你最不希望看到的,即找不到页面,</li><li>505 internal Server Error 看到这个错误,你就应该查查服务器端日志</li></ol><p><strong>常见的HTTP响应报文头属性</strong></p><ol><li>Cache-Control</li></ol><ul><li>响应输出到客户端,服务端通过该报文属性告诉客户端如何控制响应内容的缓存</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTML，-HTTP，web综合问题&quot;&gt;&lt;a href=&quot;#HTML，-HTTP，web综合问题&quot; class=&quot;headerlink&quot; title=&quot;HTML， HTTP，web综合问题&quot;&gt;&lt;/a&gt;HTML， HTTP，web综合问题&lt;/h2&gt;&lt;h3 id=&quot;1
      
    
    </summary>
    
      <category term="前端面试" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Sass学习笔记</title>
    <link href="http://yoursite.com/2019/04/13/sass%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/13/sass学习笔记/</id>
    <published>2019-04-13T10:56:39.000Z</published>
    <updated>2019-04-13T12:32:09.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sass学习笔记-sass学习入门"><a href="#Sass学习笔记-sass学习入门" class="headerlink" title="Sass学习笔记,sass学习入门"></a>Sass学习笔记,sass学习入门</h2><h3 id="sass是css预处理器"><a href="#sass是css预处理器" class="headerlink" title="sass是css预处理器"></a>sass是css预处理器</h3><ul><li>sass是基于ruby的,使用sass我们需要安装ruby</li><li>sass和scss其实是同一种东西,我们平时都称之为sass,两者不同之处有以下两点:</li></ul><ol><li>文件扩展名不同，Sass 是以“.sass”后缀为扩展名，而 SCSS 是以“.scss”后缀为扩展名</li><li>语法书写方式不同，Sass 是以严格的缩进式语法规则来书写，不带大括号({})和分号(;)，而 SCSS 的语法书写和我们的 CSS 语法书写方式非常类似。<h3 id="为什么要使用Sass"><a href="#为什么要使用Sass" class="headerlink" title="为什么要使用Sass"></a>为什么要使用Sass</h3></li><li>因为css代码重复利用少,管理起来不方便,而用Sass来写代码可以使代码复用.方便快捷修改,比如要修改整站的某种颜色,只需要修改一个变量即可,</li><li>或者对仅使用过一次的属性值,你可以赋予其一个简单易懂的变量名,让人一眼就知道这个属性值的用途.<h3 id="什么是css-reset"><a href="#什么是css-reset" class="headerlink" title="什么是css reset?"></a>什么是css reset?</h3></li></ol><ul><li>HTML标签在浏览器中都有默认的样式,不同浏览器的默认样式之间存在差别.列入ul默认带有缩进的样式,在IE浏览器中,它的缩进是由margin实现的,而在Firefox下却是由padding实现的,开发时的默认样式可能会给我们带来许多浏览器兼容性的问题,影响开发效率.现在很流行的一种方法就是一开始将浏览器的默认样式全部覆盖掉,这就是CSS reset<h3 id="编译Sass"><a href="#编译Sass" class="headerlink" title="编译Sass"></a>编译Sass</h3></li><li>单文件转换命令<br><code>sass input.scss output.css</code></li><li>单文件监听命令<br><code>sass --watch input.scss:output.css</code></li><li>如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录：<br><code>sass --watch app/sass:public/stylesheets</code></li></ul><h2 id="sass语法"><a href="#sass语法" class="headerlink" title="sass语法"></a>sass语法</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><ul><li>Sass使用$符号来标识变量(老版本使用!符号)比如$<code>sidebar-width</code>;</li><li>为什么选择$符号呢？因为它好认、更具美感，且在CSS中并无他用，不会导致与现存或未来的css语法冲突。<h3 id="css嵌套"><a href="#css嵌套" class="headerlink" title="css嵌套"></a>css嵌套</h3></li><li>父选择器的标识符&amp;<h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3></li><li>导入公共样式</li><li>可以省略.scss后缀<h3 id="原生的css导入"><a href="#原生的css导入" class="headerlink" title="原生的css导入"></a>原生的css导入</h3></li><li>因为sass的语法完全兼容css，所以把原始的css文件改名为.scss后缀，即可直接导入了。</li><li>注意:// 这种注释不会出现在已经生成的css文件中<h3 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h3></li><li>混合器使用@mixin标识符定义.</li><li><p>使用@include引用变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@mixin rounded-corners &#123;</span><br><span class="line">  -moz-border-radius: 5px;</span><br><span class="line">  -webkit-border-radius: 5px;</span><br><span class="line">  border-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">notice &#123;</span><br><span class="line">  background-color: green;</span><br><span class="line">  border: 2px solid #00aa00;</span><br><span class="line">  @include rounded-corners;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li><p>通过选择器继承继承样式(@extend)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.error &#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.seriousError &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意:不要继承后代样式</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Sass学习笔记-sass学习入门&quot;&gt;&lt;a href=&quot;#Sass学习笔记-sass学习入门&quot; class=&quot;headerlink&quot; title=&quot;Sass学习笔记,sass学习入门&quot;&gt;&lt;/a&gt;Sass学习笔记,sass学习入门&lt;/h2&gt;&lt;h3 id=&quot;sass是
      
    
    </summary>
    
      <category term="sass" scheme="http://yoursite.com/categories/sass/"/>
    
    
      <category term="Sass基础语法" scheme="http://yoursite.com/tags/Sass%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue路由基础知识总结</title>
    <link href="http://yoursite.com/2019/04/10/Vue%E8%B7%AF%E7%94%B1/"/>
    <id>http://yoursite.com/2019/04/10/Vue路由/</id>
    <published>2019-04-10T14:16:51.000Z</published>
    <updated>2019-04-15T00:09:50.102Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Vue路由"><a href="#Vue路由" class="headerlink" title="Vue路由"></a>Vue路由</h2><h3 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h3><ul><li><strong>后端路由</strong>: 对于普通网页来说,所有的超链接都是URL地址,所有URL地址都对应服务器上对应的资源</li><li><strong>前端路由</strong>: 对于单页面用户来说,主要通过URL里面的hash(#号)来实现不同页面之间的切换,同时hash有一个特点:HTTP请求中不会包含相关的内容,所有单页面跳转主要用hash实现.在单页面程序中,这种通过hash来实现切换页面的方式,我们称之为前端路由.(区别于后端路由)</li></ul><h3 id="URL里面的hash有什么特点"><a href="#URL里面的hash有什么特点" class="headerlink" title="URL里面的hash有什么特点?"></a>URL里面的hash有什么特点?</h3><ul><li>思考这个问题…</li></ul><h3 id="router-routes-route之间的区别与联系"><a href="#router-routes-route之间的区别与联系" class="headerlink" title="router,routes,route之间的区别与联系"></a>router,routes,route之间的区别与联系</h3><ol><li>route,它是一条路由,由这个英文单词也可以看出来，它是单数， Home按钮  =&gt; home内容， 这是一条route,  about按钮 =&gt; about 内容， 这是另一条路由。</li><li>routes 是一组路由，把上面的每一条路由组合起来，形成一个数组。[{home 按钮 =&gt;home内容 }， { about按钮 =&gt; about 内容}]</li><li>router 是一个机制，相当于一个管理者，它来管理路由。因为routes 只是定义了一组路由，它放在哪里是静止的，当真正来了请求，怎么办？ 就是当用户点击home 按钮的时候，怎么办？这时router 就起作用了，它到routes 中去查找，去找到对应的 home 内容，所以页面中就显示了 home 内容。</li><li>路由的执行过程:当用户点击router-link标签时,会去寻找它的to属性,它的to属性和js中配置的路径(path:’/home’,component:Home)path一一对应,从而找到了组件,最后把组件渲染到了<code>&lt;router-view&gt;</code>标签所在的地方.所有的这些实现才是基于hash实现的</li></ol><h3 id="使用路由的基本步骤"><a href="#使用路由的基本步骤" class="headerlink" title="使用路由的基本步骤"></a>使用路由的基本步骤</h3><ol><li>安装路由模块,导入后自动拥有hash路由,可以在网站上显示看到#</li><li>创建一个组件模板对象</li><li>创建一个路由实例对象,当导入vue-router包之后,在window全局对象中,就有了一个路由构造器<ul><li>其中在new路由对象的时候,可以为构造函数,传递一个配置对象</li><li>这个配置对象实际就是路由匹配规则的意思</li><li>每个路由规则都是一个对象,这个规则对象中有两个必须的属性</li><li>path表示监听,拦截路由的地址</li><li>component表示,根据path拦截到对应的路由匹配地址,则展示对应当前路由地址的component组件</li><li>注意:component属性值必须是一个组件模板对象,而不能是组件的引入名称</li></ul></li><li>通过router属性,将路由规则对象注册到vm实例上,用来监听URL地址的变化,展示对应的组件.</li><li>组件需要在页面中展示,就需要Vue提供的router-view相当于一个标签属性,我们可以把它当做一个占位符.将来根据路由规则匹配到的组件,就会展示在这个router-view</li><li>router-link 默认渲染a标签 (tag可以改变展示的标签)</li></ol><h3 id="vue使用params-query传参的区别"><a href="#vue使用params-query传参的区别" class="headerlink" title="vue使用params,query传参的区别"></a>vue使用params,query传参的区别</h3><p><strong>params</strong>：/router1/:id ，/router1/123，/router1/789 ,这里的id叫做params</p><p><strong>query</strong>：/router1?id=123 ,/router1?id=456 ,这里的id叫做query。</p><ul><li>区别一: 路由设置这里,<strong>当你使用params方法传参时,要在路由后面加参数名</strong>,并且传参的时候,参数名要跟路由后面的设置的参数名对应,使用query方法，就没有这种限制，直接在跳转里面用就可以.</li><li>注意:如果路由上不写参数,也是可以传过去的,但是不会在URL上显示出你的参数,并且当你跳转到其他页面或者刷新页面的时候参数会丢失.那依赖的这个参数的http请求,或者其他的操作就会失败.</li><li>区别二:<strong>params一旦设置在路由上</strong>,params就是路由的一部分,如果这个路由有params传参,但是在跳转的时候,没有传这个参数,会导致跳转失败或者页面会没有内容.</li></ul><h3 id="push传参的三种方法及与replace的区别"><a href="#push传参的三种方法及与replace的区别" class="headerlink" title="push传参的三种方法及与replace的区别"></a>push传参的三种方法及与replace的区别</h3><ul><li>除了使用除了使用 <router-link> 创建 a 标签来定义导航链接,我们还可以借助 router 的实例方法,通过编写代码来实现. $router.push可以实现路由的跳转,这个方法会向 history 栈添加一个新的记录,所以,当用户点击浏览器后退按钮时,则回到之前的URL.</router-link></li><li>当你点击的时候,这个方法会在内部调用,所以说,点击<code>&lt;router-link :to=&quot;…&quot;&gt;</code> 等同于调用router.push(…).</li></ul><ol><li>第一种形式:字符串<code>this.$router.push(&#39;/about&#39;)</code></li><li>第二种形式:对象<code>this.$router.push({path:&#39;/about&#39;})</code></li><li>第三种形式:命名的路由,也是传入一个对象,如果一个路由有name属性.params跳转到某个详情页<code>this.$router.push({name:&#39;about&#39;})</code>在跳转到某个详情页的时候,还需要给parmas属性传入一个对象,对象里面包含详情页的内容.</li><li>总结: 由于动态路由也是传递params的,所以在this.$router.push()方法中path不能和params一起使用,否则params无效,需要使用name来指定页面,也就是说,除了path我们也可以使用路由的name属性来实现跳转页面</li><li>replace会将之前访问的路由替换成要跳转的路由.但是导航并不会留下history记录,即使点击返回按钮也不会回到页面,加上replace为true后,它不会向history添加新记录,而是跟它的方法名一样—替换掉当前的history记录.</li><li>params中保存的是一个对象类型的数据,里面存有路由路径中参数.</li></ol><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><ul><li><p>我们常常需要把某种匹配模匹配到所有的路由,全部映射到同一个组件中。例如,我们有同一个User组件,对于所有ID各不相同的用户,都要使用这个组件来渲染.那么,我们可以在vue-router的路由路径中使用动态路径参数(dynamic segment)来达到这个效果.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    // 动态路径参数 以冒号开头</span><br><span class="line">    &#123; path: &apos;/user/:id&apos;, component: User &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>/user/foo和/user/bar都将映射到相同的路由</p></li><li>一个路径参数使用:标记,当匹配一个路由时,参数值会被设置到{this.$router.params},可以在每个组件内使用,于是我们可以更新user模板,输出当前用户的ID.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const User = &#123;</span><br><span class="line">  template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h3><ul><li>注意: 当使用路由参数时,例如从/user/bar导航到/user/foo,<strong>原来的组件将会被复用</strong>,因为两个路由都同时渲染同一个组件.比起销毁再创建,复用则显得效率更高效,不过这也意味着组件的生命周期钩子不会再被调用.复用组件的时候,如果想对路由参数的变化做出响应的话.你可以简单的watch:$route对象</li></ul><h3 id="路由注意事项"><a href="#路由注意事项" class="headerlink" title="路由注意事项"></a>路由注意事项</h3><p><strong>注意:exact-active与active的区别</strong><br>    exact是当前真正匹配的那个路由,active是匹配到exact路由经过的那个路由<br>    比如说 要匹配北京新闻详情里的路由,必须要经过上一个北京路径的这个路由</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Vue路由&quot;&gt;&lt;a href=&quot;#Vue路由&quot; class=&quot;headerlink&quot; title=&quot;Vue路由&quot;&gt;&lt;/a&gt;Vue路由&lt;/h2&gt;&lt;h3 id=&quot;路由的概念&quot;&gt;&lt;a href=&quot;#路由的概念&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Vue路由" scheme="http://yoursite.com/categories/Vue%E8%B7%AF%E7%94%B1/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="路由" scheme="http://yoursite.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础语法一</title>
    <link href="http://yoursite.com/2019/04/10/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%80/"/>
    <id>http://yoursite.com/2019/04/10/Vue基础语法一/</id>
    <published>2019-04-10T14:14:31.000Z</published>
    <updated>2019-04-15T12:17:09.986Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Vue基础之Vue模板语法"><a href="#Vue基础之Vue模板语法" class="headerlink" title="Vue基础之Vue模板语法"></a>Vue基础之Vue模板语法</h2><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ul><li>数据绑定最常见的的形式就是使用Mustache语法(双大括号)的文本插值,双大括号会将数据解析成纯文本<br><code>&lt;span&gt;Message:&lt;/span&gt;</code></li><li>如果Mustache标签将会被替代为对应数据对象上的msg属性的值.无论何时,绑定的数据对象上的msg属性发生了变化,</li><li>插值处的内容都会更新</li></ul><h3 id="纯HTML"><a href="#纯HTML" class="headerlink" title="纯HTML"></a>纯HTML</h3><ul><li>双大括号会将数据解释为纯文本,而非 HTML.为了输出真正的HTML,你需要使用v-html指令<br><code>&lt;div v-html=&quot;rawHtml&quot;&gt;&lt;/div&gt;</code></li><li>此时被插入的内容都会被当做HTML–数据绑定会被忽略<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3></li><li>Vue允许你自定义过滤器,来实现一些常见的文本格式化功能.过滤器应该被添加上mustache插值尾部,由”管道符”标识起来<br><code></code></li><li>过滤器可以串联</li><li>过滤器是javascript函数,因此可以接受参数<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3></li><li>指令是带有(Directives)是带有v-前缀的特殊属性,指令属性的值预期是单一javascript表达式(除了v-for,之后再讨论).指令的职责就是当其表达式的值时,相应的将某些行为应用到DOM上<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3></li><li>一些指令只能接受一个参数,在指令后以冒号指明,例如v-bind指令被用来更新HTML属性<br><code>&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</code></li><li>在这里href是参数,告知v-bind指令将该元素的href属性与表达式url值绑定<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3></li><li>修饰符(Modifiers)是以半角句号.指明的特殊后缀,用于指出一个指令应该以特殊方法绑定</li></ul><p><strong>事件修饰符</strong></p><ul><li>我们还可以使用事件修饰符(Event Modifer):<ul><li>.stop 阻止冒泡事件</li><li>.prevent 阻止默认事件</li><li>.capture  阻止捕获事件</li><li>.once 执行一次</li></ul></li></ul><h3 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h3><p><strong>1.声明式</strong></p><ul><li>只需要声明在哪里(where)做什么(what),不用关心如何使用(how)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//使用es6的map方法,关注如何取值</span><br><span class="line">//将原数组（arr）中利用map函数，传入每一项</span><br><span class="line">        var arrNew = arr.map(function (item) &#123;</span><br><span class="line">            return item*2</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>2.命令式</strong></p><ul><li>需要具体代码表达在哪里(where)做什么(what),如何实现(how)</li><li>命令式:使用for循环拿出每一项,然后计算完成后,再放到另一个数中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//定义一个新的空数组，然后利用for循环，每一步每一步地放入其中</span><br><span class="line">     var arrNew = [];</span><br><span class="line">       for (var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">           arrNew.push(arr[i]*2);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Vue指令"><a href="#Vue指令" class="headerlink" title="Vue指令"></a>Vue指令</h3><p><strong>什么是指令</strong></p><ul><li>是一种特殊的自定义行间属性(也就是在html标签内书写),指令的职责就是当其表达式的值发生改变的时候相应的将某些行为应用到DOM上,在Vue中,指令以v开头<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v-bind：动态绑定数据。简写为“:” 。=&gt; 以后的:class=&quot;&#123;red:boolean&#125;&quot;</span><br><span class="line">v-on ：绑定时间监听器。简写为“@”，例：@click=&quot;xxx&quot;；</span><br><span class="line">v-text ：更新数据，会覆盖已有结构。类似&#123;&#123; msg &#125;&#125; ；</span><br><span class="line">v-show ：根据值的真假，切换元素的display属性；</span><br><span class="line">v-if ：根据值的真假，切换元素会被销毁、重建； =&gt; 在dom中已消失</span><br><span class="line">v-else-if ：多条件判断，为真则渲染；</span><br><span class="line">v-else ：条件都不符合时渲染；</span><br><span class="line">v-for ：基于源数据多次渲染元素或模块；</span><br><span class="line">v-model ：在表单控件元素（input等）上创建双向数据绑定（数据源）；</span><br><span class="line">v-pre ：跳过元素和子元素的编译过程；</span><br><span class="line">v-once ：只渲染一次，随后数据更新也不重新渲染；</span><br><span class="line">v-cloak ：隐藏未编译的Mustache语法，在css中设置[v-cloak]&#123;display:none;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Vue模板"><a href="#Vue模板" class="headerlink" title="Vue模板"></a>Vue模板</h2><h3 id="1-html模板"><a href="#1-html模板" class="headerlink" title="1.html模板"></a>1.html模板</h3><ul><li>html模板:基于DOM的模板,模板都是可解析的有效的HTML</li></ul><p><strong>插值</strong></p><ul><li><p><strong>文本</strong>:使用Mustache语法(大括号)作用,替换上实例上的属性值,当值改变时,插值内容就会被自动更新.也可以使用v-text=”value”代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; value &#125;&#125;&lt;p&gt; 等价于 &lt;p v-text=&quot;value&quot;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>原生的html</strong>：双大括号输出的文本，不会解析html标签。也就是说当实例的data为html标签时，不能解析而是直接输出出来。此时如想要解析，可使用v-html=”value”代替.</p></li><li><p><strong>属性</strong>：使用v-bind进行绑定，可以响应变化。<br></p><h2 :class="{red:show}">标题</h2> =&gt; 注意此处的show为data内的一个布尔值数据，若真则添加red的class，若假则移除red的class<p></p></li><li><p><strong>使用javascript表达式</strong>：可以写简单的表达式。（可以简单的三目运算，但是不可以写if语句），以后会有计算属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; 1+2 &#125;</span><br><span class="line">&#123; true? &quot;yes&quot;:&quot;no&quot; &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-字符串模板"><a href="#2-字符串模板" class="headerlink" title="2.字符串模板"></a>2.字符串模板</h3><p><strong>template字符串</strong></p><blockquote><p>tempalte =&gt; 选项对象的属性</p><ul><li>模板将会*<em>替换</em>挂载的元素.挂载元素的内容都会被忽略,根节点只有一点,将html结构写在一堆script标签中</li></ul></blockquote><p><strong>数据对象属性</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class: &#123;&#125;,  =&gt;  绑定class，和v-bind:class一样的API</span><br><span class="line">style: &#123;&#125;,  =&gt;  绑定样式，和v-bind:style一样的API</span><br><span class="line">attrs: &#123;&#125;,  =&gt;  添加行间属性</span><br><span class="line">domProps: &#123;&#125;,  =&gt;   DOM元素属性</span><br><span class="line">on: &#123;&#125;,  =&gt;  绑定事件</span><br><span class="line">nativeOn: &#123;&#125;,  =&gt;  监听原生事件</span><br><span class="line">directives: &#123;&#125;,  =&gt;  自定义指令</span><br><span class="line">scopedSlots: &#123;&#125;,  =&gt;   slot作用域</span><br><span class="line">slot: &#123;&#125;,  =&gt;   定义slot名称  和组件有关系，插曹</span><br><span class="line">key: &quot;key&quot;,  =&gt;   给元素添加唯一标识</span><br><span class="line">ref: &quot;ref&quot;,  =&gt;   引用信息</span><br></pre></td></tr></table></figure></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><strong>1. 注册全局指令-所有人都可以使用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">      &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;div v-color=&quot;colorStatus&quot;&gt;我是一个普通的div元素&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./node_modules/vue/dist/vue.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      document.addEventListener(&apos;DOMContentLoaded&apos;,function () &#123;</span><br><span class="line">          Vue.directive(&apos;color&apos;,function (el,binding) &#123;//指令名称注意不要加**v-**</span><br><span class="line">              console.log(el);//当前绑定自定义指令的元素，可以用来直接操作DOM</span><br><span class="line">              console.log(binding);//一些参数，常用的  =&gt; binding.value（指令的值） </span><br><span class="line">              el.style.backgroundColor = &apos;lawngreen&apos;;</span><br><span class="line">          &#125;)</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &apos;.app&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                colorStatus: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,false);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p><strong>2.注册局部指令—当前组件下可用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">      &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">        &lt;div v-color=&quot;colorStatus&quot;&gt;我是一个普通的div元素&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;script src=&quot;./node_modules/vue/dist/vue.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      document.addEventListener(&apos;DOMContentLoaded&apos;,function () &#123;</span><br><span class="line">        var vm = new Vue(&#123;</span><br><span class="line">            el: &apos;.app&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                colorStatus: true</span><br><span class="line">            &#125;,</span><br><span class="line">            directives:&#123; </span><br><span class="line">                &apos;color&apos;:function (el,binding) &#123;</span><br><span class="line">                    el.style.backgroundColor = &apos;lawngreen&apos;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,false);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br></pre></td></tr></table></figure></p><ul><li><strong>注意</strong>: 选项对象的directives属性注意此处有个s</li></ul><h3 id="计算数据-计算属性"><a href="#计算数据-计算属性" class="headerlink" title="计算数据(计算属性)"></a>计算数据(计算属性)</h3><p><strong>为什么要使用计算属性</strong></p><ul><li>模板是未来描述视图的结构,在模板中放入太多的逻辑,会导致模板过重难以维护</li><li>在计算一个计算属性时,Vue.js更新它的依赖列表并缓存结果,只有当其中一个发生了变化,缓存的结果才无效</li></ul><h3 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h3><p><strong>1.什么是组件</strong></p><ul><li>WEB中的组件其实就是在页面组成的一部分,好比是电脑中的每一个原件(如硬盘,键盘.鼠标)它是一个具有独立逻辑的功能或页面,同时又能根据规定的接口规则进行相互融合,变成一个完整的应用</li></ul><p><strong>2.使用组件的好处</strong></p><ol><li>提供效率</li><li>方便重复使用</li><li>简化调试步骤</li><li>提升整个项目的可维护性</li><li>便于协同开发</li></ol><p><strong>3.组件的特性</strong></p><ol><li>高内聚性,组价功能必须是完整的,如我要实现下拉菜单的功能,那在下拉菜单这个组件中,就把下拉菜单的所有功能全部实现</li><li>低耦合性,通俗点说,代码独立不会和项目中的代码发生冲突!在实际工程,我们经常会涉及到团队协作,传统按业务线去编写代码的方式,就很容易相互发生冲突,运用组件化可以大大减低避免这种冲突的存在</li><li>每个组件都有自己清晰的职责,完整的功能,较低的耦合便于单元测试和重复利用</li></ol><p><strong>4.Vue的组件</strong></p><ul><li>vue的组件是一定自定义标签(元素),Vue.js的编译器为它添加特殊功能,vue也可以拓展原生的html元素,封装可重用的代码</li><li>样式结构,行为逻辑,数据三大组成元素</li></ul><h3 id="SASS函数功能实现PX转REM"><a href="#SASS函数功能实现PX转REM" class="headerlink" title="SASS函数功能实现PX转REM"></a>SASS函数功能实现PX转REM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$baseFontSize:100 //函数</span><br><span class="line">@function px2rem($px)&#123;</span><br><span class="line">    @return $px/baseFontsize*rem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Vue基础之Vue模板语法&quot;&gt;&lt;a href=&quot;#Vue基础之Vue模板语法&quot; class=&quot;headerlink&quot; title=&quot;Vue基础之Vue模板语法&quot;&gt;&lt;/a&gt;Vue基础之Vue模板语法&lt;/h2&gt;&lt;h3 id=&quot;插值&quot;
      
    
    </summary>
    
      <category term="Vue基础语法" scheme="http://yoursite.com/categories/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue计算属性</title>
    <link href="http://yoursite.com/2019/04/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/10/Vue计算属性/</id>
    <published>2019-04-10T03:47:37.000Z</published>
    <updated>2019-04-11T00:01:58.626Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p> <strong>1.计算属性的特点</strong></p><ul><li>1.可以对属性数据进行逻辑操作</li><li>2.对计算属性中的数据进行监视,也就是被计算的属性如果被修改,那计算属性后的结果就是被修改后再计算的结果.</li><li>3.计算属性依赖于响应式中的数据,可以当做作为data数据中的修饰符,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        msg:&quot;hello vue!&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        msgReverse:function()&#123;</span><br><span class="line">            return this.msg.split(&quot; &quot;).reverse().join(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">调用方法：&#123;&#123;msgReverse&#125;&#125;  //vue hello</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-computed计算属性VSmethods内的方法"><a href="#2-computed计算属性VSmethods内的方法" class="headerlink" title="2.computed计算属性VSmethods内的方法"></a>2.computed计算属性VSmethods内的方法</h3><ul><li>计算属性的get函数，如果使用methods内的方法，也可以达到同样的效果，那我们为何要使用计算属性呢？</li><li>他们之间的的区别<ol><li>计算属性是依赖于被计算的数据,只有当这个数据改变的时候,计算属性才会改变</li><li>计算属性是有缓存的,如果计算的那个数据没有发生改变,无论你访问多少次,计算属性返回的值依旧是之前计算的值</li></ol></li></ul><pre><code>var vm = new Vue({    el: &quot;#app&quot;,    data:{        num:8    },    computed:{        getNum:function(){            console.log(new Date());    // Wed Feb 27 2019 13:00:42 GMT+0800 (中国标准时间)            return this.num+1;         // 9        }    },    methods:{        getNum2:function(){            console.log(new Date());    // Wed Feb 27 2019 13:00:42 GMT+0800 (中国标准时间)            return this.num+1;         // 9        }    }})// 模拟多次访问计算属性，每次结果都一样，new Date()的值也被缓存了，没有发生改变setInterval(function(){    console.log(vm.getNum);     // Wed Feb 27 2019 13:00:42 GMT+0800 (中国标准时间)                                // 9},1000)// 模拟多次访问methods内的方法，new Date()每次结果都在发生改变，没有被缓存setInterval(function(){    console.log(vm.getNum2());     // （ new Date的值一直在变化 ）                                // 9},1000)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;计算属性&quot;&gt;&lt;a href=&quot;#计算属性&quot; class=&quot;headerlink&quot; title=&quot;计算属性&quot;&gt;&lt;/a&gt;计算属性&lt;/h2&gt;&lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="Vue基础语法" scheme="http://yoursite.com/categories/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>es6常用数组操作及总结</title>
    <link href="http://yoursite.com/2019/04/10/es6%E5%B8%B8%E7%94%A8%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/10/es6常用数组操作及总结/</id>
    <published>2019-04-10T01:01:48.000Z</published>
    <updated>2019-04-15T00:17:13.757Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ol><li><code>array.filter(callback[, thisArg]);</code></li></ol><ul><li>filter是一个常用的数组操作,它用于将Array的不符合条件的元素过滤出来,返回由符合条件元素组成的新列表</li><li>和map()类似,filter也接收一个函数,和map()不同的是,filter()把传入的函数一次作用于每个元素,然后根据返回值是true还是flase决定保留还是丢弃该元素.</li><li>filter()接收的是一个回调函数,通常我们只使用它的第一个参数,表示Array的某个元素,表示元素的位置和元素本身.</li></ul><p><strong>filter的几种用法</strong></p><ul><li><p>创建一个数组，判断数组中是否存在某个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var newarr = [</span><br><span class="line">  &#123; num: 1, val: &apos;ceshi&apos;, flag: &apos;aa&apos; &#125;,</span><br><span class="line">  &#123; num: 2, val: &apos;ceshi2&apos;, flag: &apos;aa2&apos;  &#125;</span><br><span class="line">]</span><br><span class="line">console.log(newarr.filter(item =&gt; item.num===2 ))</span><br></pre></td></tr></table></figure></li><li><p>去掉空数组空字符串、undefined、null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;1&apos;,&apos;2&apos;,undefined, &apos;3.jpg&apos;,undefined]</span><br><span class="line">var newArr = arr.filter(item =&gt; item)</span><br><span class="line">console.log(newArr)</span><br><span class="line"></span><br><span class="line">var arr = [&apos;1&apos;,&apos;2&apos;,null, &apos;3.jpg&apos;,null]</span><br><span class="line">var newArr = arr.filter(item =&gt; item)</span><br><span class="line">console.log(newArr)</span><br><span class="line"></span><br><span class="line">&gt;//空字符串里面不能包含空格</span><br><span class="line">var arr = [&apos;1&apos;,&apos;2&apos;,&apos;&apos;, &apos;3.jpg&apos;,&apos;&apos;]</span><br><span class="line">var newArr = arr.filter(item =&gt; item)</span><br><span class="line">console.log(newArr)</span><br></pre></td></tr></table></figure></li><li><p>去掉数组中不符合项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [20,30,50, 96,50]</span><br><span class="line">var newArr = arr.filter(item =&gt; item&gt;40)  </span><br><span class="line">console.log(newArr)</span><br></pre></td></tr></table></figure></li><li><p>过滤不符合项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;10&apos;,&apos;12&apos;,&apos;23&apos;,&apos;44&apos;,&apos;42&apos;]</span><br><span class="line">var newArr = arr.filter(item =&gt; item.indexOf(&apos;2&apos;)&lt;0) </span><br><span class="line">console.log(newArr)</span><br></pre></td></tr></table></figure></li><li><p>数组去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7,8,8,0,8,6,3,4,56,2];</span><br><span class="line">var arr2 = arr.filter((x, index,self)=&gt;self.indexOf(x)===index) //indexof可以返回每个指定字符串在字符串中出现的位置</span><br><span class="line">console.log(arr2); //[1, 2, 3, 4, 5, 6, 7, 8, 0, 56]</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>array.map(callback[, thisArg]);</li></ol><ul><li>返回一个新数组,新数组中每个元素都是调用callback函数后返回的结果,</li><li>在实际使用的时候,我们可以利用map方法以便利的获取对象中的特定的属性值</li><li>注意:array.map由于不具有过滤的功能，因此array调用map函数时，如果array中的数据并不是每一个都会return，则必须先filter，然后再map，即map调用时必须是对数组中的每一个元素都有效。<figure class="highlight plain"><figcaption><span>maped </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``` maped: [&apos;aac&apos;, &apos;bbc&apos;];**</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>array.includes(searchElement, fromIndex);</li></ol><ul><li>inlcludes()方法用来判断一个数组是否包含一个指定的值,返回true或者false.searchElement要查找的元素,fromIndex开始查找的索引的位置<br><code>[1, 2, 3].includes(2, 2);  // false</code></li></ul><ol start="4"><li>array.findIndex(callback[, thisArg]);</li></ol><ul><li>返回通过callback函数测试的第一个元素的索引，否则返回-1，callback函数定义同上。<br><code>const findIndex = [1, 2, 3].findIndex(element =&gt; element &gt; 1);  // findIndex: 1</code></li></ul><ol start="5"><li>array.find(callback[, thisArg]);</li></ol><ul><li>返回通过callback函数测试的第一个元素，否则返回undefined，callback函数定义同上。<br><code>const finded = [1, 2, 3].find(element =&gt; element &gt; 1); // finded: 2</code></li></ul><ol start="6"><li>array.slice(begin, end)</li></ol><ul><li>返回一个新数组，包含原数组从begin 到 end(不包含end)索引位置的所有元素。<br><code>const newArray = [&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;].slice(1, 3);   // newArray: [&#39;one&#39;, &#39;two&#39;];</code></li></ul><ol start="7"><li>array.splice(start[, deleteCount, item1, item2, …]);</li></ol><ul><li>通过删除现有元素和/或添加新元素来更改一个数组的内容.start指定修改的开始位置.deleteCount:从start位置开始要删除的元素个数;要添加进数组的元素,从start位置开始.</li><li>注意:返回值是由被删除数组组成的数组,如果只删除了一个元素,则返回只包含一个元素的数组.如果没有删除元素,则返回空数组.</li><li>如果deleteCount大于start之后的元素的总数.则从start后面的元素都将被删除(含start).<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const myFish = [&apos;angel&apos;, &apos;clown&apos;, &apos;mandarin&apos;, &apos;sturgeon&apos;];</span><br><span class="line">const deleted = myFish.splice(2, 0, &apos;drum&apos;); // 在索引为2的位置插入&apos;drum&apos;</span><br><span class="line">// myFish 变为 [&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;sturgeon&quot;]，deleted为[]</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li>array.concat(array1, array2,…arrayN);</li></ol><ul><li>合并多个数组,返回合并后的数组,原数组没有变化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const array = [1,2].concat([&apos;a&apos;, &apos;b&apos;], [&apos;name&apos;]);</span><br><span class="line">// [1, 2, &quot;a&quot;, &quot;b&quot;, &quot;name&quot;]</span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>array.pop() </li></ol><ul><li>pop为从数组中删除最后一个元素</li><li>参数:无</li><li>返回值:被删除的项</li><li>是否改变原数组:改变</li><li>数组为空时返回undefined。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].pop();</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure></li></ul><ol start="10"><li>Array.shift()</li></ol><ul><li>作用: 删除数组的第一个元素,</li><li>返回值:返回被删除的元素。</li><li>是否改变原数组:改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const shifted = [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;].shift();</span><br><span class="line">// shifted: &apos;one&apos;</span><br></pre></td></tr></table></figure></li></ul><ol><li>array.push(element1, element2, ….elementN) 与 array.unshift(element1, element2, …elementN);</li></ol><ul><li>push是将一个或多个元素添加到数组的末尾，并返回新数组的长度; unshift将一个或多个元素添加到数组的开头，并返回新数组的长度。唯一的区别就是插入的位置不同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3];</span><br><span class="line">const length = arr.push(4, 5);</span><br><span class="line">// arr: [1, 2, 3, 4, 5]; length: 5</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;常用方法&quot;&gt;&lt;a href=&quot;#常用方法&quot; class=&quot;headerlink&quot; title=&quot;常用方法&quot;&gt;&lt;/a&gt;常用方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;array.filter(callback[, thisArg]
      
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Vue基础语法二</title>
    <link href="http://yoursite.com/2019/04/08/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%BA%8C/"/>
    <id>http://yoursite.com/2019/04/08/Vue基础语法二/</id>
    <published>2019-04-08T12:45:47.000Z</published>
    <updated>2019-04-14T01:29:17.895Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>简单来说,假如父组件需要在子组件内放一些DOM,那么这些DOM是显示,不显示,在那些地方显示,如何显示,就是插槽(slot)分发负责的活</p></blockquote><p><strong><em>注意:父组件在子组件内套的内容,是不显示的</em></strong></p><h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><blockquote><p>slot就是占位符,用于展示在组件标签内部显示的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;  </span><br><span class="line">    &lt;children&gt;  </span><br><span class="line">        &lt;span&gt;12345&lt;/span&gt;  </span><br><span class="line">        &lt;!--上面这行不会显示--&gt;  </span><br><span class="line">    &lt;/children&gt;  </span><br><span class="line">&lt;/div&gt;  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">    var vm = new Vue(&#123;  </span><br><span class="line">        el: &apos;#app&apos;,  </span><br><span class="line">        components: &#123;  </span><br><span class="line">            children: &#123;    //这个无返回值，不会继续派发  </span><br><span class="line">                template: &quot;&lt;button&gt;为了明确作用范围，所以使用button标签&lt;/button&gt;&quot;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="单个slot"><a href="#单个slot" class="headerlink" title="单个slot"></a>单个slot</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;  </span><br><span class="line">    &lt;children&gt;  </span><br><span class="line">        &lt;span&gt;12345&lt;/span&gt;  </span><br><span class="line">        &lt;!--上面这行不会显示--&gt;  </span><br><span class="line">    &lt;/children&gt;  </span><br><span class="line">&lt;/div&gt;  </span><br><span class="line">&lt;script&gt;  </span><br><span class="line">    var vm = new Vue(&#123;  </span><br><span class="line">        el: &apos;#app&apos;,  </span><br><span class="line">        components: &#123;  </span><br><span class="line">            children: &#123;    //这个无返回值，不会继续派发  </span><br><span class="line">                template: &quot;&lt;button&gt;&lt;slot&gt;&lt;/slot&gt;为了明确作用范围，所以使用button标签&lt;/button&gt;&quot;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>这样写结果是:<code>&lt;button&gt;&lt;span&gt;12345&lt;/span&gt;</code>为了明确作用范围，所以使用button标签<code>&lt;/button&gt;</code>即父组件入到子组件的内容,插入到了子组件的<code>&lt;slot&gt;&lt;/slot&gt;</code></li><li>注意即使有多个标签,也会被一起插入,相当于用父组件插入子组件里的标签,替换了<code>&lt;slot&gt;&lt;/slot&gt;</code><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote><p>指将放入子组件里的不同html标签放在不同的位置(也就是不同的插槽内)</p></blockquote></li><li>父组件要在分发的标签里添加v-slot:name属性</li><li>子组件要在对应的分发位置的slot标签里添加name = name属性</li><li>然后就会将对应的标签放置在对应的位置上了</li><li>注意:slot不能当做组件的根元素使用,v-slot只用在组件中使用.</li><li>只要出现多个插槽，请始终为所有的插槽使用完整的基于<code>&lt;template&gt;</code>的语法</li></ul><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><blockquote><p>组件标签 的内容中的 变量 获取的是当前组件调用者的 作用域的变量</p><ul><li>父级模板里所有的内容都是在父级作用域中编译的,子级模板里的所有内容都是在子作用域中编译的.</li></ul></blockquote><h3 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h3><blockquote><p>slot可以设置后备内容</p><ul><li>后备内容指的就是默认内容,它只会在没有提供内容的时候被渲染,它被放在slot标签内部.</li><li>如果在父组件中使用并且提供内容,那个这个提供的内容将会被渲染并取代后备内容</li></ul></blockquote><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote><p>如何在组件内部的slot对应的组件外部内容中访问到组件内部的变量. 换句话说如何把组件内部的变量,通过slot在外部进行装饰.</p><ul><li>我们可以将user作为一个<slot>元素的特性绑定上去,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;slot v-bind:user=&quot;user&quot;&gt;</span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></slot></li></ul></blockquote><ul><li>绑定在<slot>元素上的特性被称为插槽prop.现在在父级作用域中,我们也可以给v-slot带一个值来定义我们插槽prop的名字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;current-user&gt;</span><br><span class="line">  &lt;template v-slot:default=&quot;abc&quot;&gt;</span><br><span class="line">    &#123;&#123; abc.user.firstName &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure></slot></li></ul><h2 id="动态组件-异步组件"><a href="#动态组件-异步组件" class="headerlink" title="动态组件/异步组件"></a>动态组件/异步组件</h2><ul><li>keep-alive</li><li>‘my-component’: () =&gt; import(‘./my-async-component’)</li></ul><h2 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h2><ol><li>父组件调用子组件</li></ol><ul><li>组件时可以复用的,父组件找到子组件的唯一方法是给子组件取名字(使用ref)</li><li>然后调用方法时,在父组件方法中通过this.$refs.(子组件名)就可以找到子组件,并且使用它</li></ul><ol start="2"><li>孙子及以下节点找父组件</li></ol><ul><li>调用自身的方法打印this.$root就是顶级父组件对象</li></ul><ol start="3"><li>孩子组件找父组件</li></ol><ul><li>调用自身的方法打印this.$parent就是父组件对象</li></ul><h3 id="访问组件"><a href="#访问组件" class="headerlink" title="访问组件"></a>访问组件</h3><ul><li>访问根实例 $root</li><li>访问父级组件实例 $parent</li><li>访问子组件实例或子元素 $refs.xx</li></ul><h2 id="过渡-动画"><a href="#过渡-动画" class="headerlink" title="过渡/动画"></a>过渡/动画</h2><ul><li>v-enter  过渡的开始状态,在元素被插入之前生效</li><li>v-enter-active 定义进入过渡生效的状态,在整个过渡阶段应用,在元素被插入之前生效</li><li>v-enter-to  定义进入过渡的结束状态</li><li>v-leave   定义离开过渡的开始状态</li><li>v-leave-active 定义离开过渡生效的状态</li><li>v-leave-to 定义离开过渡的结束状态</li><li>注意: 需要使用vue提供的transiton标签把要进行过渡的元素包裹起来。</li></ul><h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><blockquote><p>可以复用的代码块,在组件引入可以把混合的对象合并到当前组件.</p><ul><li>通过使用mixins属性并且通过数组的形式引入要被混合的对象引入到当前组件</li></ul></blockquote><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><blockquote><p>vue不提倡直接操作dom元素,如果真的需要有,一般在自定义指令里完成.指令可以传递参数和修饰符,使指令的操作更加灵活.</p><ul><li>通过directive属性定义,在inserted时被插入DOM对象</li><li>注意: 第一个参数永远是el,指的是当前指令的DOM对象</li><li>在标签中使用时需要加上v-</li><li>参数 binding.value 可以获取指令的参数</li><li>修饰符 binding.modifiers 通过修饰符可以传递额外的参数,多个参数是对象类型,其中每一个为boolean类型.</li></ul></blockquote><h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><ul><li>过滤器可以同时使用多个,通过管道符隔开</li><li>过滤器可以传参(可以传多个)</li><li>过滤器通过使用Vue.filter定义第一个参数为过滤器的名称,第二个参数为一个回调函数回调函数也有一个参数,为要过滤元素的属性值.</li></ul><h2 id="列表渲染-v-for"><a href="#列表渲染-v-for" class="headerlink" title="列表渲染(v-for)"></a>列表渲染(v-for)</h2><blockquote><p>我们使用v-for指令根据一组数据的选项列表进行渲染.v-for指令需要以item in items形式的特殊语法,items是源数据组并且item是数组元素迭代的别名<br><strong>基本用法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id =&quot;example-1&quot;&gt;</span><br><span class="line">    &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">        &#123;&#123;item.message&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var example1 new = vue(&#123;</span><br><span class="line">    el:&quot;#example&quot;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        items:&#123;</span><br><span class="line">            &#123;message:&apos;foo&apos;&#125;,</span><br><span class="line">            &#123;message:&apos;bar&apos;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>在v-for块中,我们拥有对父作用域属性的完全访问权限,v-for还支持一个可选的第二个参数为当前的索引</li><li>注意:你也可以使用of代替in作为分隔符,因为它是最近Javascript迭代器的语法</li></ul><p><strong>对象迭代</strong></p><ul><li>可以提供三个参数:</li><li>value为键值,第二个参数key为键名,第三个参数为索引index</li></ul><p><strong>整数迭代</strong></p><ul><li>v-for也可以取整数.在这种情况下,它将重复多次模板</li></ul><p><strong>组件和v-for</strong></p><ul><li>在自定义组件里你也可以使用v-for</li><li>然而他不能自动传递数据到组件里,因为组件里有自己的作用域,为了传递迭代数据到组件里,我们要使用pros</li></ul><p><strong>key</strong></p><ul><li>为了给Vue一个提示,以便它能跟踪每个节点的身份,从而重用和重新排序现有元素,你需要为每一项提供一个唯一的key值,它的工作方式类似于一个属性,所以你需要使用v-bind来绑定动态值</li></ul><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变异方法-会改变原数组-且会触发更新"><a href="#变异方法-会改变原数组-且会触发更新" class="headerlink" title="变异方法:会改变原数组,且会触发更新"></a>变异方法:会改变原数组,且会触发更新</h3><ul><li>push,pro,shift,unshift,splice,sort,reverse<h3 id="非变异方法-不会改变原数组-总是返回一个新数组"><a href="#非变异方法-不会改变原数组-总是返回一个新数组" class="headerlink" title="非变异方法: 不会改变原数组,总是返回一个新数组"></a>非变异方法: 不会改变原数组,总是返回一个新数组</h3></li><li>filter concat slice map some <h3 id="显示过滤-排序结果"><a href="#显示过滤-排序结果" class="headerlink" title="显示过滤/排序结果"></a>显示过滤/排序结果</h3></li><li>有时,我们希望显示一个数组的过滤或者排序副本,但是不改变或重置原始数据,在这种情况下,可以创建或者返过滤或者排序数组的计算属性</li></ul><h3 id="Vue中的v-if与v-show的区别"><a href="#Vue中的v-if与v-show的区别" class="headerlink" title="Vue中的v-if与v-show的区别"></a>Vue中的v-if与v-show的区别</h3><blockquote><p>v-if的特点</p><ul><li>有较高的切换消耗,每次都会重新删除或者创建的元素.就是说,如果你每次都需要删除和切换频率很高的时候建议使用v-show<br>v-show的特点</li><li>每次不会重新进行dom元素的创建和删除,只是通过display属性切换元素的属性(display:none)不会占据原来的空间,有较高的初始渲染消耗</li><li>总结v-if有较高的切换消耗,v-show有较高的初始渲染消耗</li><li>元素需要频繁切换时,使用v-show,当运行条件不大可能改变的时候可以使用v-if.</li></ul></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>因为javascript的限制,Vue.js不能检测到下面数组的变化</li></ul><ol><li>直接用索引设置元素,如vm.items[0] = {}</li></ol><ul><li>为了解决这个问题,Vue.js扩展了观察数组,为它添加了一个$set()方法</li><li><code>example.items.$set(0,{childmsg:&#39;Changed!&#39;})</code></li></ul><ol start="2"><li>修改数据的长度,如vm.items.length= 0</li></ol><ul><li>至于这个问题,只需要使用一个空数组替换items.除了$set方法,Vue.js也为观察数组提供了$remove方法,用于从目标数组中查找并删除元素,在它内部调用它splice().因此,不必这样<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var index = this.items.indexOf(item)</span><br><span class="line">if(index!=-1)&#123;</span><br><span class="line">    this.items.splice(index,1)</span><br><span class="line">&#125;</span><br><span class="line">只用这样`this.items.$remove(item);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;插槽&quot;&gt;&lt;a href=&quot;#插槽&quot; class=&quot;headerlink&quot; title=&quot;插槽&quot;&gt;&lt;/a&gt;插槽&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;
      
    
    </summary>
    
      <category term="Vue基础语法" scheme="http://yoursite.com/categories/Vue%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="-Vue -基础" scheme="http://yoursite.com/tags/Vue-%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>原型对象总结</title>
    <link href="http://yoursite.com/2019/04/07/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/07/原型对象总结/</id>
    <published>2019-04-07T14:03:20.000Z</published>
    <updated>2019-04-15T12:34:25.824Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><blockquote><p>函数的prototype属性</p><ul><li>每个函数都有一个prototype属性,它默认指向一个Object空对象(即称为:原型对象)</li><li>原型对象中有一个constructor,它指向函数对象</li></ul></blockquote><ul><li>给原型对象添加属性(一般都是方法)<ul><li>作用: 函数的实例对象自动拥有原型中的属性(方法)</li><li>实例对象可以引用原型对象添加的属性(一般是方法);<blockquote><p>显式原型和隐式原型</p></blockquote></li></ul></li><li>每个函数fucntion都有一个prototype,即显式原型</li><li>每个实例对象都有一个<strong>proto</strong>,称为隐式原型</li><li>实例对象的隐性原型对应的值,为其对应的构造函数的显式原型的值</li><li>总结:</li><li>函数的prototype属性:在定义函数时自动添加,默认值是一个空Object对象(也就是执行函数定义时自动添加了prototype属性)</li><li>注意prototype保存的值是地址值,它是一个引用变量属性.</li><li>函数的<strong>proto</strong>属性:在创建对象时自动添加,默认值为prototype的值</li><li><p>程序员能直接操作显式对象,但不能直接操作隐式对象(ES6之前)</p></li><li><p>执行函数定义与执行函数的区别</p><ul><li>执行函数定义的时候,函数体还没有执行,只是定义了函数,本质上只是创建了一个函数对象 </li><li>加()的时候函数体才会执行调用</li></ul></li></ul><h3 id="引入数据类型和基本数据类型"><a href="#引入数据类型和基本数据类型" class="headerlink" title="引入数据类型和基本数据类型"></a>引入数据类型和基本数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = xxx; a中到底保存的是什么?</span><br></pre></td></tr></table></figure><ol><li>如果xxx是基本数据类型.则保存的就是这个数据</li><li>如果xxx是对象,保存的是这个对象的地址值</li><li>注意:xxx是一个变量,保存的xxx的内存内容(可能是基本数据,也可能是地址值)特别重要!!!!!</li></ol><ul><li><p>关于引用变量赋值的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;name:&apos;tom&apos;&#125;</span><br><span class="line">var obj2 = obj1;</span><br></pre></td></tr></table></figure></li><li><p>obj2保存的是obj1的内存内容,只不过obj1的内存内容是一个地址值</p></li><li>注意:2个引用变量指向同一个对象,通过一个变量修改对象内部数据,另一个变量看到的是修改以后的数据</li><li>2个引用变量指向同一个对象,让其中一个引用变量指向另一个对象,另一个引用变量依然指向前一个对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a  =&#123;age:12&#125;</span><br><span class="line">function fn2(obj)&#123;</span><br><span class="line">    obj = &#123;age:15&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn2(a);</span><br><span class="line">console.log(a.age);</span><br></pre></td></tr></table></figure><ul><li>特别重要:</li></ul><ol><li>首先将a的内容赋值给obj,在函数还没有调用的时候,a存储的值等于obj存储的值,指向同一个对象,指向{age:12};</li><li>下一步执行函数体,obj等于一个新的对象,将一个新的对象赋值给obj,指向{age:15};</li><li>这里有两个注意点: a的值没有变,没有改变a所指向的对象.修改了obj指向的内容</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>分为两大类</strong><br><strong>1.基本数据类型</strong></p><ol><li>Number:任意数值</li><li>string:任意文本</li><li>boolean: true/false</li><li>undefined: undefined</li><li>null: null</li></ol><ul><li>对象(引用类型)</li></ul><ol><li>object一般对象类型</li><li>array特别的对象类型(下标/内部数据有序)</li><li>function特别对象类型(可执行)</li></ol><p><strong>判断</strong></p><ul><li>typeof:</li><li>可以区别:数值,字符串,布尔值,undefined,function</li><li>不能区别null与对象 数组与对象</li><li>instanceof(专门用来判断对象的数据类型):object,Array与Function</li><li>=== 可以用来判断null与undefined</li></ul><blockquote><p>undefined与null区别</p><ul><li>underfined代表定义为赋值</li><li>null表示定义且赋值了,只是值为null</li></ul></blockquote><blockquote><p>什么时候给变量赋值为null呢&gt;?</p><ul><li>初始赋值 表示将要赋值为对象</li><li>结束的时候 让b指向的对象称为垃圾对象(被垃圾回收器回收)</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;原型对象&quot;&gt;&lt;a href=&quot;#原型对象&quot; class=&quot;headerlink&quot; title=&quot;原型对象&quot;&gt;&lt;/a&gt;原型对象&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;函数的prototype属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个函
      
    
    </summary>
    
      <category term="面向对象" scheme="http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="-Javascript -面向对象" scheme="http://yoursite.com/tags/Javascript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
